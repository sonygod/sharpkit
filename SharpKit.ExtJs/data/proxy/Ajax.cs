//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using SharpKit.JavaScript;
#region Ext.data.proxy
namespace Ext.data.proxy
{
    #region Ajax
    /// <summary>
    /// AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to
    /// load data from the server, usually to be placed into a Store. Let&#39;s take a look at a typical
    /// setup. Here we&#39;re going to set up a Store that has an AjaxProxy. To prepare, we&#39;ll also set up a
    /// Model: Ext.define(&#39;User&#39;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [&#39;id&#39;, &#39;name&#39;, &#39;email&#39;]
    /// });
    /// //The Store contains the AjaxProxy as an inline configuration
    /// var store = new Ext.data.Store({
    /// model: &#39;User&#39;,
    /// proxy: {
    /// type: &#39;ajax&#39;,
    /// url : &#39;users.json&#39;
    /// }
    /// });
    /// store.load();
    /// Our example is going to load user data into a Store, so we start off by defining a Model
    /// with the fields that we expect the server to return. Next we set up the Store itself, along with a proxy
    /// configuration. This configuration was automatically turned into an Ext.data.proxy.Ajax instance, with the url we
    /// specified being passed into AjaxProxy&#39;s constructor. It&#39;s as if we&#39;d done this: new Ext.data.proxy.Ajax({
    /// url: &#39;users.json&#39;,
    /// model: &#39;User&#39;,
    /// reader: &#39;json&#39;
    /// });
    /// A couple of extra configurations appeared here - model and reader. These are set by default
    /// when we create the proxy via the Store - the Store already knows about the Model, and Proxy&#39;s default
    /// Reader is JsonReader. Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
    /// (&#39;users.json&#39; in this case). As we&#39;re performing a read, it sends a GET request to that url (see actionMethods
    /// to customize this - by default any kind of read will be sent as a GET request and any kind of write will be sent as a
    /// POST request). Limitations AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com
    /// it cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
    /// talking to each other via AJAX. If you need to read data from another domain and can&#39;t set up a proxy server (some software that runs on your own
    /// domain&#39;s web server and transparently forwards requests to http://domainB.com, making it look like they actually came
    /// from http://domainA.com), you can use Ext.data.proxy.JsonP and a technique known as JSON-P (JSON with
    /// Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
    /// JSON-P responses. See JsonPProxy&#39;s introduction docs for more details. Readers and Writers AjaxProxy can be configured to use any type of Reader to decode the server&#39;s response. If
    /// no Reader is supplied, AjaxProxy will default to using a JsonReader. Reader configuration
    /// can be passed in as a simple object, which the Proxy automatically turns into a Reader
    /// instance: var proxy = new Ext.data.proxy.Ajax({
    /// model: &#39;User&#39;,
    /// reader: {
    /// type: &#39;xml&#39;,
    /// root: &#39;users&#39;
    /// }
    /// });
    /// proxy.getReader(); //returns an XmlReader instance based on the config we supplied
    /// Url generation AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
    /// each request. These are controlled with the following configuration options:  pageParam - controls how the page number is sent to the server
    /// (see also startParam and limitParam) sortParam - controls how sort information is sent to the server groupParam - controls how grouping information is sent to the server filterParam - controls how filter information is sent to the server  Each request sent by AjaxProxy is described by an Operation. To see how we can
    /// customize the generated urls, let&#39;s say we&#39;re loading the Proxy with the following Operation: var operation = new Ext.data.Operation({
    /// action: &#39;read&#39;,
    /// page  : 2
    /// });
    /// Now we&#39;ll issue the request for this Operation by calling read: var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;
    /// });
    /// proxy.read(operation); //GET /users?page=2
    /// Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is
    /// sent to the server: var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;,
    /// pagePage: &#39;pageNumber&#39;
    /// });
    /// proxy.read(operation); //GET /users?pageNumber=2
    /// Alternatively, our Operation could have been configured to send start and limit parameters instead of page: var operation = new Ext.data.Operation({
    /// action: &#39;read&#39;,
    /// start : 50,
    /// limit : 25
    /// });
    /// var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;
    /// });
    /// proxy.read(operation); //GET /users?start=50&amp;limit=25
    /// Again we can customize this url: var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;,
    /// startParam: &#39;startIndex&#39;,
    /// limitParam: &#39;limitIndex&#39;
    /// });
    /// proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex=25
    /// AjaxProxy will also send sort and filter information to the server. Let&#39;s take a look at how this looks with a
    /// more expressive Operation object: var operation = new Ext.data.Operation({
    /// action: &#39;read&#39;,
    /// sorters: [
    /// new Ext.util.Sorter({
    /// property : &#39;name&#39;,
    /// direction: &#39;ASC&#39;
    /// }),
    /// new Ext.util.Sorter({
    /// property : &#39;age&#39;,
    /// direction: &#39;DESC&#39;
    /// })
    /// ],
    /// filters: [
    /// new Ext.util.Filter({
    /// property: &#39;eyeColor&#39;,
    /// value   : &#39;brown&#39;
    /// })
    /// ]
    /// });
    /// This is the type of object that is generated internally when loading a Store with sorters
    /// and filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like
    /// this (note that the url is escaped before sending the request, but is left unescaped here for clarity): var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;
    /// });
    /// proxy.read(operation); //GET /users?sort=[{&quot;property&quot;:&quot;name&quot;,&quot;direction&quot;:&quot;ASC&quot;},{&quot;property&quot;:&quot;age&quot;,&quot;direction&quot;:&quot;DESC&quot;}]&amp;filter=[{&quot;property&quot;:&quot;eyeColor&quot;,&quot;value&quot;:&quot;brown&quot;}]
    /// We can again customize how this is created by supplying a few configuration options. Let&#39;s say our server is set
    /// up to receive sorting information is a format like &quot;sortBy=name#ASC,age#DESC&quot;. We can configure AjaxProxy to provide
    /// that format like this:  var proxy = new Ext.data.proxy.Ajax({
    /// url: &#39;/users&#39;,
    /// sortParam: &#39;sortBy&#39;,
    /// filterParam: &#39;filterBy&#39;,
    /// //our custom implementation of sorter encoding - turns our sorters into &quot;name#ASC,age#DESC&quot;
    /// encodeSorters: function(sorters) {
    /// var length   = sorters.length,
    /// sortStrs = [],
    /// sorter, i;
    /// for (i = 0; i  We can also provide a custom encodeFilters function to encode our filters.
    /// </summary>
    [JsType(JsMode.Prototype, Export=false)]
    public partial class Ajax : Server, Ext.util.Observable
    {
        /// <summary>
        /// Note that if this HttpProxy is being used by a Store, then the
        /// Store's call to load will override any specified callb...
        /// </summary>
        public Ajax(){}
        /// <summary>
        /// Returns the HTTP method name for a given request. ...
        /// </summary>
        public JsString getMethod(Request request){return null;}
        /// <summary>
        /// Mapping of action name to HTTP request method. ...
        /// </summary>
        public object actionMethods{get;set;}
        public Ajax(Ext.data.proxy.AjaxConfig config){}
    }
    #endregion
    #region AjaxConfig
    [JsType(JsMode.Json, Export=false)]
    public partial class AjaxConfig : ServerConfig
    {
        /// <summary>
        /// Any headers to add to the Ajax request. ...
        /// </summary>
        public object headers{get;set;}
    }
    #endregion
    #region AjaxEvents
    [JsType(JsMode.Json, Export=false)]
    public partial class AjaxEvents : ServerEvents
    {
    }
    #endregion
}
#endregion
