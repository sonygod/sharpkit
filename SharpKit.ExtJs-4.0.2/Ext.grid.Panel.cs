//***************************************************
//* This file was generated by tool
//* 20/07/2011 19:12:25
//* SharpKit
//***************************************************
using SharpKit.JavaScript;
#region Ext.grid
namespace Ext.grid
{
    #region Panel
    /// <summary>
    /// Grids are an excellent way of showing large amounts of tabular data on the client side. Essentially a supercharged
    /// &amp;lt;table&amp;gt;, GridPanel makes it easy to fetch, sort and filter large amounts of data. Grids are composed of 2 main pieces - a Store full of data and a set of columns to render.  Basic GridPanel Ext.create(&#39;Ext.data.Store&#39;, {
    /// storeId:&#39;simpsonsStore&#39;,
    /// fields:[&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
    /// data:{&#39;items&#39;:[
    /// {&quot;name&quot;:&quot;Lisa&quot;, &quot;email&quot;:&quot;lisa@simpsons.com&quot;, &quot;phone&quot;:&quot;555-111-1224&quot;},
    /// {&quot;name&quot;:&quot;Bart&quot;, &quot;email&quot;:&quot;bart@simpsons.com&quot;, &quot;phone&quot;:&quot;555--222-1234&quot;},
    /// {&quot;name&quot;:&quot;Homer&quot;, &quot;email&quot;:&quot;home@simpsons.com&quot;, &quot;phone&quot;:&quot;555-222-1244&quot;},
    /// {&quot;name&quot;:&quot;Marge&quot;, &quot;email&quot;:&quot;marge@simpsons.com&quot;, &quot;phone&quot;:&quot;555-222-1254&quot;}
    /// ]},
    /// proxy: {
    /// type: &#39;memory&#39;,
    /// reader: {
    /// type: &#39;json&#39;,
    /// root: &#39;items&#39;
    /// }
    /// }
    /// });
    /// Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// title: &#39;Simpsons&#39;,
    /// store: Ext.data.StoreManager.lookup(&#39;simpsonsStore&#39;),
    /// columns: [
    /// {header: &#39;Name&#39;,  dataIndex: &#39;name&#39;},
    /// {header: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex:1},
    /// {header: &#39;Phone&#39;, dataIndex: &#39;phone&#39;}
    /// ],
    /// height: 200,
    /// width: 400,
    /// renderTo: Ext.getBody()
    /// });
    /// The code above produces a simple grid with three columns. We specified a Store which will load JSON data inline.
    /// In most apps we would be placing the grid inside another container and wouldn&#39;t need to use the
    /// height, width and renderTo configurations but they are included here to make it easy to get
    /// up and running. The grid we created above will contain a header bar with a title (&#39;Simpsons&#39;), a row of column headers directly underneath
    /// and finally the grid rows under the headers. Configuring columns By default, each column is sortable and will toggle between ASC and DESC sorting when you click on its header. Each
    /// column header is also reorderable by default, and each gains a drop-down menu with options to hide and show columns.
    /// It&#39;s easy to configure each column - here we use the same example as above and just modify the columns config: columns: [
    /// {
    /// header: &#39;Name&#39;,
    /// dataIndex: &#39;name&#39;,
    /// sortable: false,
    /// hideable: false,
    /// flex: 1
    /// },
    /// {
    /// header: &#39;Email&#39;,
    /// dataIndex: &#39;email&#39;,
    /// hidden: true
    /// },
    /// {
    /// header: &#39;Phone&#39;,
    /// dataIndex: &#39;phone&#39;,
    /// width: 100
    /// }
    /// ]
    /// We turned off sorting and hiding on the &#39;Name&#39; column so clicking its header now has no effect. We also made the Email
    /// column hidden by default (it can be shown again by using the menu on any other column). We also set the Phone column to
    /// a fixed with of 100px and flexed the Name column, which means it takes up all remaining width after the other columns
    /// have been accounted for. See the column docs for more details. Renderers As well as customizing columns, it&#39;s easy to alter the rendering of individual cells using renderers. A renderer is
    /// tied to a particular column and is passed the value that would be rendered into each cell in that column. For example,
    /// we could define a renderer function for the email column to turn each email address into a mailto link: columns: [
    /// {
    /// header: &#39;Email&#39;,
    /// dataIndex: &#39;email&#39;,
    /// renderer: function(value) {
    /// return Ext.String.format(&#39;&amp;lt;a href=&quot;mailto:{0}&quot;&amp;gt;{1}&amp;lt;/a&amp;gt;&#39;, value, value);
    /// }
    /// }
    /// ]
    /// See the column docs for more information on renderers. Selection Models Sometimes all you want is to render data onto the screen for viewing, but usually it&#39;s necessary to interact with or
    /// update that data. Grids use a concept called a Selection Model, which is simply a mechanism for selecting some part of
    /// the data in the grid. The two main types of Selection Model are RowSelectionModel, where entire rows are selected, and
    /// CellSelectionModel, where individual cells are selected. Grids use a Row Selection Model by default, but this is easy to customise like so: Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// selType: &#39;cellmodel&#39;,
    /// store: ...
    /// });
    /// Specifying the cellmodel changes a couple of things. Firstly, clicking on a cell now
    /// selects just that cell (using a rowmodel will select the entire row), and secondly the
    /// keyboard navigation will walk from cell to cell instead of row to row. Cell-based selection models are usually used in
    /// conjunction with editing.  Editing Grid has built-in support for in-line editing. There are two chief editing modes - cell editing and row editing. Cell
    /// editing is easy to add to your existing column setup - here we&#39;ll just modify the example above to include an editor
    /// on both the name and the email columns: Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// title: &#39;Simpsons&#39;,
    /// store: Ext.data.StoreManager.lookup(&#39;simpsonsStore&#39;),
    /// columns: [
    /// {header: &#39;Name&#39;,  dataIndex: &#39;name&#39;, field: &#39;textfield&#39;},
    /// {header: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex:1,
    /// field:{
    /// xtype:&#39;textfield&#39;,
    /// allowBlank:false
    /// }
    /// },
    /// {header: &#39;Phone&#39;, dataIndex: &#39;phone&#39;}
    /// ],
    /// selType: &#39;cellmodel&#39;,
    /// plugins: [
    /// Ext.create(&#39;Ext.grid.plugin.CellEditing&#39;, {
    /// clicksToEdit: 1
    /// })
    /// ],
    /// height: 200,
    /// width: 400,
    /// renderTo: Ext.getBody()
    /// });
    /// This requires a little explanation. We&#39;re passing in store and columns as normal, but
    /// this time we&#39;ve also specified a field on two of our columns. For the Name column we just want a default
    /// textfield to edit the value, so we specify &#39;textfield&#39;. For the Email column we customized the editor slightly by
    /// passing allowBlank: false, which will provide inline validation. To support cell editing, we also specified that the grid should use the &#39;cellmodel&#39; selType, and created an
    /// instance of the CellEditing plugin, which we configured to activate each editor after a
    /// single click.  Row Editing The other type of editing is row-based editing, using the RowEditor component. This enables you to edit an entire row
    /// at a time, rather than editing cell by cell. Row Editing works in exactly the same way as cell editing, all we need to
    /// do is change the plugin type to Ext.grid.plugin.RowEditing, and set the selType to &#39;rowmodel&#39;: Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// title: &#39;Simpsons&#39;,
    /// store: Ext.data.StoreManager.lookup(&#39;simpsonsStore&#39;),
    /// columns: [
    /// {header: &#39;Name&#39;,  dataIndex: &#39;name&#39;, field: &#39;textfield&#39;},
    /// {header: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex:1,
    /// field:{
    /// xtype:&#39;textfield&#39;,
    /// allowBlank:false
    /// }
    /// },
    /// {header: &#39;Phone&#39;, dataIndex: &#39;phone&#39;}
    /// ],
    /// selType: &#39;rowmodel&#39;,
    /// plugins: [
    /// Ext.create(&#39;Ext.grid.plugin.RowEditing&#39;, {
    /// clicksToEdit: 1
    /// })
    /// ],
    /// height: 200,
    /// width: 400,
    /// renderTo: Ext.getBody()
    /// });
    /// Again we passed some configuration to our Ext.grid.plugin.RowEditing plugin, and now when we click each row a row
    /// editor will appear and enable us to edit each of the columns we have specified an editor for. Sorting &amp;amp; Filtering Every grid is attached to a Store, which provides multi-sort and filtering capabilities. It&#39;s
    /// easy to set up a grid to be sorted from the start: var myGrid = Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// store: {
    /// fields: [&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
    /// sorters: [&#39;name&#39;, &#39;phone&#39;]
    /// },
    /// columns: [
    /// {text: &#39;Name&#39;,  dataIndex: &#39;name&#39;},
    /// {text: &#39;Email&#39;, dataIndex: &#39;email&#39;}
    /// ]
    /// });
    /// Sorting at run time is easily accomplished by simply clicking each column header. If you need to perform sorting on
    /// more than one field at run time it&#39;s easy to do so by adding new sorters to the store: myGrid.store.sort([
    /// {property: &#39;name&#39;,  direction: &#39;ASC&#39;},
    /// {property: &#39;email&#39;, direction: &#39;DESC&#39;},
    /// ]);
    /// Grouping Grid supports the grouping of rows by any field. For example if we had a set of employee records, we might want to
    /// group by the department that each employee works in. Here&#39;s how we might set that up: var store = Ext.create(&#39;Ext.data.Store&#39;, {
    /// storeId:&#39;employeeStore&#39;,
    /// fields:[&#39;name&#39;, &#39;senority&#39;, &#39;department&#39;],
    /// groupField: &#39;department&#39;,
    /// data:{&#39;employees&#39;:[
    /// {&quot;name&quot;:&quot;Michael Scott&quot;, &quot;senority&quot;:7, &quot;department&quot;:&quot;Manangement&quot;},
    /// {&quot;name&quot;:&quot;Dwight Schrute&quot;, &quot;senority&quot;:2, &quot;department&quot;:&quot;Sales&quot;},
    /// {&quot;name&quot;:&quot;Jim Halpert&quot;, &quot;senority&quot;:3, &quot;department&quot;:&quot;Sales&quot;},
    /// {&quot;name&quot;:&quot;Kevin Malone&quot;, &quot;senority&quot;:4, &quot;department&quot;:&quot;Accounting&quot;},
    /// {&quot;name&quot;:&quot;Angela Martin&quot;, &quot;senority&quot;:5, &quot;department&quot;:&quot;Accounting&quot;}
    /// ]},
    /// proxy: {
    /// type: &#39;memory&#39;,
    /// reader: {
    /// type: &#39;json&#39;,
    /// root: &#39;employees&#39;
    /// }
    /// }
    /// });
    /// Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// title: &#39;Employees&#39;,
    /// store: Ext.data.StoreManager.lookup(&#39;employeeStore&#39;),
    /// columns: [
    /// {header: &#39;Name&#39;,  dataIndex: &#39;name&#39;},
    /// {header: &#39;Senority&#39;, dataIndex: &#39;senority&#39;}
    /// ],
    /// features: [{ftype:&#39;grouping&#39;}],
    /// width: 200,
    /// height: 275,
    /// renderTo: Ext.getBody()
    /// });
    /// Infinite Scrolling Grid supports infinite scrolling as an alternative to using a paging toolbar. Your users can scroll through thousands
    /// of records without the performance penalties of renderering all the records on screen at once. The grid should be bound
    /// to a store with a pageSize specified. var grid = Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// // Use a PagingGridScroller (this is interchangeable with a PagingToolbar)
    /// verticalScrollerType: &#39;paginggridscroller&#39;,
    /// // do not reset the scrollbar when the view refreshs
    /// invalidateScrollerOnRefresh: false,
    /// // infinite scrolling does not support selection
    /// disableSelection: true,
    /// // ...
    /// });
    /// Paging Grid supports paging through large sets of data via a PagingToolbar or PagingGridScroller (see the Infinite Scrolling section above).
    /// To leverage paging via a toolbar or scroller, you need to set a pageSize configuration on the Store. var itemsPerPage = 2;   // set the number of items you want per page
    /// var store = Ext.create(&#39;Ext.data.Store&#39;, {
    /// id:&#39;simpsonsStore&#39;,
    /// autoLoad: false,
    /// fields:[&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
    /// pageSize: itemsPerPage, // items per page
    /// proxy: {
    /// type: &#39;ajax&#39;,
    /// url: &#39;pagingstore.js&#39;,  // url that will load data with respect to start and limit params
    /// reader: {
    /// type: &#39;json&#39;,
    /// root: &#39;items&#39;,
    /// totalProperty: &#39;total&#39;
    /// }
    /// }
    /// });
    /// // specify segment of data you want to load using params
    /// store.load({
    /// params:{
    /// start:0,
    /// limit: itemsPerPage
    /// }
    /// });
    /// Ext.create(&#39;Ext.grid.Panel&#39;, {
    /// title: &#39;Simpsons&#39;,
    /// store: store,
    /// columns: [
    /// {header: &#39;Name&#39;,  dataIndex: &#39;name&#39;},
    /// {header: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex:1},
    /// {header: &#39;Phone&#39;, dataIndex: &#39;phone&#39;}
    /// ],
    /// width: 400,
    /// height: 125,
    /// dockedItems: [{
    /// xtype: &#39;pagingtoolbar&#39;,
    /// store: store,   // same store GridPanel is using
    /// dock: &#39;bottom&#39;,
    /// displayInfo: true
    /// }],
    /// renderTo: Ext.getBody()
    /// });
    /// </summary>
    [JsType(JsMode.Prototype, Export=false)]
    public partial class Panel : Ext.panel.Table, Ext.util.Floating, Ext.util.Observable, Ext.util.Animate, Ext.state.Stateful
    {
    }
    #endregion
    #region PanelConfig
    [JsType(JsMode.Json, Export=false)]
    public partial class PanelConfig : Ext.panel.TableConfig
    {
        public bool columnLines{get;set;}
    }
    #endregion
    #region PanelEvents
    [JsType(JsMode.Json, Export=false)]
    public partial class PanelEvents : Ext.panel.TableEvents
    {
    }
    #endregion
}
#endregion
