//***************************************************
//* This file was generated by tool
//* 20/07/2011 17:29:50
//* SharpKit
//***************************************************
using SharpKit.JavaScript;
#region Ext.data.reader
namespace Ext.data.reader
{
    #region Xml
    /// <summary>
    /// The XML Reader is used by a Proxy to read a server response that is sent back in XML format. This usually
    /// happens as a result of loading a Store - for example we might create something like this: Ext.define(&#39;User&#39;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [&#39;id&#39;, &#39;name&#39;, &#39;email&#39;]
    /// });
    /// var store = new Ext.data.Store({
    /// model: &#39;User&#39;,
    /// proxy: {
    /// type: &#39;ajax&#39;,
    /// url : &#39;users.xml&#39;,
    /// reader: {
    /// type: &#39;xml&#39;,
    /// record: &#39;user&#39;
    /// }
    /// }
    /// });
    /// The example above creates a &#39;User&#39; model. Models are explained in the Model docs if you&#39;re
    /// not already familiar with them. We created the simplest type of XML Reader possible by simply telling our Store&#39;s
    /// Proxy that we want a XML Reader. The Store automatically passes the configured model to the
    /// Store, so it is as if we passed this instead:
    /// reader: {
    /// type : &#39;xml&#39;,
    /// model: &#39;User&#39;,
    /// record: &#39;user&#39;
    /// }
    /// The reader we set up is ready to read data from our server - at the moment it will accept a response like this: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Ed Spencer&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;ed@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Abe Elias&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;abe@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// The XML Reader uses the configured record option to pull out the data for each record - in this case we
    /// set record to &#39;user&#39;, so each &amp;lt;user&amp;gt; above will be converted into a User model. Reading other XML formats If you already have your XML format defined and it doesn&#39;t look quite like what we have above, you can usually
    /// pass XmlReader a couple of configuration options to make it parse your format. For example, we can use the
    /// root configuration to parse data that comes back like this: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    /// &amp;lt;users&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Ed Spencer&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;ed@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Abe Elias&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;abe@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;/users&amp;gt;
    /// To parse this we just pass in a root configuration that matches the &#39;users&#39; above: reader: {
    /// type  : &#39;xml&#39;,
    /// root  : &#39;users&#39;,
    /// record: &#39;user&#39;
    /// }
    /// Note that XmlReader doesn&#39;t care whether your root and record elements are nested deep inside
    /// a larger structure, so a response like this will still work:
    /// &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    /// &amp;lt;deeply&amp;gt;
    /// &amp;lt;nested&amp;gt;
    /// &amp;lt;xml&amp;gt;
    /// &amp;lt;users&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Ed Spencer&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;ed@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Abe Elias&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;abe@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;/users&amp;gt;
    /// &amp;lt;/xml&amp;gt;
    /// &amp;lt;/nested&amp;gt;
    /// &amp;lt;/deeply&amp;gt;
    /// Response metadata The server can return additional data in its response, such as the total number of records
    /// and the success status of the response. These are typically included in the XML response
    /// like this: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    /// &amp;lt;total&amp;gt;100&amp;lt;/total&amp;gt;
    /// &amp;lt;success&amp;gt;true&amp;lt;/success&amp;gt;
    /// &amp;lt;users&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Ed Spencer&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;ed@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;user&amp;gt;
    /// &amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;
    /// &amp;lt;name&amp;gt;Abe Elias&amp;lt;/name&amp;gt;
    /// &amp;lt;email&amp;gt;abe@sencha.com&amp;lt;/email&amp;gt;
    /// &amp;lt;/user&amp;gt;
    /// &amp;lt;/users&amp;gt;
    /// If these properties are present in the XML response they can be parsed out by the XmlReader and used by the
    /// Store that loaded it. We can set up the names of these properties by specifying a final pair of configuration
    /// options: reader: {
    /// type: &#39;xml&#39;,
    /// root: &#39;users&#39;,
    /// totalProperty  : &#39;total&#39;,
    /// successProperty: &#39;success&#39;
    /// }
    /// These final options are not necessary to make the Reader work, but can be useful when the server needs to report
    /// an error or if it needs to indicate that there is a lot of data available of which only a subset is currently being
    /// returned. Response format Note: in order for the browser to parse a returned XML document, the Content-Type header in the HTTP
    /// response must be set to &quot;text/xml&quot; or &quot;application/xml&quot;. This is very important - the XmlReader will not
    /// work correctly otherwise.
    /// </summary>
    [JsType(JsMode.Prototype, Export=false)]
    public partial class Xml : Reader
    {
        /// <summary>
        /// DEPRECATED - will be removed in Ext JS 5.0. ...
        /// </summary>
        public object xmlData{get;set;}
    }
    #endregion
    #region XmlConfig
    [JsType(JsMode.Json, Export=false)]
    public partial class XmlConfig
    {
        public JsString record{get;set;}
    }
    #endregion
    #region XmlEvents
    [JsType(JsMode.Json, Export=false)]
    public partial class XmlEvents
    {
    }
    #endregion
}
#endregion
