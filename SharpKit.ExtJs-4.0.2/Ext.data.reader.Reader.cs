//***************************************************
//* This file was generated by tool
//* 20/07/2011 19:12:24
//* SharpKit
//***************************************************
using SharpKit.JavaScript;
#region Ext.data.reader
namespace Ext.data.reader
{
    #region Reader
    /// <summary>
    /// Readers are used to interpret data to be loaded into a Model instance or a Store
    /// - usually in response to an AJAX request. This is normally handled transparently by passing some configuration to either the
    /// Model or the Store in question - see their documentation for further details. Loading Nested Data Readers have the ability to automatically load deeply-nested data objects based on the associations
    /// configured on each Model. Below is an example demonstrating the flexibility of these associations in a fictional CRM system which
    /// manages a User, their Orders, OrderItems and Products. First we&#39;ll define the models:
    /// Ext.define(&quot;User&quot;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [
    /// &#39;id&#39;, &#39;name&#39;
    /// ],
    /// hasMany: {model: &#39;Order&#39;, name: &#39;orders&#39;},
    /// proxy: {
    /// type: &#39;rest&#39;,
    /// url : &#39;users.json&#39;,
    /// reader: {
    /// type: &#39;json&#39;,
    /// root: &#39;users&#39;
    /// }
    /// }
    /// });
    /// Ext.define(&quot;Order&quot;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [
    /// &#39;id&#39;, &#39;total&#39;
    /// ],
    /// hasMany  : {model: &#39;OrderItem&#39;, name: &#39;orderItems&#39;, associationKey: &#39;order_items&#39;},
    /// belongsTo: &#39;User&#39;
    /// });
    /// Ext.define(&quot;OrderItem&quot;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [
    /// &#39;id&#39;, &#39;price&#39;, &#39;quantity&#39;, &#39;order_id&#39;, &#39;product_id&#39;
    /// ],
    /// belongsTo: [&#39;Order&#39;, {model: &#39;Product&#39;, associationKey: &#39;product&#39;}]
    /// });
    /// Ext.define(&quot;Product&quot;, {
    /// extend: &#39;Ext.data.Model&#39;,
    /// fields: [
    /// &#39;id&#39;, &#39;name&#39;
    /// ],
    /// hasMany: &#39;OrderItem&#39;
    /// });
    /// This may be a lot to take in - basically a User has many Orders, each of which is composed of several OrderItems. Finally,
    /// each OrderItem has a single Product. This allows us to consume data like this: {
    /// &quot;users&quot;: [
    /// {
    /// &quot;id&quot;: 123,
    /// &quot;name&quot;: &quot;Ed&quot;,
    /// &quot;orders&quot;: [
    /// {
    /// &quot;id&quot;: 50,
    /// &quot;total&quot;: 100,
    /// &quot;order_items&quot;: [
    /// {
    /// &quot;id&quot;      : 20,
    /// &quot;price&quot;   : 40,
    /// &quot;quantity&quot;: 2,
    /// &quot;product&quot; : {
    /// &quot;id&quot;: 1000,
    /// &quot;name&quot;: &quot;MacBook Pro&quot;
    /// }
    /// },
    /// {
    /// &quot;id&quot;      : 21,
    /// &quot;price&quot;   : 20,
    /// &quot;quantity&quot;: 3,
    /// &quot;product&quot; : {
    /// &quot;id&quot;: 1001,
    /// &quot;name&quot;: &quot;iPhone&quot;
    /// }
    /// }
    /// ]
    /// }
    /// ]
    /// }
    /// ]
    /// }
    /// The JSON response is deeply nested - it returns all Users (in this case just 1 for simplicity&#39;s sake), all of the Orders
    /// for each User (again just 1 in this case), all of the OrderItems for each Order (2 order items in this case), and finally
    /// the Product associated with each OrderItem. Now we can read the data and use it as follows:
    /// var store = new Ext.data.Store({
    /// model: &quot;User&quot;
    /// });
    /// store.load({
    /// callback: function() {
    /// //the user that was loaded
    /// var user = store.first();
    /// console.log(&quot;Orders for &quot; + user.get(&#39;name&#39;) + &quot;:&quot;)
    /// //iterate over the Orders for each User
    /// user.orders().each(function(order) {
    /// console.log(&quot;Order ID: &quot; + order.getId() + &quot;, which contains items:&quot;);
    /// //iterate over the OrderItems for each Order
    /// order.orderItems().each(function(orderItem) {
    /// //we know that the Product data is already loaded, so we can use the synchronous getProduct
    /// //usually, we would use the asynchronous version (see Ext.data.BelongsToAssociation)
    /// var product = orderItem.getProduct();
    /// console.log(orderItem.get(&#39;quantity&#39;) + &#39; orders of &#39; + product.get(&#39;name&#39;));
    /// });
    /// });
    /// }
    /// });
    /// Running the code above results in the following: Orders for Ed:
    /// Order ID: 50, which contains items:
    /// 2 orders of MacBook Pro
    /// 3 orders of iPhone
    /// </summary>
    [JsType(JsMode.Prototype, Export=false)]
    public partial class Reader
    {
        /// <summary>
        /// Creates new Reader. ...
        /// </summary>
        public object constructor(object config=null){return null;}
        /// <summary>
        /// Takes a raw response object (as passed to this.read) and returns the useful data segment of it. ...
        /// </summary>
        public object getResponseData(object response){return null;}
        /// <summary>
        /// Reads the given response object. ...
        /// </summary>
        public ResultSet read(object response){return null;}
        /// <summary>
        /// Abstracts common functionality used by all Reader subclasses. ...
        /// </summary>
        public ResultSet readRecords(object data){return null;}
        /// <summary>
        /// The raw data object that was last passed to readRecords. ...
        /// </summary>
        public object rawData{get;set;}
    }
    #endregion
    #region ReaderConfig
    [JsType(JsMode.Json, Export=false)]
    public partial class ReaderConfig
    {
        /// <summary>
        /// Name of the property within a row object
        /// that contains a record identifier value. ...
        /// </summary>
        public JsString idProperty{get;set;}
        /// <summary>
        /// True to automatically parse models nested within other models in a response
        /// object. ...
        /// </summary>
        public bool implicitIncludes{get;set;}
        /// <summary>
        /// The name of the property which contains a response message. ...
        /// </summary>
        public JsString messageProperty{get;set;}
        /// <summary>
        /// Required. ...
        /// </summary>
        public JsString root{get;set;}
        /// <summary>
        /// Name of the property from which to
        /// retrieve the success attribute. ...
        /// </summary>
        public JsString successProperty{get;set;}
        /// <summary>
        /// Name of the property from which to
        /// retrieve the total number of records in the dataset. ...
        /// </summary>
        public JsString totalProperty{get;set;}
    }
    #endregion
    #region ReaderEvents
    [JsType(JsMode.Json, Export=false)]
    public partial class ReaderEvents
    {
    }
    #endregion
}
#endregion
