//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace SharpKit.NodeJs
{
    /// <summary>
    /// <p><code>ChildProcess</code> is an [EventEmitter][].
    /// </p>
    /// <p>Child processes always have three streams associated with them. <code>child.stdin</code>,
    /// <code>child.stdout</code>, and <code>child.stderr</code>.  These may be shared with the stdio
    /// streams of the parent process, or they may be separate stream objects
    /// which can be piped to and from.
    /// </p>
    /// <p>The ChildProcess class is not intended to be used directly.  Use the
    /// <code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.
    /// </p>
    /// </summary>
    public partial class ChildProcess
    {
        /// <summary>
        /// <p>To close the IPC connection between parent and child use the
        /// <code>child.disconnect()</code> method. This allows the child to exit gracefully since
        /// there is no IPC channel keeping it alive. When calling this method the
        /// <code>disconnect</code> event will be emitted in both parent and child, and the
        /// <code>connected</code> flag will be set to <code>false</code>. Please note that you can also call
        /// <code>process.disconnect()</code> in the child process.
        /// </p>
        /// </summary>
        public object disconnect(){return null;}
        /// <summary>
        /// <p>Send a signal to the child process. If no argument is given, the process will
        /// be sent <code>&#39;SIGTERM&#39;</code>. See <code>signal(7)</code> for a list of available signals.
        /// </p>
        /// <pre><code>var spawn = require(&#39;child_process&#39;).spawn,
        /// grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);
        /// grep.on(&#39;exit&#39;, function (code, signal) {
        /// console.log(&#39;child process terminated due to receipt of signal &#39;+signal);
        /// });
        /// // send SIGHUP to process
        /// grep.kill(&#39;SIGHUP&#39;);</code></pre>
        /// <p>Note that while the function is called <code>kill</code>, the signal delivered to the child
        /// process may not actually kill it.  <code>kill</code> really just sends a signal to a process.
        /// </p>
        /// <p>See <code>kill(2)</code>
        /// </p>
        /// </summary>
        public object kill(){return null;}
        /// <summary>
        /// <p>Send a signal to the child process. If no argument is given, the process will
        /// be sent <code>&#39;SIGTERM&#39;</code>. See <code>signal(7)</code> for a list of available signals.
        /// </p>
        /// <pre><code>var spawn = require(&#39;child_process&#39;).spawn,
        /// grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);
        /// grep.on(&#39;exit&#39;, function (code, signal) {
        /// console.log(&#39;child process terminated due to receipt of signal &#39;+signal);
        /// });
        /// // send SIGHUP to process
        /// grep.kill(&#39;SIGHUP&#39;);</code></pre>
        /// <p>Note that while the function is called <code>kill</code>, the signal delivered to the child
        /// process may not actually kill it.  <code>kill</code> really just sends a signal to a process.
        /// </p>
        /// <p>See <code>kill(2)</code>
        /// </p>
        /// </summary>
        public object kill(object signal){return null;}
        /// <summary>
        /// <p>When using <code>child_process.fork()</code> you can write to the child using
        /// <code>child.send(message, [sendHandle])</code> and messages are received by
        /// a <code>&#39;message&#39;</code> event on the child.
        /// </p>
        /// <p>For example:
        /// </p>
        /// <pre><code>var cp = require(&#39;child_process&#39;);
        /// var n = cp.fork(__dirname + &#39;/sub.js&#39;);
        /// n.on(&#39;message&#39;, function(m) {
        /// console.log(&#39;PARENT got message:&#39;, m);
        /// });
        /// n.send({ hello: &#39;world&#39; });</code></pre>
        /// <p>And then the child script, <code>&#39;sub.js&#39;</code> might look like this:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m) {
        /// console.log(&#39;CHILD got message:&#39;, m);
        /// });
        /// process.send({ foo: &#39;bar&#39; });</code></pre>
        /// <p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
        /// will emit objects each time it receives a message on its channel.
        /// </p>
        /// <p>There is a special case when sending a <code>{cmd: &#39;NODE_foo&#39;}</code> message. All messages
        /// containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
        /// the <code>message</code> event, since they are internal messages used by node core.
        /// Messages containing the prefix are emitted in the <code>internalMessage</code> event, you
        /// should by all means avoid using this feature, it is subject to change without notice.
        /// </p>
        /// <p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or
        /// socket object to another process. The child will receive the object as its
        /// second argument to the <code>message</code> event.
        /// </p>
        /// <p><strong>send server object</strong>
        /// </p>
        /// <p>Here is an example of sending a server:
        /// </p>
        /// <pre><code>var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);
        /// // Open up the server object and send the handle.
        /// var server = require(&#39;net&#39;).createServer();
        /// server.on(&#39;connection&#39;, function (socket) {
        /// socket.end(&#39;handled by parent&#39;);
        /// });
        /// server.listen(1337, function() {
        /// child.send(&#39;server&#39;, server);
        /// });</code></pre>
        /// <p>And the child would the receive the server object as:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m, server) {
        /// if (m === &#39;server&#39;) {
        /// server.on(&#39;connection&#39;, function (socket) {
        /// socket.end(&#39;handled by child&#39;);
        /// });
        /// }
        /// });</code></pre>
        /// <p>Note that the server is now shared between the parent and child, this means
        /// that some connections will be handled by the parent and some by the child.
        /// </p>
        /// <p><strong>send socket object</strong>
        /// </p>
        /// <p>Here is an example of sending a socket. It will spawn two children and handle
        /// connections with the remote address <code>74.125.127.100</code> as VIP by sending the
        /// socket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.
        /// </p>
        /// <pre><code>var normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);
        /// var special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);
        /// // Open up the server and send sockets to child
        /// var server = require(&#39;net&#39;).createServer();
        /// server.on(&#39;connection&#39;, function (socket) {
        /// // if this is a VIP
        /// if (socket.remoteAddress === &#39;74.125.127.100&#39;) {
        /// special.send(&#39;socket&#39;, socket);
        /// return;
        /// }
        /// // just the usual dudes
        /// normal.send(&#39;socket&#39;, socket);
        /// });
        /// server.listen(1337);</code></pre>
        /// <p>The <code>child.js</code> could look like this:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m, socket) {
        /// if (m === &#39;socket&#39;) {
        /// socket.end(&#39;You were handled as a &#39; + process.argv[2] + &#39; person&#39;);
        /// }
        /// });</code></pre>
        /// <p>Note that once a single socket has been sent to a child the parent can no
        /// longer keep track of when the socket is destroyed. To indicate this condition
        /// the <code>.connections</code> property becomes <code>null</code>.
        /// It is also recommended not to use <code>.maxConnections</code> in this condition.
        /// </p>
        /// </summary>
        public object send(object message){return null;}
        /// <summary>
        /// <p>When using <code>child_process.fork()</code> you can write to the child using
        /// <code>child.send(message, [sendHandle])</code> and messages are received by
        /// a <code>&#39;message&#39;</code> event on the child.
        /// </p>
        /// <p>For example:
        /// </p>
        /// <pre><code>var cp = require(&#39;child_process&#39;);
        /// var n = cp.fork(__dirname + &#39;/sub.js&#39;);
        /// n.on(&#39;message&#39;, function(m) {
        /// console.log(&#39;PARENT got message:&#39;, m);
        /// });
        /// n.send({ hello: &#39;world&#39; });</code></pre>
        /// <p>And then the child script, <code>&#39;sub.js&#39;</code> might look like this:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m) {
        /// console.log(&#39;CHILD got message:&#39;, m);
        /// });
        /// process.send({ foo: &#39;bar&#39; });</code></pre>
        /// <p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
        /// will emit objects each time it receives a message on its channel.
        /// </p>
        /// <p>There is a special case when sending a <code>{cmd: &#39;NODE_foo&#39;}</code> message. All messages
        /// containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
        /// the <code>message</code> event, since they are internal messages used by node core.
        /// Messages containing the prefix are emitted in the <code>internalMessage</code> event, you
        /// should by all means avoid using this feature, it is subject to change without notice.
        /// </p>
        /// <p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or
        /// socket object to another process. The child will receive the object as its
        /// second argument to the <code>message</code> event.
        /// </p>
        /// <p><strong>send server object</strong>
        /// </p>
        /// <p>Here is an example of sending a server:
        /// </p>
        /// <pre><code>var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);
        /// // Open up the server object and send the handle.
        /// var server = require(&#39;net&#39;).createServer();
        /// server.on(&#39;connection&#39;, function (socket) {
        /// socket.end(&#39;handled by parent&#39;);
        /// });
        /// server.listen(1337, function() {
        /// child.send(&#39;server&#39;, server);
        /// });</code></pre>
        /// <p>And the child would the receive the server object as:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m, server) {
        /// if (m === &#39;server&#39;) {
        /// server.on(&#39;connection&#39;, function (socket) {
        /// socket.end(&#39;handled by child&#39;);
        /// });
        /// }
        /// });</code></pre>
        /// <p>Note that the server is now shared between the parent and child, this means
        /// that some connections will be handled by the parent and some by the child.
        /// </p>
        /// <p><strong>send socket object</strong>
        /// </p>
        /// <p>Here is an example of sending a socket. It will spawn two children and handle
        /// connections with the remote address <code>74.125.127.100</code> as VIP by sending the
        /// socket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.
        /// </p>
        /// <pre><code>var normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);
        /// var special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);
        /// // Open up the server and send sockets to child
        /// var server = require(&#39;net&#39;).createServer();
        /// server.on(&#39;connection&#39;, function (socket) {
        /// // if this is a VIP
        /// if (socket.remoteAddress === &#39;74.125.127.100&#39;) {
        /// special.send(&#39;socket&#39;, socket);
        /// return;
        /// }
        /// // just the usual dudes
        /// normal.send(&#39;socket&#39;, socket);
        /// });
        /// server.listen(1337);</code></pre>
        /// <p>The <code>child.js</code> could look like this:
        /// </p>
        /// <pre><code>process.on(&#39;message&#39;, function(m, socket) {
        /// if (m === &#39;socket&#39;) {
        /// socket.end(&#39;You were handled as a &#39; + process.argv[2] + &#39; person&#39;);
        /// }
        /// });</code></pre>
        /// <p>Note that once a single socket has been sent to a child the parent can no
        /// longer keep track of when the socket is destroyed. To indicate this condition
        /// the <code>.connections</code> property becomes <code>null</code>.
        /// It is also recommended not to use <code>.maxConnections</code> in this condition.
        /// </p>
        /// </summary>
        public object send(object message, object sendHandle){return null;}
    }
}
