//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace SharpKit.NodeJs.http
{
    /// <summary>
    /// <p>This object is created internally and returned from <code>http.request()</code>.  It
    /// represents an <em>in-progress</em> request whose header has already been queued.  The
    /// header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
    /// <code>removeHeader(name)</code> API.  The actual header will be sent along with the first
    /// data chunk or when closing the connection.
    /// </p>
    /// <p>To get the response, add a listener for <code>&#39;response&#39;</code> to the request object.
    /// <code>&#39;response&#39;</code> will be emitted from the request object when the response
    /// headers have been received.  The <code>&#39;response&#39;</code> event is executed with one
    /// argument which is an instance of <code>http.ClientResponse</code>.
    /// </p>
    /// <p>During the <code>&#39;response&#39;</code> event, one can add listeners to the
    /// response object; particularly to listen for the <code>&#39;data&#39;</code> event. Note that
    /// the <code>&#39;response&#39;</code> event is called before any part of the response body is received,
    /// so there is no need to worry about racing to catch the first part of the
    /// body. As long as a listener for <code>&#39;data&#39;</code> is added during the <code>&#39;response&#39;</code>
    /// event, the entire body will be caught.
    /// </p>
    /// <pre><code>// Good
    /// request.on(&#39;response&#39;, function (response) {
    /// response.on(&#39;data&#39;, function (chunk) {
    /// console.log(&#39;BODY: &#39; + chunk);
    /// });
    /// });
    /// // Bad - misses all or part of the body
    /// request.on(&#39;response&#39;, function (response) {
    /// setTimeout(function () {
    /// response.on(&#39;data&#39;, function (chunk) {
    /// console.log(&#39;BODY: &#39; + chunk);
    /// });
    /// }, 10);
    /// });</code></pre>
    /// <p>Note: Node does not check whether Content-Length and the length of the body
    /// which has been transmitted are equal or not.
    /// </p>
    /// <p>The request implements the [Writable Stream][] interface. This is an
    /// [EventEmitter][] with the following events:
    /// </p>
    /// </summary>
    public partial class ClientRequest
    {
        /// <summary>
        /// <p>Aborts a request.  (New since v0.3.8.)
        /// </p>
        /// </summary>
        public object abort(){return null;}
        /// <summary>
        /// <p>Finishes sending the request. If any parts of the body are
        /// unsent, it will flush them to the stream. If the request is
        /// chunked, this will send the terminating <code>&#39;0\r\n\r\n&#39;</code>.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling
        /// <code>request.write(data, encoding)</code> followed by <code>request.end()</code>.
        /// </p>
        /// </summary>
        public object end(){return null;}
        /// <summary>
        /// <p>Finishes sending the request. If any parts of the body are
        /// unsent, it will flush them to the stream. If the request is
        /// chunked, this will send the terminating <code>&#39;0\r\n\r\n&#39;</code>.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling
        /// <code>request.write(data, encoding)</code> followed by <code>request.end()</code>.
        /// </p>
        /// </summary>
        public object end(object encoding){return null;}
        /// <summary>
        /// <p>Finishes sending the request. If any parts of the body are
        /// unsent, it will flush them to the stream. If the request is
        /// chunked, this will send the terminating <code>&#39;0\r\n\r\n&#39;</code>.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling
        /// <code>request.write(data, encoding)</code> followed by <code>request.end()</code>.
        /// </p>
        /// </summary>
        public object end(object data, object encoding){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setNoDelay()][] will be called.
        /// </p>
        /// </summary>
        public object setNoDelay(){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setNoDelay()][] will be called.
        /// </p>
        /// </summary>
        public object setNoDelay(object noDelay){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setKeepAlive()][] will be called.
        /// </p>
        /// </summary>
        public object setSocketKeepAlive(){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setKeepAlive()][] will be called.
        /// </p>
        /// </summary>
        public object setSocketKeepAlive(object initialDelay){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setKeepAlive()][] will be called.
        /// </p>
        /// </summary>
        public object setSocketKeepAlive(object enable, object initialDelay){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setTimeout()][] will be called.
        /// </p>
        /// </summary>
        public object setTimeout(object timeout){return null;}
        /// <summary>
        /// <p>Once a socket is assigned to this request and is connected
        /// [socket.setTimeout()][] will be called.
        /// </p>
        /// </summary>
        public object setTimeout(object timeout, object callback){return null;}
        /// <summary>
        /// <p>Sends a chunk of the body.  By calling this method
        /// many times, the user can stream a request body to a
        /// server--in that case it is suggested to use the
        /// <code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> header line when
        /// creating the request.
        /// </p>
        /// <p>The <code>chunk</code> argument should be a [Buffer][] or a string.
        /// </p>
        /// <p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.
        /// Defaults to <code>&#39;utf8&#39;</code>.
        /// </p>
        /// </summary>
        public object write(object chunk){return null;}
        /// <summary>
        /// <p>Sends a chunk of the body.  By calling this method
        /// many times, the user can stream a request body to a
        /// server--in that case it is suggested to use the
        /// <code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> header line when
        /// creating the request.
        /// </p>
        /// <p>The <code>chunk</code> argument should be a [Buffer][] or a string.
        /// </p>
        /// <p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.
        /// Defaults to <code>&#39;utf8&#39;</code>.
        /// </p>
        /// </summary>
        public object write(object chunk, object encoding){return null;}
    }
}
