//***************************************************
//* This file was generated by tool
//* SharpKit
//***************************************************
using System;
using System.Collections.Generic;
using SharpKit.JavaScript;
namespace SharpKit.NodeJs.http
{
    /// <summary>
    /// <p>This object is created internally by a HTTP server--not by the user. It is
    /// passed as the second parameter to the <code>&apos;request&apos;</code> event.
    /// </p>
    /// <p>The response implements the <a href="stream.html#writable_stream">Writable  Stream</a>
    /// interface. This is an <code>EventEmitter</code> with the following events:
    /// </p>
    /// </summary>
    public partial class ServerResponse
    {
        /// <summary>
        /// <p>This method adds HTTP trailing headers (a header but at the end of the
        /// message) to the response.
        /// </p>
        /// <p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
        /// response; if it is not (e.g., if the request was HTTP/1.0), they will
        /// be silently discarded.
        /// </p>
        /// <p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
        /// emit trailers, with a list of the header fields in its value. E.g.,
        /// </p>
        /// <pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
        /// &apos;Trailer&apos;: &apos;Content-MD5&apos; });
        /// response.write(fileData);
        /// response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
        /// response.end();</code></pre>
        /// </summary>
        public object addTrailers(object headers){return null;}
        /// <summary>
        /// <p>This method signals to the server that all of the response headers and body
        /// has been sent; that server should consider this message complete.
        /// The method, <code>response.end()</code>, MUST be called on each
        /// response.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
        /// followed by <code>response.end()</code>.
        /// </p>
        /// </summary>
        public object end(){return null;}
        /// <summary>
        /// <p>This method signals to the server that all of the response headers and body
        /// has been sent; that server should consider this message complete.
        /// The method, <code>response.end()</code>, MUST be called on each
        /// response.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
        /// followed by <code>response.end()</code>.
        /// </p>
        /// </summary>
        public object end(object encoding){return null;}
        /// <summary>
        /// <p>This method signals to the server that all of the response headers and body
        /// has been sent; that server should consider this message complete.
        /// The method, <code>response.end()</code>, MUST be called on each
        /// response.
        /// </p>
        /// <p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
        /// followed by <code>response.end()</code>.
        /// </p>
        /// </summary>
        public object end(object data, object encoding){return null;}
        /// <summary>
        /// <p>Reads out a header that&apos;s already been queued but not sent to the client.  Note
        /// that the name is case insensitive.  This can only be called before headers get
        /// implicitly flushed.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
        /// </summary>
        public object getHeader(object name){return null;}
        /// <summary>
        /// <p>Removes a header that&apos;s queued for implicit sending.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
        /// </summary>
        public object removeHeader(object name){return null;}
        /// <summary>
        /// <p>Sets a single header value for implicit headers.  If this header already exists
        /// in the to-be-sent headers, its value will be replaced.  Use an array of strings
        /// here if you need to send multiple headers with the same name.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
        /// <p>or
        /// </p>
        /// <pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
        /// </summary>
        public object setHeader(object name, object value){return null;}
        /// <summary>
        /// <p>If this method is called and <code>response.writeHead()</code> has not been called, it will
        /// switch to implicit header mode and flush the implicit headers.
        /// </p>
        /// <p>This sends a chunk of the response body. This method may
        /// be called multiple times to provide successive parts of the body.
        /// </p>
        /// <p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
        /// the second parameter specifies how to encode it into a byte stream.
        /// By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.
        /// </p>
        /// <p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
        /// higher-level multi-part body encodings that may be used.
        /// </p>
        /// <p>The first time <code>response.write()</code> is called, it will send the buffered
        /// header information and the first body to the client. The second time
        /// <code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
        /// data, and sends that separately. That is, the response is buffered up to the
        /// first chunk of body.
        /// </p>
        /// </summary>
        public object write(object chunk){return null;}
        /// <summary>
        /// <p>If this method is called and <code>response.writeHead()</code> has not been called, it will
        /// switch to implicit header mode and flush the implicit headers.
        /// </p>
        /// <p>This sends a chunk of the response body. This method may
        /// be called multiple times to provide successive parts of the body.
        /// </p>
        /// <p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
        /// the second parameter specifies how to encode it into a byte stream.
        /// By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.
        /// </p>
        /// <p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
        /// higher-level multi-part body encodings that may be used.
        /// </p>
        /// <p>The first time <code>response.write()</code> is called, it will send the buffered
        /// header information and the first body to the client. The second time
        /// <code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
        /// data, and sends that separately. That is, the response is buffered up to the
        /// first chunk of body.
        /// </p>
        /// </summary>
        public object write(object chunk, object encoding){return null;}
        /// <summary>
        /// <p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
        /// the request body should be sent. See the <a href="#event_checkContinue_">checkContinue</a> event on
        /// <code>Server</code>.
        /// </p>
        /// </summary>
        public object writeContinue(){return null;}
        /// <summary>
        /// <p>Sends a response header to the request. The status code is a 3-digit HTTP
        /// status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
        /// Optionally one can give a human-readable <code>reasonPhrase</code> as the second
        /// argument.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>var body = &apos;hello world&apos;;
        /// response.writeHead(200, {
        /// &apos;Content-Length&apos;: body.length,
        /// &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
        /// <p>This method must only be called once on a message and it must
        /// be called before <code>response.end()</code> is called.
        /// </p>
        /// <p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
        /// implicit/mutable headers will be calculated and call this function for you.
        /// </p>
        /// <p>Note: that Content-Length is given in bytes not characters. The above example
        /// works because the string <code>&apos;hello world&apos;</code> contains only single byte characters.
        /// If the body contains higher coded characters then <code>Buffer.byteLength()</code>
        /// should be used to determine the number of bytes in a given encoding.
        /// And Node does not check whether Content-Length and the length of the body
        /// which has been transmitted are equal or not.
        /// </p>
        /// </summary>
        public object writeHead(object statusCode){return null;}
        /// <summary>
        /// <p>Sends a response header to the request. The status code is a 3-digit HTTP
        /// status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
        /// Optionally one can give a human-readable <code>reasonPhrase</code> as the second
        /// argument.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>var body = &apos;hello world&apos;;
        /// response.writeHead(200, {
        /// &apos;Content-Length&apos;: body.length,
        /// &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
        /// <p>This method must only be called once on a message and it must
        /// be called before <code>response.end()</code> is called.
        /// </p>
        /// <p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
        /// implicit/mutable headers will be calculated and call this function for you.
        /// </p>
        /// <p>Note: that Content-Length is given in bytes not characters. The above example
        /// works because the string <code>&apos;hello world&apos;</code> contains only single byte characters.
        /// If the body contains higher coded characters then <code>Buffer.byteLength()</code>
        /// should be used to determine the number of bytes in a given encoding.
        /// And Node does not check whether Content-Length and the length of the body
        /// which has been transmitted are equal or not.
        /// </p>
        /// </summary>
        public object writeHead(object statusCode, object headers){return null;}
        /// <summary>
        /// <p>Sends a response header to the request. The status code is a 3-digit HTTP
        /// status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
        /// Optionally one can give a human-readable <code>reasonPhrase</code> as the second
        /// argument.
        /// </p>
        /// <p>Example:
        /// </p>
        /// <pre><code>var body = &apos;hello world&apos;;
        /// response.writeHead(200, {
        /// &apos;Content-Length&apos;: body.length,
        /// &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
        /// <p>This method must only be called once on a message and it must
        /// be called before <code>response.end()</code> is called.
        /// </p>
        /// <p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
        /// implicit/mutable headers will be calculated and call this function for you.
        /// </p>
        /// <p>Note: that Content-Length is given in bytes not characters. The above example
        /// works because the string <code>&apos;hello world&apos;</code> contains only single byte characters.
        /// If the body contains higher coded characters then <code>Buffer.byteLength()</code>
        /// should be used to determine the number of bytes in a given encoding.
        /// And Node does not check whether Content-Length and the length of the body
        /// which has been transmitted are equal or not.
        /// </p>
        /// </summary>
        public object writeHead(object statusCode, object reasonPhrase, object headers){return null;}
    }
}
