<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SharpKit.SenchaTouch-2.0.0</name>
    </assembly>
    <members>
        <member name="M:Base.addConfig(System.Object,System.Object)">
            <summary>
            @private
            @param config
            </summary>
        </member>
        <member name="M:Base.addInheritableStatics(System.Object)">
            <summary>
            @private
            @param {Object} members
            </summary>
        </member>
        <member name="M:Base.addMember(System.Object,System.Object)">
            <summary>
            @private
            @param name
            @param member
            </summary>
        </member>
        <member name="M:Base.addMembers(System.Object)">
            <summary>
            Add methods / properties to the prototype of this class.
            *
            Ext.define('My.awesome.Cat', {
            constructor: function() {
            ...
            }
            });
            *
            My.awesome.Cat.implement({
            meow: function() {
            alert('Meowww...');
            }
            });
            *
            var kitty = new My.awesome.Cat;
            kitty.meow();
            *
            @param {Object} members
            @static
            @inheritable
            </summary>
        </member>
        <member name="M:Base.addStatics(System.Object)">
            <summary>
            Add / override static properties of this class.
            *
            Ext.define('My.cool.Class', {
            ...
            });
            *
            My.cool.Class.addStatics({
            someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
            method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
            method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
            });
            *
            @param {Object} members
            @return {Ext.Base} this
            @static
            @inheritable
            </summary>
        </member>
        <member name="M:Base.addXtype(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Base.borrow(System.Object,System.Object)">
            <summary>
            Borrow another class' members to the prototype of this class.
            *
            Ext.define('Bank', {
            money: '$$$',
            printMoney: function() {
            alert('$$$$$$$');
            }
            });
            *
            Ext.define('Thief', {
            ...
            });
            *
            Thief.borrow(Bank, ['money', 'printMoney']);
            *
            var steve = new Thief();
            *
            alert(steve.money); // alerts '$$$'
            steve.printMoney(); // alerts '$$$$$$$'
            *
            @param {Ext.Base} fromClass The class to borrow members from
            @param {Array/String} members The names of the members to borrow
            @return {Ext.Base} this
            @static
            @inheritable
            @private
            </summary>
        </member>
        <member name="M:Base.callParent(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Base.create">
            <summary>
            Create a new instance of this Class.
            *
            Ext.define('My.cool.Class', {
            ...
            });
            *
            My.cool.Class.create({
            someConfig: true
            });
            *
            All parameters are passed to the constructor of the class.
            *
            @return {Object} the created instance.
            @static
            @inheritable
            </summary>
        </member>
        <member name="M:Base.extend(System.Object)">
            <summary>
            @private
            @param config
            </summary>
        </member>
        <member name="M:Base.getName">
            <summary>
            Get the current class' name in string format.
            *
            Ext.define('My.cool.Class', {
            constructor: function() {
            alert(this.self.getName()); // alerts 'My.cool.Class'
            }
            });
            *
            My.cool.Class.getName(); // 'My.cool.Class'
            *
            @return {String} className
            @static
            @inheritable
            </summary>
        </member>
        <member name="M:Base.implement">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Base.mixin(System.Object,System.Object)">
            <summary>
            Used internally by the mixins pre-processor
            @private
            @inheritable
            </summary>
        </member>
        <member name="M:Base.onExtended(System.Object,System.Object)">
            <summary>
            @private
            @param config
            </summary>
        </member>
        <member name="M:Base.override(System.Object)">
            <summary>
            Override members of this class. Overridden methods can be invoked via
            {@link Ext.Base#callParent}.
            *
            Ext.define('My.Cat', {
            constructor: function() {
            alert("I'm a cat!");
            *
            return this;
            }
            });
            *
            My.Cat.override({
            constructor: function() {
            alert("I'm going to be a cat!");
            *
            var instance = this.callParent(arguments);
            *
            alert("Meeeeoooowwww");
            *
            return instance;
            }
            });
            *
            var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
            // alerts "I'm a cat!"
            // alerts "Meeeeoooowwww"
            *
            As of 4.1, direct use of this method is deprecated. Use {@link Ext#define Ext.define}
            instead:
            *
            Ext.define('My.CatOverride', {
            override: 'My.Cat',
            constructor: function() {
            alert("I'm going to be a cat!");
            *
            var instance = this.callParent(arguments);
            *
            alert("Meeeeoooowwww");
            *
            return instance;
            }
            });
            *
            The above accomplishes the same result but can be managed by the {@link Ext.Loader}
            which can properly order the override and its target class and the build process
            can determine whether the override is needed based on the required state of the
            target class (My.Cat).
            *
            @param {Object} members The properties to add to this class. This should be
            specified as an object literal containing one or more properties.
            @return {Ext.Base} this class
            @static
            @inheritable
            @markdown
            @deprecated 4.1.0 Use {@link Ext#define Ext.define} instead
            </summary>
        </member>
        <member name="M:Base.triggerExtended">
            <summary>
            @private
            @param config
            </summary>
        </member>
        <member name="P:Base.Name">
            <summary>
            Get the current class' name in string format.
            *
            Ext.define('My.cool.Class', {
            constructor: function() {
            alert(this.self.getName()); // alerts 'My.cool.Class'
            }
            });
            *
            My.cool.Class.getName(); // 'My.cool.Class'
            *
            @return {String} className
            @static
            @inheritable
            </summary>
        </member>
        <member name="M:Ext.ExtClass.create(System.Object)">
            <summary>
            @private
            @param Class
            @param classData
            @param onClassCreated
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getDefaultPreprocessors">
            <summary>
            Retrieve the array stack of default pre-processors
            @private
            @return {Function} defaultPreprocessors
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getPreprocessor(SharpKit.JavaScript.JsString)">
            <summary>
            Retrieve a pre-processor callback function by its name, which has been registered before
            *
            @private
            @param {String} name
            @return {Function} preprocessor
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getPreprocessors">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.onBeforeCreated(System.Object,System.Object,System.Object)">
            <summary>
            @private
            @param Class
            @param data
            @param hooks
            </summary>
        </member>
        <member name="M:Ext.ExtClass.process(System.Object,System.Object,System.Object)">
            <summary>
            @private
            @param Class
            @param data
            @param onCreated
            </summary>
        </member>
        <member name="M:Ext.ExtClass.registerPreprocessor(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object,System.Object,System.Object)">
            <summary>
            Register a new pre-processor to be used during the class creation process
            *
            @member Ext.Class registerPreprocessor
            @param {String} name The pre-processor's name
            @param {Function} fn The callback function to be executed. Typical format:
            function(cls, data, fn) {
            // Your code here
            // Execute this when the processing is finished.
            // Asynchronous processing is perfectly ok
            if (fn) {
            fn.call(this, cls, data);
            }
            });
            Passed arguments for this function are:
            *
            - `{Function} cls`: The created class
            - `{Object} data`: The set of properties passed in {@link Ext.Class} constructor
            - `{Function} fn`: The callback function that <b>must</b> to be executed when this pre-processor finishes,
            regardless of whether the processing is synchronous or aynchronous
            *
            @private
            @return {Ext.Class} this
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.setDefaultPreprocessorPosition(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Insert this pre-processor at a specific position in the stack, optionally relative to
            any existing pre-processor. For example:
            Ext.Class.registerPreprocessor('debug', function(cls, data, fn) {
            // Your code here
            if (fn) {
            fn.call(this, cls, data);
            }
            }).insertDefaultPreprocessor('debug', 'last');
            @private
            @param {String} name The pre-processor name. Note that it needs to be registered with
            {@link Ext#registerPreprocessor registerPreprocessor} before this
            @param {String} offset The insertion position. Four possible values are:
            'first', 'last', or: 'before', 'after' (relative to the name provided in the third argument)
            @param {String} relativeName
            @return {Ext.Class} this
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.setDefaultPreprocessors(SharpKit.JavaScript.JsArray)">
            <summary>
            Set the default array stack of default pre-processors
            *
            @private
            @param {Array} preprocessors
            @return {Ext.Class} this
            </summary>
        </member>
        <member name="M:Ext.ExtClass.application(System.Object)">
            <summary>
            Loads Ext.app.Application class and starts it up with given configuration after the page is ready.
            See Ext.app.Application for details.
            @param {Object} config
            </summary>
        </member>
        <member name="M:Ext.ExtClass.applyIf(System.Object,System.Object)">
            <summary>
            Copies all the properties of config to object if they don't already exist.
            @param {Object} object The receiver of the properties
            @param {Object} config The source of the properties
            @return {Object} returns obj
            </summary>
        </member>
        <member name="M:Ext.ExtClass.callback(SharpKit.JavaScript.JsAction,System.Object,SharpKit.JavaScript.JsArray,SharpKit.JavaScript.JsNumber)">
            <summary>
            @param {Function} callback The callback to execute
            @param {Object} scope (optional) The scope to execute in
            @param {Array} args (optional) The arguments to pass to the function
            @param {Number} delay (optional) Pass a number to delay the call by a number of milliseconds.
            </summary>
        </member>
        <member name="M:Ext.ExtClass.clone(System.Object)">
            <summary>
            Clone almost any type of variable including array, object, DOM nodes and Date without keeping the old reference
            @param {Object} item The variable to clone
            @return {Object} clone
            </summary>
        </member>
        <member name="M:Ext.ExtClass.create(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Instantiate a class by either full name, alias or alternate name. ...
            </summary>
        </member>
        <member name="M:Ext.ExtClass.define(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsAction)">
            <summary>
            @method
            Defines a class or override. A basic class is defined like this:
            *
            Ext.define('My.awesome.Class', {
            someProperty: 'something',
            *
            someMethod: function() {
            alert(s + this.someProperty);
            }
            *
            ...
            });
            *
            var obj = new My.awesome.Class();
            *
            obj.someMethod('Say '); // alerts 'Say something'
            *
            To defines an override, include the `override` property. The content of an
            override is aggregated with the specified class in order to extend or modify
            that class. This can be as simple as setting default property values or it can
            extend and/or replace methods. This can also extend the statics of the class.
            *
            One use for an override is to break a large class into manageable pieces.
            *
            // File: /src/app/Panel.js
            *
            Ext.define('My.app.Panel', {
            extend: 'Ext.panel.Panel',
            requires: [
            'My.app.PanelPart2',
            'My.app.PanelPart3'
            ]
            *
            constructor: function (config) {
            this.callParent(arguments); // calls Ext.panel.Panel's constructor
            //...
            },
            *
            statics: {
            method: function () {
            return 'abc';
            }
            }
            });
            *
            // File: /src/app/PanelPart2.js
            Ext.define('My.app.PanelPart2', {
            override: 'My.app.Panel',
            *
            constructor: function (config) {
            this.callParent(arguments); // calls My.app.Panel's constructor
            //...
            }
            });
            *
            Another use for an override is to provide optional parts of classes that can be
            independently required. In this case, the class may even be unaware of the
            override altogether.
            *
            Ext.define('My.ux.CoolTip', {
            override: 'Ext.tip.ToolTip',
            *
            constructor: function (config) {
            this.callParent(arguments); // calls Ext.tip.ToolTip's constructor
            //...
            }
            });
            *
            The above override can now be required as normal.
            *
            Ext.define('My.app.App', {
            requires: [
            'My.ux.CoolTip'
            ]
            });
            *
            Overrides can also contain statics:
            *
            Ext.define('My.app.BarMod', {
            override: 'Ext.foo.Bar',
            *
            statics: {
            method: function (x) {
            return this.callParent([x * 2]); // call Ext.foo.Bar.method
            }
            }
            });
            *
            IMPORTANT: An override is only included in a build if the class it overrides is
            required. Otherwise, the override, like the target class, is not included.
            *
            @param {String} className The class name to create in string dot-namespaced format, for example:
            'My.very.awesome.Class', 'FeedViewer.plugin.CoolPager'
            It is highly recommended to follow this simple convention:
            - The root and the class name are 'CamelCased'
            - Everything else is lower-cased
            @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of any valid
            strings, except those in the reserved listed below:
            - `mixins`
            - `statics`
            - `config`
            - `alias`
            - `self`
            - `singleton`
            - `alternateClassName`
            - `override`
            *
            @param {Function} createdFn Optional callback to execute after the class (or override)
            is created. The execution scope (`this`) will be the newly created class itself.
            @return {Ext.Base}
            @markdown
            @member Ext
            @method define
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecate(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Create a closure for deprecated code.
            *
            // This means Ext.oldMethod is only supported in 4.0.0beta and older.
            // If Ext.getVersion('extjs') returns a version that is later than '4.0.0beta', for example '4.0.0RC',
            // the closure will not be invoked
            Ext.deprecate('extjs', '4.0.0beta', function() {
            Ext.oldMethod = Ext.newMethod;
            ...
            });
            @param {String} packageName The package name
            @param {String} since The last version before it's deprecated
            @param {Function} closure The callback function to be executed with the specified version is less than the current version
            @param {Object} scope The execution scope (<tt>this</tt>) if the closure
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateClassConfigDirectAccess(System.Object,System.Object)">
            <summary>
            @private
            @param cls
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateClassMember(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateClassMembers(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateClassMethod(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateMethod(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.deprecateProperty(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.destroy">
            <summary>
            Attempts to destroy any objects passed to it by removing all event listeners, removing them from the
            DOM (if applicable) and calling their destroy functions (if available).  This method is primarily
            intended for arguments of type {@link Ext.Element} and {@link Ext.Component}, but any subclass of
            {@link Ext.util.Observable} can be passed in.  Any number of elements and/or components can be
            passed into this function in a single call as separate arguments.
            @param {Mixed...} args An {@link Ext.Element}, {@link Ext.Component}, or an Array of either of these to destroy
            </summary>
        </member>
        <member name="M:Ext.ExtClass.factory(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            @param config
            @param classReference
            @param instance
            </summary>
        </member>
        <member name="M:Ext.ExtClass.factoryConfig(System.Object,System.Object)">
            <summary>
            @private
            @param config
            @param callback
            </summary>
        </member>
        <member name="M:Ext.ExtClass.functionFactory">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getBody">
            <summary>
            Returns the current document body as an {@link Ext.Element}.
            @return Ext.Element The document body
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getCmp(SharpKit.JavaScript.JsString)">
            <summary>
            This is shorthand reference to {@link Ext.ComponentMgr#get}.
            Looks up an existing {@link Ext.Component Component} by {@link Ext.Component#getId id}
            @param {String} id The component {@link Ext.Component#getId id}
            @return Ext.Component The Component, <tt>undefined</tt> if not found, or <tt>null</tt> if a
            Class was found.
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getDisplayName(System.Object)">
            <summary>
            *
            @param {Mixed} object
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getDoc">
            <summary>
            Returns the current HTML document object as an {@link Ext.Element}.
            @return Ext.Element The document
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getDom(System.Object)">
            <summary>
            Return the dom node for the passed String (id), dom node, or Ext.Element.
            Here are some examples:
            <pre><code>
            // gets dom node based on id
            var elDom = Ext.getDom('elId');
            // gets dom node based on the dom node
            var elDom1 = Ext.getDom(elDom);
            // If we don&#39;t know if we are working with an
            // Ext.Element or a dom node use Ext.getDom
            function(el){
            var dom = Ext.getDom(el);
            // do something with the dom node
            }
            </code></pre>
            <b>Note</b>: the dom node to be found actually needs to exist (be rendered, etc)
            when this method is called to be successful.
            @param {Mixed} el
            @return HTMLElement
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getHead">
            <summary>
            Returns the current document head as an {@link Ext.Element}.
            @return Ext.Element The document head
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getUniqueGlobalNamespace">
            <summary>
            @private
            Generate a unique reference of Ext in the global scope, useful for sandboxing
            </summary>
        </member>
        <member name="M:Ext.ExtClass.getVersion(SharpKit.JavaScript.JsString)">
            <summary>
            Get the version number of the supplied package name; will return the last registered version
            (last Ext.setVersion call) if there's no package name given.
            *
            @param {String} packageName (Optional) The package name, for example: 'core', 'touch', 'extjs'
            @return {Ext.Version} The version
            </summary>
        </member>
        <member name="M:Ext.ExtClass.id(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Generates unique ids. If the element already has an id, it is unchanged
            @param {Mixed} el (optional) The element to generate an id for
            @param {String} prefix (optional) Id prefix (defaults "ext-gen")
            @return {String} The generated Id.
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isBoolean(System.Object)">
            <summary>
            Returns true if the passed value is a boolean.
            *
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isDate(System.Object)">
            <summary>
            Returns true if the passed value is a JavaScript Date object, false otherwise.
            @param {Object} object The object to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isDefined(System.Object)">
            <summary>
            Returns true if the passed value is defined.
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isElement(System.Object)">
            <summary>
            Returns true if the passed value is an HTMLElement
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isEmpty(System.Object,System.Boolean)">
            <summary>
            Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:
            *
            - `null`
            - `undefined`
            - a zero-length array
            - a zero-length string (Unless the `allowEmptyString` parameter is set to `true`)
            *
            @param {Object} value The value to test
            @param {Boolean} allowEmptyString (optional) true to allow empty strings (defaults to false)
            @return {Boolean}
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isIterable(System.Object)">
            <summary>
            Returns true if the passed value is iterable, false otherwise
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isNumber(System.Object)">
            <summary>
            Returns true if the passed value is a number. Returns false for non-finite numbers.
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isNumeric(System.Object)">
            <summary>
            Validates that a value is numeric.
            @param {Object} value Examples: 1, '1', '2.34'
            @return {Boolean} True if numeric, false otherwise
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isPrimitive(System.Object)">
            <summary>
            Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isSimpleObject(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isString(System.Object)">
            <summary>
            Returns true if the passed value is a string.
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.isTextNode(System.Object)">
            <summary>
            Returns true if the passed value is a TextNode
            @param {Object} value The value to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.iterate(System.Object,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Iterates either an array or an object. This method delegates to
            {@link Ext.Array#each Ext.Array.each} if the given value is iterable, and {@link Ext.Object#each Ext.Object.each} otherwise.
            *
            @param {Object/Array} object The object or array to be iterated.
            @param {Function} fn The function to be called for each iteration. See and {@link Ext.Array#each Ext.Array.each} and
            {@link Ext.Object#each Ext.Object.each} for detailed lists of arguments passed to this function depending on the given object
            type that is being iterated.
            @param {Object} scope (Optional) The scope (`this` reference) in which the specified function is executed.
            Defaults to the object being iterated itself.
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.num">
            <summary>
            This method is deprecated, please use {@link Ext.Number#from Ext.Number.from} instead
            *
            @deprecated 4.0.0 Replaced by Ext.Number.from
            @member Ext
            @method num
            </summary>
        </member>
        <member name="M:Ext.ExtClass.onDocumentReady(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.onReady(System.Object,System.Object,System.Object)">
            <summary>
            @member Ext
            @method onReady
            </summary>
        </member>
        <member name="M:Ext.ExtClass.override(System.Object,System.Object)">
            <summary>
            Proxy to {@link Ext.Base#override}. Please refer {@link Ext.Base#override} for further details.
            *
            @param {Object} cls The class to override
            @param {Object} overrides The properties to add to origClass. This should be specified as an object literal
            containing one or more properties.
            @method override
            @markdown
            @deprecated 4.1.0 Use {@link Ext#define Ext.define} instead
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.ExtClass.removeNode(SharpKit.Html4.HtmlElement)" -->
        <member name="M:Ext.ExtClass.repaint">
            <summary>
            Repaints the whole page. This fixes frequently encountered painting issues in mobile Safari.
            </summary>
        </member>
        <member name="M:Ext.ExtClass.setVersion(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Set version number for the given package name.
            *
            @param {String} packageName The package name, for example: 'core', 'touch', 'extjs'
            @param {String/Ext.Version} version The version, for example: '1.2.3alpha', '2.4.0-dev'
            @return {Ext}
            </summary>
        </member>
        <member name="M:Ext.ExtClass.toArray">
            <summary>
            @method
            @member Ext
            @alias Ext.Array#toArray
            </summary>
        </member>
        <member name="M:Ext.ExtClass.triggerReady">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.ExtClass.typeOf(System.Object)">
            <summary>
            Returns the type of the given variable in string format. List of possible values are:
            *
            - `undefined`: If the given value is `undefined`
            - `null`: If the given value is `null`
            - `string`: If the given value is a string
            - `number`: If the given value is a number
            - `boolean`: If the given value is a boolean value
            - `date`: If the given value is a `Date` object
            - `function`: If the given value is a function reference
            - `object`: If the given value is an object
            - `array`: If the given value is an array
            - `regexp`: If the given value is a regular expression
            - `element`: If the given value is a DOM Element
            - `textnode`: If the given value is a DOM text node and contains something other than whitespace
            - `whitespace`: If the given value is a DOM text node and contains only whitespace
            *
            @param {Object} value
            @return {String}
            @markdown
            </summary>
        </member>
        <member name="M:Ext.ExtClass.urlDecode">
            <summary>
            A convenient alias method for {@link Ext.Object#fromQueryString}
            *
            @member Ext
            @method urlDecode
            @deprecated 4.0.0 Use {@link Ext.Object#fromQueryString Ext.Object.fromQueryString} instead
            </summary>
        </member>
        <member name="M:Ext.ExtClass.urlEncode">
            <summary>
            A convenient alias method for {@link Ext.Object#toQueryString}
            *
            @member Ext
            @method urlEncode
            @deprecated 4.0.0 Use {@link Ext.Object#toQueryString Ext.Object.toQueryString} instead
            </summary>
        </member>
        <member name="M:Ext.ExtClass.valueFrom(System.Object,System.Object,System.Boolean)">
            <summary>
            Returns the given value itself if it's not empty, as described in {@link Ext#isEmpty}; returns the default
            value (second argument) otherwise.
            *
            @param {Object} value The value to test
            @param {Object} defaultValue The value to return if the original value is empty
            @param {Boolean} allowBlank (optional) true to allow zero length strings to qualify as non-empty (defaults to false)
            @return {Object} value, if non-empty, else defaultValue
            </summary>
        </member>
        <member name="M:Ext.ExtClass.widget(System.Object)">
            <summary>
            Convenient shorthand to create a widget by its xtype, also see {@link Ext.ClassManager#instantiateByAlias}
            var button = Ext.widget('button'); // Equivalent to Ext.create('widget.button')
            var panel = Ext.widget('panel'); // Equivalent to Ext.create('widget.panel')
            @member Ext
            @method widget
            @markdown
            </summary>
        </member>
        <member name="P:Ext.ExtClass.DefaultPreprocessors">
            <summary>
            Retrieve the array stack of default pre-processors
            @private
            @return {Function} defaultPreprocessors
            Set the default array stack of default pre-processors
            *
            @private
            @param {Array} preprocessors
            @return {Ext.Class} this
            </summary>
        </member>
        <member name="P:Ext.ExtClass.idSeed">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.ExtClass.isReady">
            <summary>
            True when the document is fully initialized and ready for action
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.ExtClass.lastRegisteredVersion">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Loader.addOptionalRequires(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Loader.cleanupScriptElement(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Loader.historyPush(SharpKit.JavaScript.JsString)">
            <summary>
            @private
            @param {String} className
            </summary>
        </member>
        <member name="M:Loader.injectScriptElement(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Inject a script element to document's head, call onLoad and onError accordingly
            @private
            </summary>
        </member>
        <member name="M:Loader.loadScriptFile(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object,System.Object,System.Boolean)">
            <summary>
            Load a script file, supports both asynchronous and synchronous approaches
            *
            @param {String} url
            @param {Function} onLoad
            @param {Scope} scope
            @param {Boolean} synchronous
            @private
            </summary>
        </member>
        <member name="M:Loader.onFileLoaded(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            @private
            @param {String} className
            @param {String} filePath
            </summary>
        </member>
        <member name="M:Loader.onFileLoadError(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Loader.onReady(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @ignore
            </summary>
        </member>
        <member name="M:Loader.refreshQueue">
            <summary>
            Refresh all items in the queue. If all dependencies for an item exist during looping,
            it will execute the callback and call refreshQueue again. Triggers onReady when the queue is
            empty
            @private
            </summary>
        </member>
        <member name="M:Loader.require_(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            @ignore
            </summary>
        </member>
        <member name="M:Loader.syncRequire">
            <summary>
            @ignore
            </summary>
        </member>
        <member name="M:Loader.triggerReady(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Loader.hasFileLoadError">
            <summary>
            * @private
            </summary>
        </member>
        <member name="P:Loader.isLoading">
            <summary>
            Flag indicating whether there are still files being loaded
            @private
            </summary>
        </member>
        <member name="P:Loader.numLoadedFiles">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Loader.numPendingFiles">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Loader.syncModeEnabled">
            <summary>
            @private
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Version.compare(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)" -->
        <member name="M:Version.getComponentValue(System.Object)">
            <summary>
            Converts a version component to a comparable value
            *
            @static
            @param {Object} value The value to convert
            @return {Object}
            </summary>
        </member>
        <member name="T:Element.populateStyleMap">
            <summary>
            Creates mappings for 'margin-before' to 'marginLeft' (etc.) given the output
            map and an ordering pair (e.g., ['left', 'right']). The ordering pair is in
            before/after order.
            </summary>
        </member>
        <member name="M:Element.populateStyleMap.#ctor(System.Object,System.Object)">
            <summary>
            Creates mappings for 'margin-before' to 'marginLeft' (etc.) given the output
            map and an ordering pair (e.g., ['left', 'right']). The ordering pair is in
            before/after order.
            </summary>
        </member>
        <member name="M:Ext.AbstractComponent.addReferenceNode(System.Object,System.Object)">
            <summary>
            @private
            Significantly improve instantiation time for Component with multiple references
            Ext.Element instance of the reference domNode is only created the very first time
            it's ever used
            </summary>
        </member>
        <member name="P:Ext.AbstractComponent.extend">
            <summary>
            *
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.create(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Creates and returns an instance of whatever this manager manages, based on the supplied type and
            config object.
            @param {Object} config The config object
            @param {String} defaultType If no type is discovered in the config object, we fall back to this type
            @return {Object} The instance of whatever this manager is managing
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.each(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Executes the specified function once for each item in the collection.
            @param {Function} fn The function to execute.
            @param {String} fn.key The key of the item
            @param {Number} fn.value The value of the item
            @param {Number} fn.length The total number of items in the collection
            @param {Boolean} fn.return False to cease iteration.
            @param {Object} scope The scope to execute in. Defaults to `this`.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.get(SharpKit.JavaScript.JsString)">
            <summary>
            Returns an item by id.
            For additional details see {@link Ext.util.HashMap#get}.
            @param {String} id The id of the item
            @return {Object} The item, undefined if not found.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.getCount">
            <summary>
            Gets the number of items in the collection.
            @return {Number} The number of items in the collection.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.isRegistered(SharpKit.JavaScript.JsString)">
            <summary>
            Checks if an item type is registered.
            @param {String} type The mnemonic string by which the class may be looked up
            @return {Boolean} Whether the type is registered.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.onAvailable(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Registers a function that will be called when an item with the specified id is added to the manager.
            This will happen on instantiation.
            @param {String} id The item id
            @param {Function} fn The callback function. Called with a single parameter, the item.
            @param {Object} scope The scope (this reference) in which the callback is executed.
            Defaults to the item.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.register(System.Object)">
            <summary>
            Registers an item to be managed
            @param {Object} item The item to register
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.registerType(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction)">
            <summary>
            Registers a new item constructor, keyed by a type key.
            @param {String} type The mnemonic string by which the class may be looked up.
            @param {Function} cls The new instance class.
            </summary>
        </member>
        <member name="M:Ext.AbstractManager.unregister(System.Object)">
            <summary>
            Unregisters an item by removing it from this manager
            @param {Object} item The item to unregister
            </summary>
        </member>
        <member name="P:Ext.AbstractManager.Count">
            <summary>
            Gets the number of items in the collection.
            @return {Number} The number of items in the collection.
            </summary>
        </member>
        <member name="P:Ext.AbstractManager.typeName">
            <summary>
            End Definitions
            </summary>
        </member>
        <member name="M:Ext.AbstractPlugin.disable">
            <summary>
            <p>The base implementation just sets the plugin's <code>disabled</code> flag to <code>true</code></p>
            <p>Plugin subclasses which need more complex processing may implement an overriding implementation.</p>
            </summary>
        </member>
        <member name="M:Ext.AbstractPlugin.enable">
            <summary>
            <p>The base implementation just sets the plugin's <code>disabled</code> flag to <code>false</code></p>
            <p>Plugin subclasses which need more complex processing may implement an overriding implementation.</p>
            </summary>
        </member>
        <member name="P:Ext.AbstractPlugin.disabled">
            <summary>
            @class Ext.AbstractPlugin
            @extends Object
            *
            <p>The AbstractPlugin class is the base class from which user-implemented plugins should inherit.</p>
            <p>This class defines the essential API of plugins as used by Components by defining the following methods:</p>
            <ul>
            <li><code>init</code> : The plugin initialization method which the owning Component calls at Component initialization
            time.<div class="sub-desc"><p>The Component passes itself as the sole parameter.</p><p>Subclasses should set up bidirectional
            links between the plugin and its client Component here.</p></div></li>
            <li><code>destroy</code> : The plugin cleanup method which the owning Component calls at Component destruction time.<div class="sub-desc">Use
            this method to break links between the plugin and the Component and to free any allocated resources.</div></li>
            <li><code>enable</code> : The base implementation just sets the plugin's <code>disabled</code> flag to <code>false</code><div class="sub-desc"></div></li>
            <li><code>disable</code> : The base implementation just sets the plugin's <code>disabled</code> flag to <code>true</code><div class="sub-desc"></div></li>
            </ul>
            </summary>
        </member>
        <member name="P:Ext.ActionSheet.alias">
            <summary>
            A button {@link Ext.Sheet} class designed to popup or slide/anchor a series of {@link Ext.Button}s.
            *
            # Example
            *
            @example preview
            var actionSheet = Ext.create('Ext.ActionSheet', {
            items: [
            {
            text: 'Delete draft',
            ui  : 'decline'
            },
            {
            text: 'Save draft'
            },
            {
            text: 'Cancel',
            ui  : 'confirm'
            }
            ]
            });
            actionSheet.show();
            *
            </summary>
        </member>
        <member name="P:Ext.ActionSheet.extend">
            <summary>
            A button {@link Ext.Sheet} class designed to popup or slide/anchor a series of {@link Ext.Button}s.
            *
            # Example
            *
            @example preview
            var actionSheet = Ext.create('Ext.ActionSheet', {
            items: [
            {
            text: 'Delete draft',
            ui  : 'decline'
            },
            {
            text: 'Save draft'
            },
            {
            text: 'Cancel',
            ui  : 'confirm'
            }
            ]
            });
            actionSheet.show();
            *
            </summary>
        </member>
        <member name="P:Ext.Ajax.autoAbort">
            <summary>
            @property  autoAbort
            Whether a new request should abort any pending requests. (defaults to false)
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.Ajax.extend">
            <summary>
            A singleton instance of an {@link Ext.data.Connection}. This class
            is used to communicate with your server side code. It can be used as follows:
            *
            Ext.Ajax.request({
            url: 'page.php',
            params: {
            id: 1
            },
            success: function(response){
            var text = response.responseText;
            // process server response here
            }
            });
            *
            Default options for all requests can be set by changing a property on the Ext.Ajax class:
            *
            Ext.Ajax.timeout = 60000; // 60 seconds
            *
            Any options specified in the request method for the Ajax request will override any
            defaults set on the Ext.Ajax class. In the code sample below, the timeout for the
            request will be 60 seconds.
            Ext.Ajax.timeout = 120000; // 120 seconds
            Ext.Ajax.request({
            url: 'page.aspx',
            timeout: 60000
            });
            *
            In general, this class will be used for all Ajax requests in your application.
            The main reason for creating a separate {@link Ext.data.Connection} is for a
            series of requests that share common settings that are different to all other
            requests in the application.
            </summary>
        </member>
        <member name="P:Ext.Ajax.singleton">
            <summary>
            A singleton instance of an {@link Ext.data.Connection}. This class
            is used to communicate with your server side code. It can be used as follows:
            *
            Ext.Ajax.request({
            url: 'page.php',
            params: {
            id: 1
            },
            success: function(response){
            var text = response.responseText;
            // process server response here
            }
            });
            *
            Default options for all requests can be set by changing a property on the Ext.Ajax class:
            *
            Ext.Ajax.timeout = 60000; // 60 seconds
            *
            Any options specified in the request method for the Ajax request will override any
            defaults set on the Ext.Ajax class. In the code sample below, the timeout for the
            request will be 60 seconds.
            Ext.Ajax.timeout = 120000; // 120 seconds
            Ext.Ajax.request({
            url: 'page.aspx',
            timeout: 60000
            });
            *
            In general, this class will be used for all Ajax requests in your application.
            The main reason for creating a separate {@link Ext.data.Connection} is for a
            series of requests that share common settings that are different to all other
            requests in the application.
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.autoAbort">
            <summary>
            (Optional) @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.defaultHeaders">
            <summary>
            @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.disableCaching">
            <summary>
            (Optional) @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.extraParams">
            <summary>
            @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.method">
            <summary>
            (Optional) @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.timeout">
            <summary>
            (Optional) @hide
            </summary>
        </member>
        <member name="P:Ext.AjaxConfig.url">
            <summary>
            @hide
            </summary>
        </member>
        <member name="T:Ext.Anim">
            <summary>
            <p>Ext.Anim is used to excute animations defined in {@link Ext.anims}. The {@link #run} method can take any of the
            properties defined below.</p>
            *
            <h2>Example usage:</h2>
            <code><pre>
            Ext.Anim.run(this, 'fade', {
            out: false,
            autoClear: true
            });
            </pre></code>
            *
            <p>Animations are disabled on Android and Blackberry by default using the {@link #disableAnimations} property.</p>
            @singleton
            </summary>
        </member>
        <member name="M:Ext.Anim.run(System.Object,SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Used to run an animation on a specific element. Use the config argument to customize the animation
            @param {Ext.Element/HTMLElement} el The element to animate
            @param {String} anim The animation type, defined in {@link Ext.anims}
            @param {Object} config The config object for the animation
            @method run
            </summary>
        </member>
        <member name="P:Ext.Anim.disableAnimations">
            <summary>
            @cfg {Boolean} disableAnimations
            True to disable animations. By default, animations are disabled on Android and Blackberry
            </summary>
        </member>
        <member name="P:Ext.Anim.isAnim">
            <summary>
            <p>Ext.Anim is used to excute animations defined in {@link Ext.anims}. The {@link #run} method can take any of the
            properties defined below.</p>
            *
            <h2>Example usage:</h2>
            <code><pre>
            Ext.Anim.run(this, 'fade', {
            out: false,
            autoClear: true
            });
            </pre></code>
            *
            <p>Animations are disabled on Android and Blackberry by default using the {@link #disableAnimations} property.</p>
            @singleton
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.autoClear">
            <summary>
            True to remove all custom CSS defined in the {@link #to} config when the animation is over.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.before">
            <summary>
            Code to execute before starting the animation.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.delay">
            <summary>
            Time to delay before starting the animation.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.direction">
            <summary>
            Valid values are 'left', 'right', 'up', 'down' and null.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.disableAnimations">
            <summary>
            True to disable animations. By default, animations are disabled on Android and Blackberry
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.duration">
            <summary>
            Time in milliseconds for the animation to last.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.easing">
            <summary>
            Valid values are 'ease', 'linear', ease-in', 'ease-out', 'ease-in-out' or a cubic-bezier curve as defined by CSS.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.from">
            <summary>
            An object of CSS values which the animation begins with. If you define a CSS property here, you must also
            define it in the {@link #to} config.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.out">
            <summary>
            True if you want the animation to slide out of the screen.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.reverse">
            <summary>
            True to reverse the animation direction. For example, if the animation direction was set to 'left', it would
            then use 'right'.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.scope">
            <summary>
            Scope to run the {@link #before} function in.
            </summary>
        </member>
        <member name="P:Ext.AnimConfig.to">
            <summary>
            An object of CSS values which the animation ends with. If you define a CSS property here, you must also
            define it in the {@link #from} config.
            </summary>
        </member>
        <member name="T:Ext.apply">
            <summary>
            Copies all the properties of config to the specified object.
            Note that if recursive merging and cloning without referencing the original objects / arrays is needed, use
            {@link Ext.Object#merge} instead.
            @param {Object} object The receiver of the properties
            @param {Object} config The source of the properties
            @param {Object} defaults A different object that will also be applied for default values
            @return {Object} returns obj
            </summary>
        </member>
        <member name="M:Ext.apply.#ctor(System.Object,System.Object,System.Object)">
            <summary>
            Copies all the properties of config to the specified object.
            Note that if recursive merging and cloning without referencing the original objects / arrays is needed, use
            {@link Ext.Object#merge} instead.
            @param {Object} object The receiver of the properties
            @param {Object} config The source of the properties
            @param {Object} defaults A different object that will also be applied for default values
            @return {Object} returns obj
            </summary>
        </member>
        <member name="P:Ext.Audio.extend">
            <summary>
            {@link Ext.Audio} is a simple class which provides a container for the [HTML5 Audio element](http://www.w3schools.com/html5/tag_audio.asp).
            ## Recommended File Types/Compression:
            * Uncompressed WAV and AIF audio
            * MP3 audio
            * AAC-LC
            * HE-AAC audio
            *
            ## Notes
            On Android devices, the audio tags controls do not show. You must use the {@link #play}, {@link #pause} and
            {@link #toggle} methods to control the audio (example below).
            ## Examples
            Here is an example of the {@link Ext.Audio} component in a fullscreen container:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type : 'vbox',
            pack : 'center',
            align: 'stretch'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title : 'Ext.Audio'
            },
            {
            xtype: 'audio',
            url  : 'touch/examples/audio/crash.mp3'
            }
            ]
            });
            You can also set the {@link #hidden} configuration of the {@link Ext.Audio} component to true by default, and then control the audio by using the {@link #play}, {@link #pause} and {@link #toggle} methods:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title : 'Ext.Audio'
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            defaults: {
            xtype: 'button',
            handler: function() {
            var container = this.getParent().getParent(),
            // use ComponentQuery to get the audio component (using its xtype)
            audio = container.down('audio');
            audio.toggle();
            this.setText(audio.isPlaying() ? 'Pause' : 'Play');
            }
            },
            items: [
            { text: 'Play', flex: 1 }
            ]
            },
            {
            html: 'Hidden audio!',
            styleHtmlContent: true
            },
            {
            xtype : 'audio',
            hidden: true,
            url   : 'touch/examples/audio/crash.mp3'
            }
            ]
            });
            *
            </summary>
        </member>
        <member name="P:Ext.Audio.xtype">
            <summary>
            {@link Ext.Audio} is a simple class which provides a container for the [HTML5 Audio element](http://www.w3schools.com/html5/tag_audio.asp).
            ## Recommended File Types/Compression:
            * Uncompressed WAV and AIF audio
            * MP3 audio
            * AAC-LC
            * HE-AAC audio
            *
            ## Notes
            On Android devices, the audio tags controls do not show. You must use the {@link #play}, {@link #pause} and
            {@link #toggle} methods to control the audio (example below).
            ## Examples
            Here is an example of the {@link Ext.Audio} component in a fullscreen container:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type : 'vbox',
            pack : 'center',
            align: 'stretch'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title : 'Ext.Audio'
            },
            {
            xtype: 'audio',
            url  : 'touch/examples/audio/crash.mp3'
            }
            ]
            });
            You can also set the {@link #hidden} configuration of the {@link Ext.Audio} component to true by default, and then control the audio by using the {@link #play}, {@link #pause} and {@link #toggle} methods:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title : 'Ext.Audio'
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            defaults: {
            xtype: 'button',
            handler: function() {
            var container = this.getParent().getParent(),
            // use ComponentQuery to get the audio component (using its xtype)
            audio = container.down('audio');
            audio.toggle();
            this.setText(audio.isPlaying() ? 'Pause' : 'Play');
            }
            },
            items: [
            { text: 'Play', flex: 1 }
            ]
            },
            {
            html: 'Hidden audio!',
            styleHtmlContent: true
            },
            {
            xtype : 'audio',
            hidden: true,
            url   : 'touch/examples/audio/crash.mp3'
            }
            ]
            });
            *
            </summary>
        </member>
        <member name="P:Ext.AudioConfig.url">
            <summary>
            The location of the audio to play.
            ### Recommended file types are:
            * Uncompressed WAV and AIF audio
            * MP3 audio
            * AAC-LC
            * HE-AAC audio
            @accessor
            @markdown
            </summary>
        </member>
        <member name="T:Ext.bind">
            <summary>
            @method
            @member Ext
            @alias Ext.Function#bind
            </summary>
        </member>
        <member name="M:Ext.Button.doTap">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateAutoEvent(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateBadgeCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateBadgeText(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateHasBadgeCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateIcon(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateIconAlign(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateIconCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateIconMask(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateIconMaskCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateLabelCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updatePressedCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Button.updateText(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.Button.extend" -->
        <member name="P:Ext.ButtonConfig.autoEvent">
            <summary>
            Optional event name that will be fired instead of 'tap' when the Button is tapped on
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.badgeCls">
            <summary>
            The CSS class to add to the Button's badge, if it has one
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.badgeText">
            <summary>
            Optional badge text
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.handler">
            <summary>
            The handler function to run when the Button is tapped on
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.hasBadgeCls">
            <summary>
            The CSS class to add to the Button if it has a badge (note that this goes on the
            Button element itself, not on the badge element)
            @private
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.icon">
            <summary>
            Url to the icon image to use if you want an icon to appear on your button
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.iconAlign">
            <summary>
            The position within the Button to render the icon
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.iconCls">
            <summary>
            Optional CSS class to add to the icon element. This is useful if you want to use a CSS
            background image to create your Button icon
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.iconMask">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.iconMaskCls">
            <summary>
            The CSS class to add to the icon element as allowed by {@link #iconMask}
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.labelCls">
            <summary>
            The CSS class to add to the field's label element
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.pressedCls">
            <summary>
            The CSS class to add to the Button when it is pressed
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.scope">
            <summary>
            The scope to fire the configured {@link #handler} in. Optional
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.text">
            <summary>
            The Button text
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ButtonConfig.ui">
            <summary>
            The ui style to render this button with. The valid default options are:  'normal', 'back', 'round', 'action', and 'forward'.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.Component.addCls(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Adds a CSS class (or classes) to this Component's rendered element
            @param {String} cls The CSS class to add
            @param {String} prefix Optional prefix to add to each class
            @param {String} suffix Optional suffix to add to each class
            </summary>
        </member>
        <member name="M:Ext.Component.applyTpl(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Component.#ctor(System.Object)">
            <summary>
            Creates new Component.
            @param {Object} config The standard configuration object.
            </summary>
        </member>
        <member name="M:Ext.Component.destroy">
            <summary>
            Destroys this Component. If it is currently added to a Container it will first be removed from that Container.
            All Ext.Element references are also deleted and the Component is de-registered from Ext.ComponentManager
            </summary>
        </member>
        <member name="M:Ext.Component.disable">
            <summary>
            Disables this Component
            </summary>
        </member>
        <member name="M:Ext.Component.enable">
            <summary>
            Enables this Component
            </summary>
        </member>
        <member name="M:Ext.Component.getEl">
            <summary>
            Retrieves the top level element representing this component.
            @return {Ext.dom.Element}
            </summary>
        </member>
        <member name="M:Ext.Component.getSize">
            <summary>
            Returns the height and width of the Component
            @return {Object} The current height and width of the Component
            </summary>
        </member>
        <member name="M:Ext.Component.getXTypes">
            <summary>
            <p>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
            available xtypes, see the {@link Ext.Component} header.</p>
            <p><b>If using your own subclasses, be aware that a Component must register its own xtype
            to participate in determination of inherited xtypes.</b></p>
            <p>Example usage:</p>
            <pre><code>
            var t = new Ext.field.Text();
            alert(t.getXTypes());  // alerts 'component/field/textfield'
            </code></pre>
            @return {String} The xtype hierarchy string
            </summary>
        </member>
        <member name="M:Ext.Component.hide">
            <summary>
            Hides this Component
            </summary>
        </member>
        <member name="M:Ext.Component.isDisabled">
            <summary>
            Returns true if this Component is currently disabled
            @return {Boolean} True if currently disabled
            </summary>
        </member>
        <member name="M:Ext.Component.isHidden">
            <summary>
            Returns true if this Component is currently hidden
            @return {Boolean} True if currently hidden
            </summary>
        </member>
        <member name="M:Ext.Component.isPainted">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Component.isRendered">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Component.isXType(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            <p>Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
            from the xtype (default) or whether it is directly of the xtype specified (shallow = true).</p>
            <p><b>If using your own subclasses, be aware that a Component must register its own xtype
            to participate in determination of inherited xtypes.</b></p>
            <p>For a list of all available xtypes, see the {@link Ext.Component} header.</p>
            <p>Example usage:</p>
            <pre><code>
            var t = new Ext.field.Text();
            var isText = t.isXType('textfield');        // true
            var isBoxSubclass = t.isXType('field');       // true, descended from Ext.field.Field
            var isBoxInstance = t.isXType('field', true); // false, not a direct Ext.field.Field instance
            </code></pre>
            @param {String} xtype The xtype to check for this Component
            @param {Boolean} shallow (optional) False to check whether this Component is descended from the xtype (this is
            the default), or true to check whether this Component is directly of the specified xtype.
            @return {Boolean} True if this component descends from the specified xtype, false otherwise.
            </summary>
        </member>
        <member name="M:Ext.Component.removeCls(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Removes the given CSS class(es) from this Component's rendered element
            @param {String} cls The class(es) to remove
            @param {String} prefix Optional prefix to prepend before each class
            @param {String} suffix Optional suffix to append to each class
            </summary>
        </member>
        <member name="M:Ext.Component.setSize(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Sets the size of the Component
            @param {Number} width The new width for the Component
            @param {Number} height The new height for the Component
            </summary>
        </member>
        <member name="M:Ext.Component.show">
            <summary>
            Shows this component
            </summary>
        </member>
        <member name="M:Ext.Component.showBy(System.Object,System.Object,System.Object)">
            <summary>
            Shows this Component next to another Component or Element
            @param {Ext.Component/Ext.Element} alignTo The Element or Component to align to
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.Component.up(SharpKit.JavaScript.JsString)" -->
        <member name="M:Ext.Component.updateData(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Component.updateStyleHtmlCls(System.Object,System.Object)">
            <summary>
            Updates the {@link #styleHtmlCls} configuration
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.Component.extend" -->
        <member name="P:Ext.Component.floating">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Component.isComponent">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Component.loadingMask">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Component.maskText">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Component.rendered">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Component.Size">
            <summary>
            Returns the height and width of the Component
            @return {Object} The current height and width of the Component
            </summary>
        </member>
        <member name="P:Ext.Component.XTypes">
            <summary>
            <p>Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
            available xtypes, see the {@link Ext.Component} header.</p>
            <p><b>If using your own subclasses, be aware that a Component must register its own xtype
            to participate in determination of inherited xtypes.</b></p>
            <p>Example usage:</p>
            <pre><code>
            var t = new Ext.field.Text();
            alert(t.getXTypes());  // alerts 'component/field/textfield'
            </code></pre>
            @return {String} The xtype hierarchy string
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.baseCls">
            <summary>
            The base CSS class to apply to this components's element. This will also be prepended to
            other elements within this component. To add specific styling for sub-classes, use the `cls` config.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.border">
            <summary>
            The border to use on this Component. Can be specified as a number (in which
            case all edges get the same border width) or a CSS string like '5 10 10 10'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.bottom">
            <summary>
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.centered">
            <summary>
            Whether or not this component is absolutely centered inside its container
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.cls">
            <summary>
            the CSS class to add to this component's element, in addition to the `baseCls`
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.data">
            <summary>
            The initial set of data to apply to the <code>{@link #tpl}</code> to
            update the content area of the Component.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.disabled">
            <summary>
            Whether or not this component is disabled
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.disabledCls">
            <summary>
            The CSS class to add to the component when it is disabled
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.docked">
            <summary>
            The dock position of this component in its container. Can be 'left', 'top', 'right' or 'bottom'.
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.draggable">
            <summary>
            Configuration options to make this Component draggable
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.droppable">
            <summary>
            Configuration options to make this Component droppable
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.flex">
            <summary>
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.fullscreen">
            <summary>
            @deprecated 2.0.0 Please use Ext.Viewport.add instead
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.height">
            <summary>
            The height of this component in pixels.
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.hidden">
            <summary>
            True to hide this component
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.hideOnMaskTap">
            <summary>
            When using a {@link #modal} Component, setting this to true (the default) will
            hide the modal mask and the Component when the mask is tapped on
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.html">
            <summary>
            Optional HTML content to render inside this Component
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.left">
            <summary>
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.margin">
            <summary>
            The margin to use on this Component. Can be specified as a number (in which case
            all edges get the same margin) or a CSS string like '5 10 10 10'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.masked">
            <summary>
            True to mask this component.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.modal">
            <summary>
            True to make this Component modal. This will create a mask underneath the Component
            that covers the whole page and does not allow the user to interact with any other Components until this
            Component is dismissed
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.padding">
            <summary>
            The padding to use on this Component. Can be specified as a number (in which
            case all edges get the same padding) or a CSS string like '5 10 10 10'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.renderTo">
            <summary>
            Optional element to render this Component to. Usually this is not needed because
            a Component is normally full screen or automatically rendered inside another {@link Ext.Container Container}
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.renderTpl">
            <summary>
            <p>An {@link Ext.XTemplate XTemplate} used to create the internal structure inside this Component's
            encapsulating Element.</p>
            <p>You do not normally need to specify this. For the base classes {@link Ext.Component}
            and {@link Ext.Container}, this defaults to <b><code>null</code></b> which means that they will be initially rendered
            with no internal structure; they render their {@link #getEl Element} empty. The more specialized ExtJS and Touch classes
            which use a more complex DOM structure, provide their own template definitions.</p>
            <p>This is intended to allow the developer to create application-specific utility Components with customized
            internal structure.</p>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.right">
            <summary>
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.style">
            <summary>
            Optional CSS styles that will be rendered into an inline style attribute when the
            Component is rendered
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.styleHtmlCls">
            <summary>
            The class that is added to the content target when you set styleHtmlContent to true.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.styleHtmlContent">
            <summary>
            True to automatically style the html inside the content target of this component (body for panels).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.top">
            <summary>
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.tpl">
            <summary>
            An <bold>{@link Ext.Template}</bold>, <bold>{@link Ext.XTemplate}</bold>
            or an array of strings to form an Ext.XTemplate.
            Used in conjunction with the <code>{@link #data}</code> and
            <code>{@link #tplWriteMode}</code> configurations.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.tplWriteMode">
            <summary>
            The Ext.(X)Template method to use when
            updating the content area of the Component. Defaults to <code>'overwrite'</code>
            (see <code>{@link Ext.XTemplate#overwrite}</code>).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.ui">
            <summary>
            The ui to be used on this Component
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.width">
            <summary>
            The width of this component in pixels.
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ComponentConfig.zIndex">
            <summary>
            The z-index to give this Component when it is rendered
            @accessor
            </summary>
        </member>
        <member name="M:Ext.ComponentManager.create(System.Object,SharpKit.JavaScript.JsAction)">
            <summary>
            Creates a new Component from the specified config object using the
            config object's xtype to determine the class to instantiate.
            @param {Object} config A configuration object for the Component you wish to create.
            @param {Function} defaultType (optional) The constructor to provide the default Component type if
            the config object does not contain a <code>xtype</code>. (Optional if the config contains a <code>xtype</code>).
            @return {Ext.Component} The newly instantiated Component.
            </summary>
        </member>
        <member name="M:Ext.ComponentManager.get(SharpKit.JavaScript.JsString)">
            <summary>
            Returns an item by id.
            For additional details see {@link Ext.util.HashMap#get}.
            @param {String} id The id of the item
            @return {Object} The item, undefined if not found.
            </summary>
        </member>
        <member name="M:Ext.ComponentManager.isRegistered(SharpKit.JavaScript.JsString)">
            <summary>
            Checks if an item type is registered.
            @param {String} component The mnemonic string by which the class may be looked up
            @return {Boolean} Whether the type is registered.
            </summary>
        </member>
        <member name="M:Ext.ComponentManager.register(System.Object)">
            <summary>
            Registers an item to be managed
            @param {Object} component The item to register
            </summary>
        </member>
        <member name="M:Ext.ComponentManager.unregister(System.Object)">
            <summary>
            Unregisters an item by removing it from this manager
            @param {Object} component The item to unregister
            </summary>
        </member>
        <member name="P:Ext.ComponentManager.alternateClassName">
            <summary>
            @private
            *
            <p>Provides a registry of all Components (instances of {@link Ext.Component} or any subclass
            thereof) on a page so that they can be easily accessed by {@link Ext.Component component}
            {@link Ext.Component#getId id} (see {@link #get}, or the convenience method {@link Ext#getCmp Ext.getCmp}).</p>
            <p>This object also provides a registry of available Component <i>classes</i>
            indexed by a mnemonic code known as the Component's `xtype`.
            The <code>xtype</code> provides a way to avoid instantiating child Components
            when creating a full, nested config object for a complete Ext page.</p>
            <p>A child Component may be specified simply as a <i>config object</i>
            as long as the correct `xtype` is specified so that if and when the Component
            needs rendering, the correct type can be looked up for lazy instantiation.</p>
            <p>For a list of all available `xtype`, see {@link Ext.Component}.</p>
            </summary>
        </member>
        <member name="P:Ext.ComponentManager.singleton">
            <summary>
            @private
            *
            <p>Provides a registry of all Components (instances of {@link Ext.Component} or any subclass
            thereof) on a page so that they can be easily accessed by {@link Ext.Component component}
            {@link Ext.Component#getId id} (see {@link #get}, or the convenience method {@link Ext#getCmp Ext.getCmp}).</p>
            <p>This object also provides a registry of available Component <i>classes</i>
            indexed by a mnemonic code known as the Component's `xtype`.
            The <code>xtype</code> provides a way to avoid instantiating child Components
            when creating a full, nested config object for a complete Ext page.</p>
            <p>A child Component may be specified simply as a <i>config object</i>
            as long as the correct `xtype` is specified so that if and when the Component
            needs rendering, the correct type can be looked up for lazy instantiation.</p>
            <p>For a list of all available `xtype`, see {@link Ext.Component}.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.ComponentQuery.singleton" -->
        <member name="M:Ext.Container.add(SharpKit.JavaScript.JsArray)">
            <summary>
            Adds one or more Components to this Container. Example:
            *
            var myPanel = Ext.create('Ext.Panel', {
            html: 'This will be added to a Container'
            });
            *
            myContainer.add([myPanel])
            *
            @param {Array} newItems The new items to add to the Container
            </summary>
        </member>
        <member name="M:Ext.Container.applyActiveItem(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.applyScrollable(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.child(SharpKit.JavaScript.JsString)">
            <summary>
            Retrieves the first direct child of this container which matches the passed selector.
            The passed in selector must comply with an Ext.ComponentQuery selector.
            @param {String} selector An Ext.ComponentQuery selector
            @return Ext.Component
            </summary>
        </member>
        <member name="M:Ext.Container.doAdd(System.Object)">
            <summary>
            @private
            @param item
            </summary>
        </member>
        <member name="M:Ext.Container.doInsert(System.Object,System.Object)">
            <summary>
            @private
            @param index
            @param item
            </summary>
        </member>
        <member name="M:Ext.Container.doSetActiveItem(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.down(SharpKit.JavaScript.JsString)">
            <summary>
            Retrieves the first descendant of this container which matches the passed selector.
            The passed in selector must comply with an Ext.ComponentQuery selector.
            @param {String} selector An Ext.ComponentQuery selector
            @return Ext.Component
            </summary>
        </member>
        <member name="M:Ext.Container.getAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns the Component for a given index in the Container's {@link #items}
            @param {Number} index The index of the Component to return
            @return {Ext.Component} The item at the specified index, if found
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.Container.getComponent(System.Object)" -->
        <member name="M:Ext.Container.getInnerItems">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.getScrollable">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.getScrollableBehavior">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.has(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.hasInnerItem(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.indexOf(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.insert(SharpKit.JavaScript.JsNumber,System.Object)">
            <summary>
            Adds a child Component at the given index. For example, here's how we can add a new item, making it the first
            child Component of this Container:
            *
            myContainer.insert(0, {xtype: 'panel', html: 'new item'});
            *
            @param {Number} index The index to insert the Component at
            @param {Object} item The Component to insert
            </summary>
        </member>
        <member name="M:Ext.Container.insertAfter(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.insertBefore(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.insertFirst(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.insertInner(System.Object,System.Object)">
            <summary>
            @private
            @param item
            @param index
            </summary>
        </member>
        <member name="M:Ext.Container.insertLast(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onAdd(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onFirstAdd">
            <summary>
            Initialize layout and event listeners the very first time an item is added
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onItemCenteredChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onItemDockedChange(System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onItemFloatingChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onMove(System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.onRemove(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.Container.query(SharpKit.JavaScript.JsString)">
            <summary>
            Retrieves all descendant components which match the passed selector.
            Executes an Ext.ComponentQuery.query using this container as its root.
            @param {String} selector Selector complying to an Ext.ComponentQuery selector
            @return {Array} Ext.Component's which matched the selector
            </summary>
        </member>
        <member name="M:Ext.Container.remove(System.Object,System.Boolean)">
            <summary>
            Removes an item from this Container, optionally destroying it
            @param {Object} item The item to remove
            @param {Boolean} destroy Calls the Component's {@link Ext.Component#destroy destroy} method if true
            @return {Ext.Component} this
            </summary>
        </member>
        <member name="M:Ext.Container.removeAll(System.Boolean)">
            <summary>
            Removes all items currently in the Container, optionally destroying them all
            @param {Boolean} destroy If true, {@link Ext.Component#destroy destroys} each removed Component
            @return {Ext.Component} this
            </summary>
        </member>
        <member name="M:Ext.Container.removeAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Removes the Component at the specified index:
            *
            myContainer.removeAt(0); //removes the first item
            *
            @param {Number} index The index of the Component to remove
            </summary>
        </member>
        <member name="M:Ext.Container.removeInner(System.Object)">
            <summary>
            @private
            @param item
            </summary>
        </member>
        <member name="M:Ext.Container.setRendered(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.Container.extend" -->
        <member name="P:Ext.Container.Rendered">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.activeItem">
            <summary>
            The item from the {@link #items} collection that will be active first. This is
            usually only meaningful in a {@link Ext.layout.Card card layout}, where only one item can be active at a
            time
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.autoDestroy">
            <summary>
            If true, child items will be destroyed as soon as they are {@link #remove removed}
            from this container
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.defaults">
            <summary>
            A set of default configurations to apply to all child Components in this Container.
            It's often useful to specify defaults when creating more than one items with similar configurations. For example here we can
            specify that each child is a panel and avoid repeating the xtype declaration for each one:
            *
            Ext.create('Ext.Container', {
            defaults: {
            xtype: 'panel'
            },
            items: [
            {
            html: 'Panel 1'
            },
            {
            html: 'Panel 2'
            }
            ]
            });
            *
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.items">
            <summary>
            The child items to add to this Container. This is usually an array of Component
            configurations or instances, for example:
            *
            Ext.create('Ext.Container', {
            items: [
            {
            xtype: 'panel',
            html: 'This is an item'
            }
            ]
            });
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.layout">
            <summary>
            Configuration for this Container's layout. Example:
            *
            Ext.create('Ext.Container', {
            layout: {
            type: 'hbox',
            align: 'middle'
            },
            items: [
            {
            xtype: 'panel',
            flex: 1,
            style: 'background-color: red;'
            },
            {
            xtype: 'panel',
            flex: 2,
            style: 'background-color: green'
            }
            ]
            });
            *
            See the layouts guide for more information
            *
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ContainerConfig.scrollable">
            <summary>
            Configuration options to make this Container scrollable
            @accessor
            </summary>
        </member>
        <member name="M:Ext.Date.toString(System.Object)">
            <summary>
            @private
            Private for now
            </summary>
        </member>
        <member name="M:Ext.DateExtras.add(SharpKit.JavaScript.JsDate,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber)">
            <summary>
            Provides a convenient method for performing basic date arithmetic. This method
            does not modify the Date instance being called - it creates and returns
            a new Date instance containing the resulting date value.
            *
            Examples:
            <pre><code>
            // Basic usage:
            var dt = Ext.Date.add(new Date('10/29/2006'), Ext.Date.DAY, 5);
            console.log(dt); //returns 'Fri Nov 03 2006 00:00:00'
            // Negative values will be subtracted:
            var dt2 = Ext.Date.add(new Date('10/1/2006'), Ext.Date.DAY, -5);
            console.log(dt2); //returns 'Tue Sep 26 2006 00:00:00'
            </code></pre>
            *
            @param {Date} date The date to modify
            @param {String} interval A valid date interval enum value.
            @param {Number} value The amount to add to the current date.
            @return {Date} The new Date instance.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.between(SharpKit.JavaScript.JsDate,SharpKit.JavaScript.JsDate,SharpKit.JavaScript.JsDate)">
            <summary>
            Checks if a date falls on or between the given start and end dates.
            @param {Date} date The date to check
            @param {Date} start Start date
            @param {Date} end End date
            @return {Boolean} true if this date falls on or between the given start and end dates.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.clearTime(SharpKit.JavaScript.JsDate,System.Boolean)">
            <summary>
            Attempts to clear all time information from this Date by setting the time to midnight of the same day,
            automatically adjusting for Daylight Saving Time (DST) where applicable.
            (note: DST timezone information for the browser's host operating system is assumed to be up-to-date)
            @param {Date} date The date
            @param {Boolean} clone true to create a clone of this date, clear the time and return it (defaults to false).
            @return {Date} this or the clone.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.clone(SharpKit.JavaScript.JsDate)">
            <summary>
            Creates and returns a new Date instance with the exact same date value as the called instance.
            Dates are copied and passed by reference, so if a copied date variable is modified later, the original
            variable will also be changed.  When the intention is to create a new variable that will not
            modify the original instance, you should create a clone.
            *
            Example of correctly cloning a date:
            <pre><code>
            //wrong way:
            var orig = new Date('10/1/2006');
            var copy = orig;
            copy.setDate(5);
            console.log(orig);  //returns 'Thu Oct 05 2006'!
            //correct way:
            var orig = new Date('10/1/2006'),
            copy = Ext.Date.clone(orig);
            copy.setDate(5);
            console.log(orig);  //returns 'Thu Oct 01 2006'
            </code></pre>
            @param {Date} date The date
            @return {Date} The new Date instance.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.format(SharpKit.JavaScript.JsDate,SharpKit.JavaScript.JsString)">
            <summary>
            Formats a date given the supplied format string.
            @param {Date} date The date to format
            @param {String} format The format string
            @return {String} The formatted date
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getDayOfYear(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the numeric day number of the year, adjusted for leap year.
            @param {Date} date The date
            @return {Number} 0 to 364 (365 in leap years).
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getElapsed(SharpKit.JavaScript.JsDate,SharpKit.JavaScript.JsDate)">
            <summary>
            Returns the number of milliseconds between two dates
            @param {Date} dateA The first date
            @param {Date} dateB (optional) The second date, defaults to now
            @return {Number} The difference in milliseconds
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getFirstDateOfMonth(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the date of the first day of the month in which this date resides.
            @param {Date} date The date
            @return {Date}
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getFirstDayOfMonth(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the first day of the current month, adjusted for leap year.  The returned value
            is the numeric day index within the week (0-6) which can be used in conjunction with
            the {@link #monthNames} array to retrieve the textual day name.
            Example:
            <pre><code>
            var dt = new Date('1/10/2007'),
            firstDay = Ext.Date.getFirstDayOfMonth(dt);
            console.log(Ext.Date.dayNames[firstDay]); //output: 'Monday'
            </code></pre>
            @param {Date} date The date
            @return {Number} The day number (0-6).
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getGMTOffset(SharpKit.JavaScript.JsDate,System.Boolean)">
            <summary>
            Get the offset from GMT of the current date (equivalent to the format specifier 'O').
            @param {Date} date The date
            @param {Boolean} colon (optional) true to separate the hours and minutes with a colon (defaults to false).
            @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600').
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getLastDateOfMonth(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the date of the last day of the month in which this date resides.
            @param {Date} date The date
            @return {Date}
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getLastDayOfMonth(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the last day of the current month, adjusted for leap year.  The returned value
            is the numeric day index within the week (0-6) which can be used in conjunction with
            the {@link #monthNames} array to retrieve the textual day name.
            Example:
            <pre><code>
            var dt = new Date('1/10/2007'),
            lastDay = Ext.Date.getLastDayOfMonth(dt);
            console.log(Ext.Date.dayNames[lastDay]); //output: 'Wednesday'
            </code></pre>
            @param {Date} date The date
            @return {Number} The day number (0-6).
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getMonthNumber(SharpKit.JavaScript.JsString)">
            <summary>
            Get the zero-based javascript month number for the given short/full month name.
            Override this function for international dates.
            @param {String} name The short/full month name.
            @return {Number} The zero-based javascript month number.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getShortDayName(SharpKit.JavaScript.JsNumber)">
            <summary>
            Get the short day name for the given day number.
            Override this function for international dates.
            @param {Number} day A zero-based javascript day number.
            @return {String} The short day name.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getShortMonthName(SharpKit.JavaScript.JsNumber)">
            <summary>
            Get the short month name for the given month number.
            Override this function for international dates.
            @param {Number} month A zero-based javascript month number.
            @return {String} The short month name.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getSuffix(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
            @param {Date} date The date
            @return {String} 'st, 'nd', 'rd' or 'th'.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.getTimezone(SharpKit.JavaScript.JsDate)">
            <summary>
            Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
            *
            Note: The date string returned by the javascript Date object's toString() method varies
            between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
            For a given date string e.g. "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)",
            getTimezone() first tries to get the timezone abbreviation from between a pair of parentheses
            (which may or may not be present), failing which it proceeds to get the timezone abbreviation
            from the GMT offset portion of the date string.
            @param {Date} date The date
            @return {String} The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
            </summary>
        </member>
        <member name="M:Ext.DateExtras.isDST(SharpKit.JavaScript.JsDate)">
            <summary>
            Checks if the current date is affected by Daylight Saving Time (DST).
            @param {Date} date The date
            @return {Boolean} True if the current date is affected by DST.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.isLeapYear(SharpKit.JavaScript.JsDate)">
            <summary>
            Checks if the current date falls within a leap year.
            @param {Date} date The date
            @return {Boolean} True if the current date falls within a leap year, false otherwise.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.isValid(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Checks if the passed Date parameters will cause a javascript Date "rollover".
            @param {Number} year 4-digit year
            @param {Number} month 1-based month-of-year
            @param {Number} day Day of month
            @param {Number} hour (optional) Hour
            @param {Number} minute (optional) Minute
            @param {Number} second (optional) Second
            @param {Number} millisecond (optional) Millisecond
            @return {Boolean} true if the passed parameters do not cause a Date "rollover", false otherwise.
            </summary>
        </member>
        <member name="M:Ext.DateExtras.parse(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Parses the passed string using the specified date format.
            Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
            The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
            which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
            the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
            Keep in mind that the input date string must precisely match the specified format string
            in order for the parse operation to be successful (failed parse operations return a null value).
            <p>Example:</p><pre><code>
            //dt = Fri May 25 2007 (current date)
            var dt = new Date();
            //dt = Thu May 25 2006 (today&#39;s month/day in 2006)
            dt = Ext.Date.parse("2006", "Y");
            //dt = Sun Jan 15 2006 (all date parts specified)
            dt = Ext.Date.parse("2006-01-15", "Y-m-d");
            //dt = Sun Jan 15 2006 15:20:01
            dt = Ext.Date.parse("2006-01-15 3:20:01 PM", "Y-m-d g:i:s A");
            // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
            dt = Ext.Date.parse("2006-02-29 03:20:01", "Y-m-d H:i:s", true); // returns null
            </code></pre>
            @param {String} input The raw date string.
            @param {String} format The expected date string format.
            @param {Boolean} strict (optional) True to validate date strings while parsing (i.e. prevents javascript Date "rollover")
            (defaults to false). Invalid date strings will return null when parsed.
            @return {Date} The parsed Date.
            </summary>
        </member>
        <member name="P:Ext.DateExtras.DAY">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.defaultFormat">
            <summary>
            <p>The date format string that the {@link Ext.util.Format#date} function uses.
            See {@link Ext.Date} for details.</p>
            <p>This defaults to <code>m/d/Y</code>, but may be overridden in a locale file.</p>
            @property defaultFormat
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.HOUR">
            <summary>
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.MILLI">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.MINUTE">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.MONTH">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.SECOND">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="P:Ext.DateExtras.useStrict">
            <summary>
            Global flag which determines if strict date parsing should be used.
            Strict date parsing will not roll-over invalid dates, which is the
            default behaviour of javascript Date objects.
            (see {@link #parse} for more information)
            Defaults to <tt>false</tt>.
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.DateExtras.YEAR">
            <summary>
            Date interval constant
            @type String
            </summary>
        </member>
        <member name="T:Ext.defer">
            <summary>
            @method
            @member Ext
            @alias Ext.Function#defer
            </summary>
        </member>
        <member name="M:Ext.Function.alias(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Create an alias to the provided method property with name `methodName` of `object`.
            Note that the execution scope will still be bound to the provided `object` itself.
            *
            @param {Object/Function} object
            @param {String} methodName
            @return {Function} aliasFn
            </summary>
        </member>
        <member name="M:Ext.Function.bind(SharpKit.JavaScript.JsAction,System.Object,SharpKit.JavaScript.JsArray,System.Object)">
            <summary>
            Create a new function from the provided `fn`, change `this` to the provided scope, optionally
            overrides arguments for the call. (Defaults to the arguments passed by the caller)
            *
            {@link Ext#bind Ext.bind} is alias for {@link Ext.Function#bind Ext.Function.bind}
            *
            @param {Function} fn The function to delegate.
            @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
            **If omitted, defaults to the browser window.**
            @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
            @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
            if a number the args are inserted at the specified position
            @return {Function} The new function
            </summary>
        </member>
        <member name="M:Ext.Function.clone(SharpKit.JavaScript.JsAction)">
            <summary>
            Create a "clone" of the provided method. The returned method will call the given
            method passing along all arguments and the "this" pointer and return its result.
            *
            @param {Function} method
            @return {Function} cloneFn
            </summary>
        </member>
        <member name="M:Ext.Function.createBuffered(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsNumber,System.Object,SharpKit.JavaScript.JsArray)">
            <summary>
            Creates a delegate function, optionally with a bound scope which, when called, buffers
            the execution of the passed function for the configured number of milliseconds.
            If called again within that period, the impending invocation will be canceled, and the
            timeout period will begin again.
            *
            @param {Function} fn The function to invoke on a buffered timer.
            @param {Number} buffer The number of milliseconds by which to buffer the invocation of the
            function.
            @param {Object} scope (optional) The scope (`this` reference) in which
            the passed function is executed. If omitted, defaults to the scope specified by the caller.
            @param {Array} args (optional) Override arguments for the call. Defaults to the arguments
            passed by the caller.
            @return {Function} A function which invokes the passed function after buffering for the specified time.
            </summary>
        </member>
        <member name="M:Ext.Function.createDelayed(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsNumber,System.Object,SharpKit.JavaScript.JsArray,System.Object)">
            <summary>
            Creates a delegate (callback) which, when called, executes after a specific delay.
            *
            @param {Function} fn The function which will be called on a delay when the returned function is called.
            Optionally, a replacement (or additional) argument list may be specified.
            @param {Number} delay The number of milliseconds to defer execution by whenever called.
            @param {Object} scope (optional) The scope (`this` reference) used by the function at execution time.
            @param {Array} args (optional) Override arguments for the call. (Defaults to the arguments passed by the caller)
            @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
            if a number the args are inserted at the specified position.
            @return {Function} A function which, when called, executes the original function after the specified delay.
            </summary>
        </member>
        <member name="M:Ext.Function.createInterceptor(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsAction,System.Object,System.Object)">
            <summary>
            Creates an interceptor function. The passed function is called before the original one. If it returns false,
            the original one is not called. The resulting function returns the results of the original function.
            The passed function is called with the parameters of the original function. Example usage:
            *
            var sayHi = function(name){
            alert('Hi, ' + name);
            }
            *
            sayHi('Fred'); // alerts "Hi, Fred"
            *
            // create a new function that validates input without
            // directly modifying the original function:
            var sayHiToFriend = Ext.Function.createInterceptor(sayHi, function(name){
            return name == 'Brian';
            });
            *
            sayHiToFriend('Fred');  // no alert
            sayHiToFriend('Brian'); // alerts "Hi, Brian"
            *
            @param {Function} origFn The original function.
            @param {Function} newFn The function to call before the original
            @param {Object} scope (optional) The scope (`this` reference) in which the passed function is executed.
            **If omitted, defaults to the scope in which the original function is called or the browser window.**
            @param {Object} returnValue (optional) The value to return if the passed function return false (defaults to null).
            @return {Function} The new function
            </summary>
        </member>
        <member name="M:Ext.Function.createSequence(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Create a combined function call sequence of the original function + the passed function.
            The resulting function returns the results of the original function.
            The passed function is called with the parameters of the original function. Example usage:
            *
            var sayHi = function(name){
            alert('Hi, ' + name);
            }
            *
            sayHi('Fred'); // alerts "Hi, Fred"
            *
            var sayGoodbye = Ext.Function.createSequence(sayHi, function(name){
            alert('Bye, ' + name);
            });
            *
            sayGoodbye('Fred'); // both alerts show
            *
            @param {Function} originalFn The original function.
            @param {Function} newFn The function to sequence
            @param {Object} scope (optional) The scope (`this` reference) in which the passed function is executed.
            If omitted, defaults to the scope in which the original function is called or the browser window.
            @return {Function} The new function
            </summary>
        </member>
        <member name="M:Ext.Function.createThrottled(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsNumber,System.Object)">
            <summary>
            Creates a throttled version of the passed function which, when called repeatedly and
            rapidly, invokes the passed function only after a certain interval has elapsed since the
            previous invocation.
            *
            This is useful for wrapping functions which may be called repeatedly, such as
            a handler of a mouse move event when the processing is expensive.
            *
            @param {Function} fn The function to execute at a regular time interval.
            @param {Number} interval The interval **in milliseconds** on which the passed function is executed.
            @param {Object} scope (optional) The scope (`this` reference) in which
            the passed function is executed. If omitted, defaults to the scope specified by the caller.
            @returns {Function} A function which invokes the passed function at the specified interval.
            </summary>
        </member>
        <member name="M:Ext.Function.defer(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsNumber,System.Object,SharpKit.JavaScript.JsArray,System.Object)">
            <summary>
            Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
            *
            var sayHi = function(name){
            alert('Hi, ' + name);
            }
            *
            // executes immediately:
            sayHi('Fred');
            *
            // executes after 2 seconds:
            Ext.Function.defer(sayHi, 2000, this, ['Fred']);
            *
            // this syntax is sometimes useful for deferring
            // execution of an anonymous function:
            Ext.Function.defer(function(){
            alert('Anonymous');
            }, 100);
            *
            {@link Ext#defer Ext.defer} is alias for {@link Ext.Function#defer Ext.Function.defer}
            *
            @param {Function} fn The function to defer.
            @param {Number} millis The number of milliseconds for the setTimeout call
            (if less than or equal to 0 the function is executed immediately)
            @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
            **If omitted, defaults to the browser window.**
            @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
            @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
            if a number the args are inserted at the specified position
            @return {Number} The timeout id that can be used with clearTimeout
            </summary>
        </member>
        <member name="M:Ext.Function.flexSetter(SharpKit.JavaScript.JsAction)">
            <summary>
            A very commonly used method throughout the framework. It acts as a wrapper around another method
            which originally accepts 2 arguments for `name` and `value`.
            The wrapped function then allows "flexible" value setting of either:
            *
            - `name` and `value` as 2 arguments
            - one single object argument with multiple key - value pairs
            *
            For example:
            *
            var setValue = Ext.Function.flexSetter(function(name, value) {
            this[name] = value;
            });
            *
            // Afterwards
            // Setting a single name - value
            setValue('name1', 'value1');
            *
            // Settings multiple name - value pairs
            setValue({
            name1: 'value1',
            name2: 'value2',
            name3: 'value3'
            });
            *
            @param {Function} setter
            @returns {Function} flexSetter
            </summary>
        </member>
        <member name="M:Ext.Function.pass(SharpKit.JavaScript.JsAction,SharpKit.JavaScript.JsArray,System.Object)">
            <summary>
            Create a new function from the provided `fn`, the arguments of which are pre-set to `args`.
            New arguments passed to the newly created callback when it's invoked are appended after the pre-set ones.
            This is especially useful when creating callbacks.
            *
            For example:
            *
            var originalFunction = function(){
            alert(Ext.Array.from(arguments).join(' '));
            };
            *
            var callback = Ext.Function.pass(originalFunction, ['Hello', 'World']);
            *
            callback(); // alerts 'Hello World'
            callback('by Me'); // alerts 'Hello World by Me'
            *
            {@link Ext#pass Ext.pass} is alias for {@link Ext.Function#pass Ext.Function.pass}
            *
            @param {Function} fn The original function
            @param {Array} args The arguments to pass to new callback
            @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
            @return {Function} The new callback function
            </summary>
        </member>
        <member name="M:Ext.Img.updateSrc(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.Img.extend">
            <summary>
            This is a simple way to add an image of any size to your application and have it participate in the layout system
            like any other component. This component typically takes between 1 and 3 configurations - a {@link #src}, and
            optionally a {@link #height} and a {@link #width}:
            Ext.create('Ext.Img', {
            src: 'path/to/my/image.jpg',
            height: 300,
            width: 400
            });
            It's also easy to add an image into a panel or other container using its xtype:
            Ext.create('Ext.Panel', {
            layout: '{@link Ext.layout.HBox hbox}',
            items: [
            {
            xtype: 'image',
            src: 'path/to/my/profilePicture.jpg',
            flex: 1
            },
            {
            xtype: 'textareafield',
            flex: 2,
            label: {
            text: 'My Profile',
            align: 'top'
            }
            }
            ]
            });
            Here we created a panel which contains an image (a profile picture in this case) and a text area to allow the user
            to enter profile information about themselves. In this case we used an {@link Ext.layout.HBox hbox layout} and
            flexed the image to take up one third of the width and the text area to take two thirds of the width. See the
            {@link Ext.layout.HBox hbox docs} for more information on flexing items.
            </summary>
        </member>
        <member name="P:Ext.Img.xtype">
            <summary>
            This is a simple way to add an image of any size to your application and have it participate in the layout system
            like any other component. This component typically takes between 1 and 3 configurations - a {@link #src}, and
            optionally a {@link #height} and a {@link #width}:
            Ext.create('Ext.Img', {
            src: 'path/to/my/image.jpg',
            height: 300,
            width: 400
            });
            It's also easy to add an image into a panel or other container using its xtype:
            Ext.create('Ext.Panel', {
            layout: '{@link Ext.layout.HBox hbox}',
            items: [
            {
            xtype: 'image',
            src: 'path/to/my/profilePicture.jpg',
            flex: 1
            },
            {
            xtype: 'textareafield',
            flex: 2,
            label: {
            text: 'My Profile',
            align: 'top'
            }
            }
            ]
            });
            Here we created a panel which contains an image (a profile picture in this case) and a text area to allow the user
            to enter profile information about themselves. In this case we used an {@link Ext.layout.HBox hbox layout} and
            flexed the image to take up one third of the width and the text area to take two thirds of the width. See the
            {@link Ext.layout.HBox hbox docs} for more information on flexing items.
            </summary>
        </member>
        <member name="P:Ext.ImgConfig.src">
            <summary>
            The source of this image
            </summary>
        </member>
        <member name="T:Ext.JSON">
            <summary>
            @class Ext.JSON
            Modified version of Douglas Crockford"s json.js that doesn"t
            mess with the Object prototype
            http://www.json.org/js.html
            @singleton
            </summary>
        </member>
        <member name="M:Ext.LoadMask.applyMsg(System.Object)">
            <summary>
            Sets the {@link #msg} configuration
            </summary>
        </member>
        <member name="M:Ext.LoadMask.applyMsgCls(System.Object)">
            <summary>
            Sets the {@link #msgCls} configuration
            </summary>
        </member>
        <member name="M:Ext.LoadMask.bindStore(Ext.data.Store,System.Object)">
            <summary>
            Changes the data store bound to this LoadMask.
            @param {Ext.data.Store} store The store to bind to this LoadMask
            </summary>
        </member>
        <member name="M:Ext.LoadMask.#ctor(System.Object,System.Object)">
            <summary>
            Creates new LoadMask.
            @param {Mixed} el The element or DOM node, or its id
            @param {Object} config The config object
            </summary>
        </member>
        <member name="M:Ext.LoadMask.disable">
            <summary>
            Disables the mask to prevent it from being displayed
            </summary>
        </member>
        <member name="M:Ext.LoadMask.enable">
            <summary>
            Enables the mask so that it can be displayed
            </summary>
        </member>
        <member name="M:Ext.LoadMask.hide">
            <summary>
            Hide this LoadMask.
            </summary>
        </member>
        <member name="M:Ext.LoadMask.isDisabled">
            <summary>
            Method to determine whether this LoadMask is currently disabled.
            @return {Boolean} the disabled state of this LoadMask.
            </summary>
        </member>
        <member name="M:Ext.LoadMask.show">
            <summary>
            Show this LoadMask over the configured Element.
            </summary>
        </member>
        <member name="P:Ext.LoadMask.disabled">
            <summary>
            Read-only. True if the mask is currently disabled so that it will not be displayed
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.LoadMaskConfig.msg">
            <summary>
            The text to display in a centered loading message box (defaults to 'Loading...')
            @accessor
            </summary>
        </member>
        <member name="P:Ext.LoadMaskConfig.msgCls">
            <summary>
            The CSS class to apply to the loading message element (defaults to "x-mask-loading")
            @accessor
            </summary>
        </member>
        <member name="P:Ext.LoadMaskConfig.store">
            <summary>
            Optional Store to which the mask is bound. The mask is displayed when a load request is issued, and
            hidden on either load sucess, or load fail.
            </summary>
        </member>
        <member name="M:Ext.Map.update(System.Object)">
            <summary>
            Moves the map center to the designated coordinates hash of the form:
            *
            { latitude: 37.381592, longitude: -122.135672 }
            *
            or a google.maps.LatLng object representing to the target location.
            *
            @param {Object/google.maps.LatLng} coordinates Object representing the desired Latitude and
            longitude upon which to center the map.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.Map.extend" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.Map.xtype" -->
        <member name="P:Ext.MapConfig.baseCls">
            <summary>
            The base CSS class to apply to the Maps's element
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.geo">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.map">
            <summary>
            The wrapped map.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.mapOptions">
            <summary>
            MapOptions as specified by the Google Documentation:
            http://code.google.com/apis/maps/documentation/v3/reference.html
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.maskMap">
            <summary>
            Masks the map (Defaults to false)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.maskMapCls">
            <summary>
            CSS class to add to the map when maskMap is set to true.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MapConfig.useCurrentLocation">
            <summary>
            Pass in true to center the map based on the geolocation coordinates.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.Media.isPlaying">
            <summary>
            Returns if the media is currently playing
            @return {Boolean} playing True if the media is playing
            </summary>
        </member>
        <member name="M:Ext.Media.pause">
            <summary>
            Pauses media playback
            </summary>
        </member>
        <member name="M:Ext.Media.play">
            <summary>
            Starts or resumes media playback
            </summary>
        </member>
        <member name="M:Ext.Media.toggle">
            <summary>
            Toggles the media playback state
            </summary>
        </member>
        <member name="M:Ext.Media.updateEnableControls(System.Object)">
            <summary>
            Updates the controls of the video element.
            </summary>
        </member>
        <member name="M:Ext.Media.updateLoop(System.Object)">
            <summary>
            Updates the loop setting of the media element.
            </summary>
        </member>
        <member name="M:Ext.Media.updateUrl(System.Object)">
            <summary>
            Sets the URL of the media element. If the media element already exists, it is update the src attribute of the
            element. If it is currently playing, it will start the new video.
            </summary>
        </member>
        <member name="P:Ext.Media.extend">
            <summary>
            Provides a base class for audio/visual controls. Should not be used directly.
            </summary>
        </member>
        <member name="P:Ext.Media.xtype">
            <summary>
            Provides a base class for audio/visual controls. Should not be used directly.
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.autoPause">
            <summary>
            Will automatically pause the media when the container is deactivated.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.autoResume">
            <summary>
            Will automatically start playing the media when the container is activated.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.enableControls">
            <summary>
            Set this to false to turn off the native media controls.
            Defaults to false when you are on Android, as it doesnt support controls.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.loop">
            <summary>
            Will loop the media forever.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.media">
            <summary>
            A reference to the underlying audio/video element.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.preload">
            <summary>
            Will begin preloading the media immediately.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MediaConfig.url">
            <summary>
            Location of the media to play.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.MessageBox.alert(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Displays a standard read-only message box with an OK button (comparable to the basic JavaScript alert prompt). If
            a callback function is passed it will be called after the user clicks the button, and the itemId of the button
            that was clicked will be passed as the only parameter to the callback.
            *
            @param {String} title The title bar text
            @param {String} msg The message box body text
            @param {Function} fn The callback function invoked after the message box is closed
            @param {Object} [scope] The scope (`this` reference) in which the callback is executed.
            Defaults to the browser window.
            @return {Ext.MessageBox} this
            </summary>
        </member>
        <member name="M:Ext.MessageBox.applyMsg(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.applyPromptConfig(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.applyTitle(System.Object)">
            <summary>
            Creates a new {@link Ext.Toolbar} instance using {@link Ext.Factory}
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.confirm(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's confirm). If a callback
            function is passed it will be called after the user clicks either button, and the id of the button that was
            clicked will be passed as the only parameter to the callback (could also be the top-right close button).
            *
            @param {String} title The title bar text
            @param {String} msg The message box body text
            @param {Function} fn The callback function invoked when user taps on the OK/Cancel button.
            The button is passed as the first argument.
            @param {Object} [scope] The scope (`this` reference) in which the callback is executed.
            Defaults to the browser window.
            @return {Ext.MessageBox} this
            </summary>
        </member>
        <member name="M:Ext.MessageBox.prompt(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction,System.Object,System.Object,SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Displays a message box with OK and Cancel buttons prompting the user to enter some text (comparable to
            JavaScript's prompt). The prompt can be a single-line or multi-line textbox. If a callback function is passed it
            will be called after the user clicks either button, and the id of the button that was clicked (could also be the
            top-right close button) and the text that was entered will be passed as the two parameters to the callback.
            *
            Example usage:
            *
            Ext.Msg.prompt(
            'Welcome!',
            'What\'s your name going to be today?',
            function(value){
            console.log(value)
            },
            null,
            false,
            null,
            { autocapitalize : true, placeholder : 'First-name please...' }
            );
            *
            @param {String} title The title bar text
            @param {String} msg The message box body text
            @param {Function} fn The callback function invoked when the user taps on the OK/Cancel button, the button is
            passed as the first argument, the entered string value is passed as the second argument
            @param {Object} [scope] The scope (`this` reference) in which the callback is executed.
            Defaults to the browser window.
            @param {Boolean/Number} [multiLine=false] True to create a multiline textbox using the defaultTextHeight property,
            or the height in pixels to create the textbox.
            @param {String} [value=''] Default value of the text input element.
            @param {Object} [promptConfig] A hash collection of input attribute values.
            *
            @param {Boolean} [promptConfig.focus=false]
            True to assert initial input focus.
            *
            @param {String} [promptConfig.placeholder='']
            String value rendered when the input field is empty.
            *
            @param {String/Boolean} [promptConfig.autocapitalize='off']
            True/on to capitalize the first letter of each word in the input value.
            *
            @param {String/Boolean} [promptConfig.autocorrect='off']
            True/on to enable spell-checking/autocorrect features if supported by the browser.
            *
            @param {String/Boolean} [promptConfig.autocomplete='off']
            True/on to enable autoCompletion of supplied text input values if supported by the browser.
            *
            @param {Number} [promptConfig.maxlength=0]
            Maximum number of characters allowed in the input if supported by the browser.
            *
            @param {String} [promptConfig.type='text']
            The type of input field. Possible values (if supported by the browser) may include (text, search, number, range,
            color, tel, url, email, date, month, week, time, datetime) (defaults to 'text')
            *
            @return {Ext.MessageBox} this
            </summary>
        </member>
        <member name="M:Ext.MessageBox.show(System.Object)">
            <summary>
            Displays a new message box, or reinitializes an existing message box, based on the config options passed in. All
            display functions (e.g. prompt, alert, etc.) on MessageBox call this function internally, although those calls
            are basic shortcuts and do not support all of the config options allowed here.
            *
            Example usage:
            *
            Ext.Msg.show({
            title: 'Address',
            msg: 'Please enter your address:',
            width: 300,
            buttons: Ext.MessageBox.OKCANCEL,
            multiLine: true,
            prompt : { maxlength : 180, autocapitalize : true },
            fn: saveAddress,
            iconCls: Ext.MessageBox.INFO
            });
            *
            @param {Object} config An object with the following config options:
            *
            @param {Object/Array} [config.buttons=false]
            A button config object or Array of the same(e.g., `Ext.MessageBox.OKCANCEL` or `{text:'Foo', itemId:'cancel'}`),
            or false to not show any buttons.
            *
            @param {String} config.cls
            A custom CSS class to apply to the message box's container element.
            *
            @param {Number} [config.defaultTextHeight=75]
            The default height in pixels of the message box's multiline textarea if displayed.
            *
            @param {Function} config.fn
            A callback function which is called when the dialog is dismissed by clicking on the configured buttons.
            @param {String} config.fn.buttonId The itemId of the button pressed, one of: 'ok', 'yes', 'no', 'cancel'.
            @param {String} config.fn.value Value of the input field if either `prompt` or `multiline` option is true.
            @param {Object} config.fn.opt The config object passed to show.
            *
            @param {Number} [config.width='auto']
            A fixed width for the MessageBox.
            *
            @param {Number} [config.height='auto']
            A fixed height for the MessageBox.
            *
            @param {Object} config.scope
            The scope of the callback function
            *
            @param {String} [config.icon='']
            A CSS class that provides a background image to be used as the body icon for the dialog
            (e.g. Ext.MessageBox.WARNING or 'custom-class').
            *
            @param {Boolean} [config.modal=true]
            False to allow user interaction with the page while the message box is displayed.
            *
            @param {String} config.msg
            A string that will replace the existing message box body text.
            Defaults to the XHTML-compliant non-breaking space character `&#160;`.
            *
            @param {Boolean} [config.multiline=false]
            True to prompt the user to enter multi-line text.
            *
            @param {Boolean} [config.prompt=false]
            True to prompt the user to enter single-line text (defaults to false)
            *
            @param {String} config.title
            The title text.
            *
            @param {String} config.value
            The string value to set into the active textbox element if displayed.
            *
            @return {Ext.MessageBox} this
            </summary>
        </member>
        <member name="M:Ext.MessageBox.updateButtons(System.Object)">
            <summary>
            Adds the new {@link Ext.Toolbar} instance into this container
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.updateIconCls(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.updateMsg(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.updatePromptConfig(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.MessageBox.updateTitle(System.Object)">
            <summary>
            Adds the new {@link Ext.Toolbar} instance into this container
            @private
            </summary>
        </member>
        <member name="P:Ext.MessageBox.extend">
            <summary>
            Utility class for generating different styles of message boxes. The framework provides a global singleton
            {@link Ext.Msg} for common usage.
            *
            Note that the MessageBox is asynchronous. Unlike a regular JavaScript `alert` (which will halt browser execution),
            showing a MessageBox will not cause the code to stop. For this reason, if you have code that should only run _after_
            some user feedback from the MessageBox, you must use a callback function (see the `fn` configuration option parameter
            for the {@link #show show} method for more details).
            *
            # Example usage:
            *
            Basic alert:
            *
            @example preview
            Ext.Msg.alert('Title', 'The quick brown fox jumped over the lazy dog.', Ext.emptyFn);
            *
            Prompt for user data and process the result using a callback:
            *
            @example preview
            Ext.Msg.prompt('Name', 'Please enter your name:', function(text) {
            // process text value and close...
            });
            *
            Confirmation alert:
            *
            @example preview
            Ext.Msg.confirm("Confirmation", "Are you sure you want to do that?", Ext.emptyFn);
            *
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.buttons">
            <summary>
            An array of buttons, or an object of a button to be displayed in the toolbar of this {@link Ext.MessageBox}.
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.defaultTextHeight">
            <summary>
            The default height in pixels of the message box's multiline textarea if displayed.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.enterAnimation">
            <summary>
            Effect when the message box is being displayed.
            @todo not implemented
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.exitAnimation">
            <summary>
            Effect when the message box is being hidden.
            @todo not implemented
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.iconCls">
            <summary>
            CSS class for the icon When null disables the icon.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.msg">
            <summary>
            The message to be displayed in the {@link Ext.MessageBox}.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.promptConfig">
            <summary>
            The configuration to be passed if you want an {@link Ext.field.Text} or {@link Ext.field.TextArea} field
            in your {@link Ext.MessageBox}.
            Pass an object with the property "multiline" with a value of true, if you want the prompt to use a TextArea.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.MessageBoxConfig.title">
            <summary>
            The title of this {@link Ext.MessageBox}.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.ModelManager.create(System.Object,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber)">
            <summary>
            Creates a new instance of a Model using the given data.
            *
            This method is deprecated.  Use {@link Ext#create Ext.create} instead.  For example:
            *
            Ext.create('User', {
            first: 'Ed',
            last: 'Spencer'
            });
            *
            @param {Object} data Data to initialize the Model's fields with
            @param {String} name The name of the model to create
            @param {Number} id (Optional) unique id of the Model instance (see {@link Ext.data.Model})
            </summary>
        </member>
        <member name="M:Ext.ModelManager.getModel(System.Object)">
            <summary>
            Returns the {@link Ext.data.Model} for a given model name
            @param {String/Object} id The id of the model or the model instance.
            @return {Ext.data.Model} a model class.
            </summary>
        </member>
        <member name="M:Ext.ModelManager.onModelDefined(SharpKit.JavaScript.JsAction)">
            <summary>
            @private
            Private callback called whenever a model has just been defined. This sets up any associations
            that were waiting for the given model to be defined
            @param {Function} model The model that was just created
            </summary>
        </member>
        <member name="M:Ext.ModelManager.registerDeferredAssociation(Ext.data.association.Association)">
            <summary>
            Registers an association where one of the models defined doesn't exist yet.
            The ModelManager will check when new models are registered if it can link them
            together
            @private
            @param {Ext.data.association.Association} association The association
            </summary>
        </member>
        <member name="M:Ext.ModelManager.registerType(System.Object,System.Object)">
            <summary>
            Registers a model definition. All model plugins marked with isDefault: true are bootstrapped
            immediately, as are any addition plugins defined in the model config.
            @private
            </summary>
        </member>
        <member name="P:Ext.ModelManager.alternateClassName">
            <summary>
            @author Ed Spencer
            @class Ext.ModelManager
            @extends Ext.AbstractManager
            The ModelManager keeps track of all {@link Ext.data.Model} types defined in your application.
            __Creating Model Instances__
            Model instances can be created by using the {@link Ext#create Ext.create} method. Ext.create replaces
            the deprecated {@link #create Ext.ModelManager.create} method. It is also possible to create a model instance
            this by using the Model type directly. The following 3 snippets are equivalent:
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['first', 'last']
            });
            // method 1, create using Ext.create (recommended)
            Ext.create('User', {
            first: 'Ed',
            last: 'Spencer'
            });
            // method 2, create through the manager (deprecated)
            Ext.ModelManager.create({
            first: 'Ed',
            last: 'Spencer'
            }, 'User');
            // method 3, create on the type directly
            new User({
            first: 'Ed',
            last: 'Spencer'
            });
            __Accessing Model Types__
            A reference to a Model type can be obtained by using the {@link #getModel} function. Since models types
            are normal classes, you can access the type directly. The following snippets are equivalent:
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['first', 'last']
            });
            // method 1, access model type through the manager
            var UserType = Ext.ModelManager.getModel('User');
            // method 2, reference the type directly
            var UserType = User;
            @markdown
            @singleton
            </summary>
        </member>
        <member name="P:Ext.ModelManager.extend">
            <summary>
            @author Ed Spencer
            @class Ext.ModelManager
            @extends Ext.AbstractManager
            The ModelManager keeps track of all {@link Ext.data.Model} types defined in your application.
            __Creating Model Instances__
            Model instances can be created by using the {@link Ext#create Ext.create} method. Ext.create replaces
            the deprecated {@link #create Ext.ModelManager.create} method. It is also possible to create a model instance
            this by using the Model type directly. The following 3 snippets are equivalent:
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['first', 'last']
            });
            // method 1, create using Ext.create (recommended)
            Ext.create('User', {
            first: 'Ed',
            last: 'Spencer'
            });
            // method 2, create through the manager (deprecated)
            Ext.ModelManager.create({
            first: 'Ed',
            last: 'Spencer'
            }, 'User');
            // method 3, create on the type directly
            new User({
            first: 'Ed',
            last: 'Spencer'
            });
            __Accessing Model Types__
            A reference to a Model type can be obtained by using the {@link #getModel} function. Since models types
            are normal classes, you can access the type directly. The following snippets are equivalent:
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['first', 'last']
            });
            // method 1, access model type through the manager
            var UserType = Ext.ModelManager.getModel('User');
            // method 2, reference the type directly
            var UserType = User;
            @markdown
            @singleton
            </summary>
        </member>
        <member name="P:Ext.NavigationBar.extend">
            <summary>
            Navigation  are most commonly used as dockedItems within an Ext.Panel.
            They can be docked at the 'top' or 'bottom' of a Panel by specifying
            the dock config.
            *
            The {@link #defaultType} of Toolbar's is '{@link Ext.Button button}'.
            *
            # Example:
            *
            var myNavBar = new Ext.NavigationBar({
            dock : 'top',
            title: 'Navigation',
            items: [
            {
            text: 'My Button'
            }
            ]
            });
            *
            var myPanel = new Ext.Panel({
            dockedItems: [myNavBar],
            fullscreen : true,
            html       : 'Test Panel'
            });
            *
            </summary>
        </member>
        <member name="P:Ext.NavigationBarConfig.defaultType">
            <summary>
            The default xtype to create.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.NavigationBarConfig.title">
            <summary>
            The title of the toolbar.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.NavigationBarConfig.ui">
            <summary>
            Style options for Toolbar. Either 'light' or 'dark'.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.Number.constrain(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Checks whether or not the passed number is within a desired range.  If the number is already within the
            range it is returned, otherwise the min or max value is returned depending on which side of the range is
            exceeded. Note that this method returns the constrained value but does not change the current number.
            @param {Number} number The number to check
            @param {Number} min The minimum number in the range
            @param {Number} max The maximum number in the range
            @return {Number} The constrained value if outside the range, otherwise the current value
            </summary>
        </member>
        <member name="M:Ext.Number.from(System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            Validate that a value is numeric and convert it to a number if necessary. Returns the specified default value if
            it is not.
            Ext.Number.from('1.23', 1); // returns 1.23
            Ext.Number.from('abc', 1); // returns 1
            @param {Object} value
            @param {Number} defaultValue The value to return if the original value is non-numeric
            @return {Number} value, if numeric, defaultValue otherwise
            </summary>
        </member>
        <member name="M:Ext.Number.snap(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Snaps the passed number between stopping points based upon a passed increment value.
            @param {Number} value The unsnapped value.
            @param {Number} increment The increment by which the value must move.
            @param {Number} minValue The minimum value to which the returned value must be constrained. Overrides the increment..
            @param {Number} maxValue The maximum value to which the returned value must be constrained. Overrides the increment..
            @return {Number} The value of the nearest snap target.
            </summary>
        </member>
        <member name="M:Ext.Number.toFixed(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Formats a number using fixed-point notation
            @param {Number} value The number to format
            @param {Number} precision The number of digits to show after the decimal point
            </summary>
        </member>
        <member name="P:Ext.Panel.extend">
            <summary>
            Panel is a container that has specific functionality and structural components that make it the perfect building
            block for application-oriented user interfaces.
            *
            Panels are, by virtue of their inheritance from {@link Ext.Container}, capable of being configured with a {@link
            Ext.Container#layout layout}, and containing child Components.
            *
            When either specifying child {@link Ext.Container#items items} of a Panel, or dynamically {@link Ext.Container#add
            adding} Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and
            whether those child elements need to be sized using one of Ext's built-in `**{@link Ext.Container#layout layout}**`
            schemes.
            *
            # Example:
            *
            @example preview
            var panel = Ext.create('Ext.Panel', {
            fullscreen: true,
            *
            items: [
            {
            dock : 'top',
            xtype: 'toolbar',
            title: 'Standard Titlebar'
            },
            {
            dock : 'top',
            xtype: 'toolbar',
            ui   : 'light',
            items: [
            {
            text: 'Test Button'
            }
            ]
            }
            ],
            *
            html: 'Testing'
            });
            *
            </summary>
        </member>
        <member name="P:Ext.Panel.isPanel">
            <summary>
            Panel is a container that has specific functionality and structural components that make it the perfect building
            block for application-oriented user interfaces.
            *
            Panels are, by virtue of their inheritance from {@link Ext.Container}, capable of being configured with a {@link
            Ext.Container#layout layout}, and containing child Components.
            *
            When either specifying child {@link Ext.Container#items items} of a Panel, or dynamically {@link Ext.Container#add
            adding} Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and
            whether those child elements need to be sized using one of Ext's built-in `**{@link Ext.Container#layout layout}**`
            schemes.
            *
            # Example:
            *
            @example preview
            var panel = Ext.create('Ext.Panel', {
            fullscreen: true,
            *
            items: [
            {
            dock : 'top',
            xtype: 'toolbar',
            title: 'Standard Titlebar'
            },
            {
            dock : 'top',
            xtype: 'toolbar',
            ui   : 'light',
            items: [
            {
            text: 'Test Button'
            }
            ]
            }
            ],
            *
            html: 'Testing'
            });
            *
            </summary>
        </member>
        <member name="T:Ext.pass">
            <summary>
            @method
            @member Ext
            @alias Ext.Function#pass
            </summary>
        </member>
        <member name="M:Ext.PluginManager.findByType(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Returns all plugins registered with the given type. Here, 'type' refers to the type of plugin, not its ptype.
            @param {String} type The type to search for
            @param {Boolean} defaultsOnly True to only return plugins of this type where the plugin's isDefault property is
            truthy
            @return {Ext.AbstractPlugin[]} All matching plugins
            </summary>
        </member>
        <member name="P:Ext.PluginManager.alternateClassName">
            <summary>
            @singleton
            *
            Provides a registry of available Plugin classes indexed by a mnemonic code known as the Plugin's ptype.
            *
            A plugin may be specified simply as a *config object* as long as the correct `ptype` is specified:
            *
            {
            ptype: 'gridviewdragdrop',
            dragText: 'Drag and drop to reorganize'
            }
            *
            Or just use the ptype on its own:
            *
            'gridviewdragdrop'
            *
            Alternatively you can instantiate the plugin with Ext.create:
            *
            Ext.create('Ext.view.plugin.AutoComplete', {
            ptype: 'gridviewdragdrop',
            dragText: 'Drag and drop to reorganize'
            })
            </summary>
        </member>
        <member name="P:Ext.PluginManager.extend">
            <summary>
            @singleton
            *
            Provides a registry of available Plugin classes indexed by a mnemonic code known as the Plugin's ptype.
            *
            A plugin may be specified simply as a *config object* as long as the correct `ptype` is specified:
            *
            {
            ptype: 'gridviewdragdrop',
            dragText: 'Drag and drop to reorganize'
            }
            *
            Or just use the ptype on its own:
            *
            'gridviewdragdrop'
            *
            Alternatively you can instantiate the plugin with Ext.create:
            *
            Ext.create('Ext.view.plugin.AutoComplete', {
            ptype: 'gridviewdragdrop',
            dragText: 'Drag and drop to reorganize'
            })
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.applyItems">
            <summary>
            We override initItems so we can check for the pressed config.
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.applyPressedButtons(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.#ctor">
            <summary>
            @event toggle
            Fires when any child button's pressed state has changed.
            @param {Ext.SegmentedButton} this
            @param {Ext.Button[]} pressedButtons The new pressed buttons
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.disable">
            <summary>
            Disables all buttons
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.doUpdatePressedButtons(System.Object)">
            <summary>
            Updates the pressed buttons.
            @private
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.enable">
            <summary>
            Enables all buttons
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.onButtonRelease">
            <summary>
            Button sets a timeout of 10ms to remove the {@link #pressedCls} on the release event.
            We don't want this to happen, so lets return false and cancel the event.
            @private
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.onButtonTap(System.Object)">
            <summary>
            Called when the button has been tapped.
            Checks for {@link #allowMultiple} + {@link #allowDepress} and delegates accordingly
            @private
            </summary>
        </member>
        <member name="M:Ext.SegmentedButton.updatePressedButtons(System.Object,System.Object)">
            <summary>
            Called when the {@link #pressedButtons} config gets changed. Fires off the toggle event.
            @private
            </summary>
        </member>
        <member name="P:Ext.SegmentedButton.extend">
            <summary>
            SegmentedButton is a container for a group of {@link Ext.Button}s. Generally a SegmentedButton would be
            a child of a {@link Ext.Toolbar} and would be used to switch between different views.
            # Useful Properties:
            *
            - {@link #allowMultiple}
            # Example usage:
            *
            var segmentedButton = new Ext.SegmentedButton({
            allowMultiple: true,
            items: [
            {
            text: 'Option 1'
            },
            {
            text   : 'Option 2',
            pressed: true,
            handler: tappedFn
            },
            {
            text: 'Option 3'
            }
            ],
            listeners: {
            toggle: function(container, button, pressed){
            console.log("User toggled the '" + button.text + "' button: " + (pressed ? 'on' : 'off'));
            }
            }
            });
            *
            </summary>
        </member>
        <member name="P:Ext.SegmentedButton.xtype">
            <summary>
            SegmentedButton is a container for a group of {@link Ext.Button}s. Generally a SegmentedButton would be
            a child of a {@link Ext.Toolbar} and would be used to switch between different views.
            # Useful Properties:
            *
            - {@link #allowMultiple}
            # Example usage:
            *
            var segmentedButton = new Ext.SegmentedButton({
            allowMultiple: true,
            items: [
            {
            text: 'Option 1'
            },
            {
            text   : 'Option 2',
            pressed: true,
            handler: tappedFn
            },
            {
            text: 'Option 3'
            }
            ],
            listeners: {
            toggle: function(container, button, pressed){
            console.log("User toggled the '" + button.text + "' button: " + (pressed ? 'on' : 'off'));
            }
            }
            });
            *
            </summary>
        </member>
        <member name="P:Ext.SegmentedButtonConfig.allowDepress">
            <summary>
            Allow toggling the pressed state of each button.
            Defaults to true when `allowMultiple` is true.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SegmentedButtonConfig.allowMultiple">
            <summary>
            Allow multiple pressed buttons.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SegmentedButtonConfig.pressedButtons">
            <summary>
            The pressed buttons for this segmented button.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SegmentedButtonConfig.pressedCls">
            <summary>
            CSS class when a button is in pressed state.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.Sheet.alias">
            <summary>
            A general sheet class. This renderable container provides base support for orientation-aware transitions for popup or
            side-anchored sliding Panels. In most cases, you should use {@link Ext.ActionSheet}, {@link Ext.MessageBox}, {@link Ext.picker.Picker} or {@link Ext.picker.Date}.
            *
            ## Example
            *
            @example preview
            var sheet = Ext.create('Ext.Sheet', {
            items: [
            {
            dock : 'bottom',
            xtype: 'button',
            text : 'Click me'
            }
            ]
            });
            sheet.show();
            </summary>
        </member>
        <member name="P:Ext.Sheet.extend">
            <summary>
            A general sheet class. This renderable container provides base support for orientation-aware transitions for popup or
            side-anchored sliding Panels. In most cases, you should use {@link Ext.ActionSheet}, {@link Ext.MessageBox}, {@link Ext.picker.Picker} or {@link Ext.picker.Date}.
            *
            ## Example
            *
            @example preview
            var sheet = Ext.create('Ext.Sheet', {
            items: [
            {
            dock : 'bottom',
            xtype: 'button',
            text : 'Click me'
            }
            ]
            });
            sheet.show();
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.centered">
            <summary>
            Whether or not this component is absolutely centered inside its container
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.enter">
            <summary>
            The viewport side used as the enter point when shown (top, bottom, left, right)
            Applies to sliding animation effects only. Defaults to 'bottom'
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.enterAnimation">
            <summary>
            the named Ext.anim effect or animation configuration object used for transitions
            when the component is shown. Defaults to 'slide'
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.exit">
            <summary>
            The viewport side used as the exit point when hidden (top, bottom, left, right)
            Applies to sliding animation effects only. Defaults to 'bottom'
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.exitAnimation">
            <summary>
            the named Ext.anim effect or animation configuration object used for transitions
            when the component is hidden. Defaults to 'slide'
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.hidden">
            <summary>
            True to hide this component
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.hideOnMaskTap">
            <summary>
            When using a {@link #modal} Component, setting this to true (the default) will
            hide the modal mask and the Component when the mask is tapped on
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.modal">
            <summary>
            True to make this Component modal. This will create a mask underneath the Component
            that covers the whole page and does not allow the user to interact with any other Components until this
            Component is dismissed
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.stretchX">
            <summary>
            True to stretch this sheet horizontally.
            </summary>
        </member>
        <member name="P:Ext.SheetConfig.stretchY">
            <summary>
            True to stretch this sheet vertically.
            </summary>
        </member>
        <member name="M:Ext.Sortable.#ctor(System.Object,System.Object)">
            <summary>
            Creates new Sortable.
            @param {Mixed} el
            @param {Object} config
            </summary>
        </member>
        <member name="M:Ext.Sortable.disable">
            <summary>
            Disables sorting for this Sortable.
            </summary>
        </member>
        <member name="M:Ext.Sortable.enable">
            <summary>
            Enables sorting for this Sortable.
            This method is invoked immediately after construction of a Sortable unless
            the disabled configuration is set to true.
            </summary>
        </member>
        <member name="M:Ext.Sortable.isDisabled">
            <summary>
            Method to determine whether this Sortable is currently disabled.
            @return {Boolean} the disabled state of this Sortable.
            </summary>
        </member>
        <member name="M:Ext.Sortable.isHorizontal">
            <summary>
            Method to determine whether this Sortable is currently sorting.
            @return {Boolean} the sorting state of this Sortable.
            </summary>
        </member>
        <member name="M:Ext.Sortable.isSorting">
            <summary>
            Method to determine whether this Sortable is currently sorting.
            @return {Boolean} the sorting state of this Sortable.
            </summary>
        </member>
        <member name="M:Ext.Sortable.isVertical">
            <summary>
            Method to determine whether this Sortable is currently disabled.
            @return {Boolean} the disabled state of this Sortable.
            </summary>
        </member>
        <member name="P:Ext.Sortable.cancelSelector">
            <summary>
            @cfg {String} cancelSelector
            A simple CSS selector that represents elements within the draggable
            that should NOT initiate a drag.
            </summary>
        </member>
        <member name="P:Ext.Sortable.direction">
            <summary>
            @cfg {String} direction
            Possible values: 'vertical', 'horizontal'
            Defaults to 'vertical'
            </summary>
        </member>
        <member name="P:Ext.Sortable.disabled">
            <summary>
            @cfg {Boolean} disabled
            Passing in true will disable this Sortable.
            </summary>
        </member>
        <member name="P:Ext.Sortable.group">
            <summary>
            @cfg {String} group
            Draggable and Droppable objects can participate in a group which are
            capable of interacting. Defaults to 'base'
            </summary>
        </member>
        <member name="P:Ext.Sortable.handleSelector">
            <summary>
            @cfg {String} handleSelector
            A simple CSS selector to indicate what is the handle to drag the Sortable.
            </summary>
        </member>
        <member name="P:Ext.Sortable.itemSelector">
            <summary>
            @cfg {String} itemSelector
            A simple CSS selector that represents individual items within the Sortable.
            </summary>
        </member>
        <member name="P:Ext.Sortable.revert">
            <summary>
            @cfg {Boolean} revert
            This should NOT be changed.
            @private
            </summary>
        </member>
        <member name="P:Ext.Sortable.sorting">
            <summary>
            Read-only property that indicates whether a Sortable is currently sorting.
            @type Boolean
            @private
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.cancelSelector">
            <summary>
            A simple CSS selector that represents elements within the draggable
            that should NOT initiate a drag.
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.constrain">
            <summary>
            An Element to constrain the Sortable dragging to. Defaults to <tt>window</tt>.
            If <tt>true</tt> is specified, the dragging will be constrained to the element
            of the sortable.
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.delay">
            <summary>
            How many milliseconds a user must hold the draggable before starting a
            drag operation. Defaults to 0 or immediate.
            @private
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.direction">
            <summary>
            Possible values: 'vertical', 'horizontal'
            Defaults to 'vertical'
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.disabled">
            <summary>
            Passing in true will disable this Sortable.
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.group">
            <summary>
            Draggable and Droppable objects can participate in a group which are
            capable of interacting. Defaults to 'base'
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.handleSelector">
            <summary>
            A simple CSS selector to indicate what is the handle to drag the Sortable.
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.itemSelector">
            <summary>
            A simple CSS selector that represents individual items within the Sortable.
            </summary>
        </member>
        <member name="P:Ext.SortableConfig.revert">
            <summary>
            This should NOT be changed.
            @private
            </summary>
        </member>
        <member name="P:Ext.Spacer.alias">
            <summary>
            The {@link Ext.Spacer} component is generally used to put space between items in {@link Ext.Toolbar} components.
            ## Examples
            By default the {@link #flex} configuration is set to 1:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer'
            },
            {
            xtype: 'button',
            text : 'Button Two'
            }
            ]
            }
            ]
            });
            Alternatively you can just set the {@link #width} configuration which will get the {@link Ext.Spacer} a fixed width:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center',
            align: 'stretch'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer',
            width: 50
            },
            {
            xtype: 'button',
            text : 'Button Two'
            }
            ]
            },
            {
            xtype: 'container',
            items: [
            {
            xtype: 'button',
            text : 'Change Ext.Spacer width',
            handler: function() {
            //get the spacer using ComponentQuery
            var spacer = Ext.ComponentQuery.query('spacer')[0],
            from = 10,
            to = 250;
            //set the width to a random number
            (to - from + 1) + from));
            }
            }
            ]
            }
            ]
            });
            You can also insert multiple {@link Ext.Spacer}'s:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer'
            },
            {
            xtype: 'button',
            text : 'Button Two'
            },
            {
            xtype: 'spacer',
            width: 20
            },
            {
            xtype: 'button',
            text : 'Button Three'
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.Spacer.extend">
            <summary>
            The {@link Ext.Spacer} component is generally used to put space between items in {@link Ext.Toolbar} components.
            ## Examples
            By default the {@link #flex} configuration is set to 1:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer'
            },
            {
            xtype: 'button',
            text : 'Button Two'
            }
            ]
            }
            ]
            });
            Alternatively you can just set the {@link #width} configuration which will get the {@link Ext.Spacer} a fixed width:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center',
            align: 'stretch'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer',
            width: 50
            },
            {
            xtype: 'button',
            text : 'Button Two'
            }
            ]
            },
            {
            xtype: 'container',
            items: [
            {
            xtype: 'button',
            text : 'Change Ext.Spacer width',
            handler: function() {
            //get the spacer using ComponentQuery
            var spacer = Ext.ComponentQuery.query('spacer')[0],
            from = 10,
            to = 250;
            //set the width to a random number
            (to - from + 1) + from));
            }
            }
            ]
            }
            ]
            });
            You can also insert multiple {@link Ext.Spacer}'s:
            @example preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            items: [
            {
            xtype: 'button',
            text : 'Button One'
            },
            {
            xtype: 'spacer'
            },
            {
            xtype: 'button',
            text : 'Button Two'
            },
            {
            xtype: 'spacer',
            width: 20
            },
            {
            xtype: 'button',
            text : 'Button Three'
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.SpacerConfig.flex">
            <summary>
            The flex value of this spacer. This defaults to 1, if no width has been set.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.SpacerConfig.width">
            <summary>
            The width of this spacer. If this is set, the value of {@link #flex} will be ignored.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.String.capitalize(SharpKit.JavaScript.JsString)">
            <summary>
            Capitalize the given string
            @param {String} string
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.String.ellipsis(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,System.Boolean)">
            <summary>
            Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length
            @param {String} value The string to truncate
            @param {Number} length The maximum length to allow before truncating
            @param {Boolean} word True to try to find a common word break
            @return {String} The converted text
            </summary>
        </member>
        <member name="M:Ext.String.escape(SharpKit.JavaScript.JsString)">
            <summary>
            Escapes the passed string for ' and \
            @param {String} string The string to escape
            @return {String} The escaped string
            </summary>
        </member>
        <member name="M:Ext.String.escapeRegex(SharpKit.JavaScript.JsString)">
            <summary>
            Escapes the passed string for use in a regular expression
            @param {String} string
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.String.format(SharpKit.JavaScript.JsString)">
            <summary>
            Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
            token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
            <pre><code>
            var cls = 'my-class', text = 'Some text';
            var s = Ext.String.format('&lt;div class="{0}">{1}&lt;/div>', cls, text);
            // s now contains the string: '&lt;div class="my-class">Some text&lt;/div>'
            </code></pre>
            @param {String} string The tokenized string to be formatted
            @param {String} value1 The value to replace token {0}
            @param {String} value2 Etc...
            @return {String} The formatted string
            </summary>
        </member>
        <member name="M:Ext.String.leftPad(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsString)">
            <summary>
            Pads the left side of a string with a specified character.  This is especially useful
            for normalizing number and date strings.  Example usage:
            *
            <pre><code>
            var s = Ext.String.leftPad('123', 5, '0');
            // s now contains the string: '00123'
            </code></pre>
            @param {String} string The original string
            @param {Number} size The total length of the output string
            @param {String} character (optional) The character with which to pad the original string (defaults to empty string " ")
            @return {String} The padded string
            </summary>
        </member>
        <member name="M:Ext.String.repeat(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsString)">
            <summary>
            Returns a string with a specified number of repititions a given string pattern.
            The pattern be separated by a different string.
            *
            var s = Ext.String.repeat('---', 4); // = '------------'
            var t = Ext.String.repeat('--', 3, '/'); // = '--/--/--'
            *
            @param {String} pattern The pattern to repeat.
            @param {Number} count The number of times to repeat the pattern (may be 0).
            @param {String} sep An option string to separate each pattern.
            </summary>
        </member>
        <member name="M:Ext.String.toggle(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Utility function that allows you to easily switch a string between two alternating values.  The passed value
            is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
            they are already different, the first value passed in is returned.  Note that this method returns the new value
            but does not change the current string.
            <pre><code>
            // alternate sort directions
            sort = Ext.String.toggle(sort, 'ASC', 'DESC');
            // instead of conditional logic:
            sort = (sort == 'ASC' ? 'DESC' : 'ASC');
            </code></pre>
            @param {String} string The current string
            @param {String} value The value to compare to the current string
            @param {String} other The new value to use if the string already equals the first value passed in
            @return {String} The new value
            </summary>
        </member>
        <member name="M:Ext.String.trim(SharpKit.JavaScript.JsString)">
            <summary>
            Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
            @example
            var s = '  foo bar  ';
            alert('-' + s + '-');         //alerts "- foo bar -"
            alert('-' + Ext.String.trim(s) + '-');  //alerts "-foo bar-"
            @param {String} string The string to escape
            @return {String} The trimmed string
            </summary>
        </member>
        <member name="M:Ext.String.urlAppend(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Appends content to the query string of a URL, handling logic for whether to place
            a question mark or ampersand.
            @param {String} url The URL to append to.
            @param {String} string The content to append to the URL.
            @return (String) The resulting URL
            </summary>
        </member>
        <member name="P:Ext.String.trimRegex">
            <summary>
            @class Ext.String
            *
            A collection of useful static methods to deal with strings
            @singleton
            </summary>
        </member>
        <member name="M:Ext.Template.append(System.Object,System.Object,System.Boolean)">
            <summary>
            Applies the supplied `values` to the template and appends the new node(s) to the specified `el`.
            *
            For example usage see {@link Ext.Template Ext.Template class docs}.
            *
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
            @param {Boolean} returnElement (optional) true to return an Ext.Element.
            @return {HTMLElement/Ext.Element} The new node or Element
            </summary>
        </member>
        <member name="M:Ext.Template.apply(System.Object)">
            <summary>
            Returns an HTML fragment of this template with the specified values applied.
            *
            @param {Object/Array} values The template values. Can be an array if your params are numeric:
            *
            var tpl = new Ext.Template('Name: {0}, Age: {1}');
            tpl.apply(['John', 25]);
            *
            or an object:
            *
            var tpl = new Ext.Template('Name: {name}, Age: {age}');
            tpl.apply({name: 'John', age: 25});
            *
            @return {String} The HTML fragment
            </summary>
        </member>
        <member name="M:Ext.Template.applyOut(System.Object,SharpKit.JavaScript.JsArray)">
            <summary>
            Appends the result of this template to the provided output array.
            @param {Object/Array} values The template values. See {@link #apply}.
            @param {Array} out The array to which output is pushed.
            @return {Array} The given out array.
            </summary>
        </member>
        <member name="M:Ext.Template.applyTemplate">
            <summary>
            @method applyTemplate
            @member Ext.Template
            Alias for {@link #apply}.
            @alias Ext.Template#apply
            </summary>
        </member>
        <member name="M:Ext.Template.compile">
            <summary>
            Compiles the template into an internal function, eliminating the RegEx overhead.
            @return {Ext.Template} this
            </summary>
        </member>
        <member name="M:Ext.Template.#ctor(System.Object)">
            <summary>
            Creates new template.
            @param {String...} html List of strings to be concatenated into template.
            Alternatively an array of strings can be given, but then no config object may be passed.
            @param {Object} config (optional) Config object
            </summary>
        </member>
        <member name="M:Ext.Template.insertAfter(System.Object,System.Object,System.Boolean)">
            <summary>
            Applies the supplied values to the template and inserts the new node(s) after el.
            *
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
            @param {Boolean} returnElement (optional) true to return a Ext.Element.
            @return {HTMLElement/Ext.Element} The new node or Element
            </summary>
        </member>
        <member name="M:Ext.Template.insertBefore(System.Object,System.Object,System.Boolean)">
            <summary>
            Applies the supplied values to the template and inserts the new node(s) before el.
            *
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
            @param {Boolean} returnElement (optional) true to return a Ext.Element.
            @return {HTMLElement/Ext.Element} The new node or Element
            </summary>
        </member>
        <member name="M:Ext.Template.insertFirst(System.Object,System.Object,System.Boolean)">
            <summary>
            Applies the supplied values to the template and inserts the new node(s) as the first child of el.
            *
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
            @param {Boolean} returnElement (optional) true to return a Ext.Element.
            @return {HTMLElement/Ext.Element} The new node or Element
            </summary>
        </member>
        <member name="M:Ext.Template.overwrite(System.Object,System.Object,System.Boolean)">
            <summary>
            Applies the supplied values to the template and overwrites the content of el with the new node(s).
            *
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
            @param {Boolean} returnElement (optional) true to return a Ext.Element.
            @return {HTMLElement/Ext.Element} The new node or Element
            </summary>
        </member>
        <member name="M:Ext.Template.set(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Sets the HTML used as the template and optionally compiles it.
            @param {String} html
            @param {Boolean} compile (optional) True to compile the template.
            @return {Ext.Template} this
            </summary>
        </member>
        <member name="P:Ext.Template.disableFormats">
            <summary>
            @cfg {Boolean} disableFormats
            True to disable format functions in the template. If the template doesn't contain
            format functions, setting disableFormats to true will reduce apply time. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.Template.re">
            <summary>
            @cfg {Boolean} disableFormats
            True to disable format functions in the template. If the template doesn't contain
            format functions, setting disableFormats to true will reduce apply time. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.TemplateConfig.compiled">
            <summary>
            True to immediately compile the template. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.Title.extend">
            <summary>
            {@link Ext.Title} is used for the {@link Ext.Toolbar#title} configuration in the {@link Ext.Toolbar} component.
            </summary>
        </member>
        <member name="P:Ext.Title.xtype">
            <summary>
            {@link Ext.Title} is used for the {@link Ext.Toolbar#title} configuration in the {@link Ext.Toolbar} component.
            </summary>
        </member>
        <member name="P:Ext.TitleConfig.title">
            <summary>
            The title text
            </summary>
        </member>
        <member name="M:Ext.Toolbar.hideTitle">
            <summary>
            Hides the title if it exists.
            </summary>
        </member>
        <member name="M:Ext.Toolbar.showTitle">
            <summary>
            Shows the title if it exists.
            </summary>
        </member>
        <member name="P:Ext.Toolbar.extend">
            <summary>
            {@link Ext.Toolbar}s are most commonly used as docked items as within a {@link Ext.Container}. They can be docked either `top` or `bottom` using the {@link #docked} configuration.
            The {@link #defaultType} of {@link Ext.Toolbar} is {@link Ext.Button}.
            ## Examples
            @example miniphone preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title: 'My Toolbar'
            },
            {
            xtype: 'container',
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            defaults: {
            xtype: 'button',
            margin: '10 10 0 10'
            },
            items: [
            {
            text: 'Toggle docked',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            newDocked = (toolbar.getDocked() == 'top') ? 'bottom' : 'top';
            toolbar.setDocked(newDocked);
            }
            },
            {
            text: 'Toggle UI',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            newUi = (toolbar.getUi() == 'light') ? 'dark' : 'light';
            toolbar.setUi(newUi);
            }
            },
            {
            text: 'Change title',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            titles = ['My Toolbar', 'Ext.Toolbar', 'Configurations are awesome!', 'Beautiful.'],
            //internally, the title configuration gets converted into a {@link Ext.Title} component,
            //so you must get the title configuration of that component
            title = toolbar.getTitle().getTitle(),
            newTitle = titles[titles.indexOf(title) + 1] || titles[0];
            toolbar.setTitle(newTitle);
            }
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.Toolbar.xtype">
            <summary>
            {@link Ext.Toolbar}s are most commonly used as docked items as within a {@link Ext.Container}. They can be docked either `top` or `bottom` using the {@link #docked} configuration.
            The {@link #defaultType} of {@link Ext.Toolbar} is {@link Ext.Button}.
            ## Examples
            @example miniphone preview
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            items: [
            {
            xtype : 'toolbar',
            docked: 'top',
            title: 'My Toolbar'
            },
            {
            xtype: 'container',
            layout: {
            type: 'vbox',
            pack: 'center'
            },
            defaults: {
            xtype: 'button',
            margin: '10 10 0 10'
            },
            items: [
            {
            text: 'Toggle docked',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            newDocked = (toolbar.getDocked() == 'top') ? 'bottom' : 'top';
            toolbar.setDocked(newDocked);
            }
            },
            {
            text: 'Toggle UI',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            newUi = (toolbar.getUi() == 'light') ? 'dark' : 'light';
            toolbar.setUi(newUi);
            }
            },
            {
            text: 'Change title',
            handler: function() {
            var toolbar = Ext.ComponentQuery.query('toolbar')[0],
            titles = ['My Toolbar', 'Ext.Toolbar', 'Configurations are awesome!', 'Beautiful.'],
            //internally, the title configuration gets converted into a {@link Ext.Title} component,
            //so you must get the title configuration of that component
            title = toolbar.getTitle().getTitle(),
            newTitle = titles[titles.indexOf(title) + 1] || titles[0];
            toolbar.setTitle(newTitle);
            }
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.ToolbarConfig.defaultType">
            <summary>
            The default xtype to create.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ToolbarConfig.docked">
            <summary>
            The docked position for this {@link Ext.Toolbar}. Must be either `top` or `bottom`.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ToolbarConfig.title">
            <summary>
            The title of the toolbar.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.ToolbarConfig.ui">
            <summary>
            The ui for this {@link Ext.Toolbar}. Either 'light' or 'dark'. Cou can create more UIs by using using the CSS Mixin {@link #sencha-toolbar-ui}
            @accessor
            </summary>
        </member>
        <member name="M:Ext.Video.onGhostTap">
            <summary>
            @private
            Called when the {@link #ghost} element is tapped.
            </summary>
        </member>
        <member name="M:Ext.Video.updatePosterUrl(System.Object)">
            <summary>
            Updates the URL to the poster, even if it is rendered.
            @param {Object} newUrl
            </summary>
        </member>
        <member name="P:Ext.Video.extend">
            <summary>
            Provides a simple Container for HTML5 Video.
            *
            # Useful Properties
            *
            - {@link #url}
            - {@link #autoPause}
            - {@link #autoResume}
            *
            # Useful Methods
            *
            - {@link #pause}
            - {@link #play}
            - {@link #toggle}
            *
            # Example code:
            *
            var panel = new Ext.Panel({
            fullscreen: true,
            items: [
            {
            xtype    : 'video',
            x        : 600,
            y        : 300,
            width    : 175,
            height   : 98,
            url      : "porsche911.mov",
            posterUrl: 'porsche.png'
            }
            ]
            });
            *
            </summary>
        </member>
        <member name="P:Ext.Video.xtype">
            <summary>
            Provides a simple Container for HTML5 Video.
            *
            # Useful Properties
            *
            - {@link #url}
            - {@link #autoPause}
            - {@link #autoResume}
            *
            # Useful Methods
            *
            - {@link #pause}
            - {@link #play}
            - {@link #toggle}
            *
            # Example code:
            *
            var panel = new Ext.Panel({
            fullscreen: true,
            items: [
            {
            xtype    : 'video',
            x        : 600,
            y        : 300,
            width    : 175,
            height   : 98,
            url      : "porsche911.mov",
            posterUrl: 'porsche.png'
            }
            ]
            });
            *
            </summary>
        </member>
        <member name="P:Ext.VideoConfig.posterUrl">
            <summary>
            Location of a poster image to be shown before showing the video.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.VideoConfig.url">
            <summary>
            Location of the video to play. This should be in H.264 format and in a .mov file format.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.XTemplate.apply(System.Object)">
            <summary>
            @cfg {Boolean} compiled
            Only applies to {@link Ext.Template}, XTemplates are compiled automatically on the
            first call to {@link #apply} or {@link #applyOut}.
            </summary>
        </member>
        <member name="M:Ext.XTemplate.compile">
            <summary>
            Does nothing. XTemplates are compiled automatically, so this function simply returns this.
            @return {Ext.XTemplate} this
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.XTemplate.extend" -->
        <member name="P:Ext.XTemplateCompiler.extend">
            <summary>
            This class compiles the XTemplate syntax into a function object. The function is used
            like so:
            function (out, values, parent, xindex, xcount) {
            // out is the output array to store results
            // values, parent, xindex and xcount have their historical meaning
            }
            *
            @markdown
            @private
            </summary>
        </member>
        <member name="M:Ext.XTemplateParser.#ctor(System.Object)">
            <summary>
            This class parses the XTemplate syntax and calls abstract methods to process the parts.
            @private
            </summary>
        </member>
        <member name="M:Ext.XTemplateParser.parse(System.Object)">
            <summary>
            This method is called to process an empty &lt;tpl>. This is unlikely to need to be
            implemented, so a default (do nothing) version is provided.
            @method doTpl
            </summary>
        </member>
        <member name="M:Ext.app.Application.#ctor(System.Object)">
            <summary>
            Creates new Application.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.app.Application.onBeforeLaunch">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.app.Application.alternateClassName">
            <summary>
            Represents a Sencha Touch application, which is typically a single page app using a
            {@link Ext.viewport.Viewport Viewport}. A typical Ext.app.Application might look like this:
            *
            Ext.application({
            name: 'MyApp',
            launch: function() {
            Ext.create('Ext.Panel', {
            fullscreen: true,
            html: 'Hello World'
            });
            }
            });
            *
            This does several things. First it creates a global variable called 'MyApp' - all of your Application's classes (such
            as its Models, Views and Controllers) will reside under this single namespace, which drastically lowers the chances
            of colliding global variables.
            *
            When the page is ready and all of your JavaScript has loaded, your Application's {@link #launch} function is called,
            at which time you can run the code that starts your app. Usually this consists of creating a Viewport, as we do in
            the example above.
            *
            ## Telling Application about the rest of the app
            *
            Because an Ext.app.Application represents an entire app, we should tell it about the other parts of the app - namely
            the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
            might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
            Here's how we'd tell our Application about all these things:
            *
            Ext.application({
            name: 'Blog',
            models: ['Post', 'Comment'],
            controllers: ['Posts', 'Comments'],
            *
            launch: function() {
            ...
            }
            });
            *
            Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
            Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
            Controllers using the pathing conventions laid out in the upcoming application architecture guide - in this case
            expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
            Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
            controller like be defined:
            *
            Ext.define('MyApp.controller.Posts', {
            extend: 'Ext.app.Controller',
            views: ['posts.List', 'posts.Edit'],
            *
            //the rest of the Controller here
            });
            *
            Because we told our Application about our Models and Controllers, and our Controllers about their Views, Sencha
            Touch will automatically load all of our app files for us. This means we don't have to manually add script tags into
            our html files whenever we add a new class, but more importantly it enables us to create a minimized build of our
            entire application using the Ext JS 4 SDK Tools.
            ## Further Reading
            Applications are usually populated with Models, Views and Controllers. We're working on a set of guides around MVC
            but in the meantime you can find more background information at:
            * {@link Ext.app.Controller}
            * {@link Ext.data.Model}
            * [Component (View) Guide](#!/guide/components)
            *
            @docauthor Ed Spencer
            </summary>
        </member>
        <member name="P:Ext.app.Application.appFolder">
            <summary>
            @cfg {String} appFolder The path to the directory which contains all application's classes.
            This path will be registered via {@link Ext.Loader#setPath} for the namespace specified in the {@link #name name} config.
            Defaults to 'app'
            </summary>
        </member>
        <member name="P:Ext.app.Application.autoCreateViewport">
            <summary>
            @cfg {Boolean} autoCreateViewport True to automatically load and instantiate AppName.view.Viewport
            before firing the launch function (defaults to false).
            </summary>
        </member>
        <member name="P:Ext.app.Application.enableQuickTips">
            <summary>
            @cfg {Boolean} enableQuickTips True to automatically set up Ext.tip.QuickTip support (defaults to true)
            </summary>
        </member>
        <member name="P:Ext.app.Application.extend">
            <summary>
            Represents a Sencha Touch application, which is typically a single page app using a
            {@link Ext.viewport.Viewport Viewport}. A typical Ext.app.Application might look like this:
            *
            Ext.application({
            name: 'MyApp',
            launch: function() {
            Ext.create('Ext.Panel', {
            fullscreen: true,
            html: 'Hello World'
            });
            }
            });
            *
            This does several things. First it creates a global variable called 'MyApp' - all of your Application's classes (such
            as its Models, Views and Controllers) will reside under this single namespace, which drastically lowers the chances
            of colliding global variables.
            *
            When the page is ready and all of your JavaScript has loaded, your Application's {@link #launch} function is called,
            at which time you can run the code that starts your app. Usually this consists of creating a Viewport, as we do in
            the example above.
            *
            ## Telling Application about the rest of the app
            *
            Because an Ext.app.Application represents an entire app, we should tell it about the other parts of the app - namely
            the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
            might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
            Here's how we'd tell our Application about all these things:
            *
            Ext.application({
            name: 'Blog',
            models: ['Post', 'Comment'],
            controllers: ['Posts', 'Comments'],
            *
            launch: function() {
            ...
            }
            });
            *
            Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
            Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
            Controllers using the pathing conventions laid out in the upcoming application architecture guide - in this case
            expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
            Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
            controller like be defined:
            *
            Ext.define('MyApp.controller.Posts', {
            extend: 'Ext.app.Controller',
            views: ['posts.List', 'posts.Edit'],
            *
            //the rest of the Controller here
            });
            *
            Because we told our Application about our Models and Controllers, and our Controllers about their Views, Sencha
            Touch will automatically load all of our app files for us. This means we don't have to manually add script tags into
            our html files whenever we add a new class, but more importantly it enables us to create a minimized build of our
            entire application using the Ext JS 4 SDK Tools.
            ## Further Reading
            Applications are usually populated with Models, Views and Controllers. We're working on a set of guides around MVC
            but in the meantime you can find more background information at:
            * {@link Ext.app.Controller}
            * {@link Ext.data.Model}
            * [Component (View) Guide](#!/guide/components)
            *
            @docauthor Ed Spencer
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.appFolder">
            <summary>
            The path to the directory which contains all application's classes.
            This path will be registered via {@link Ext.Loader#setPath} for the namespace specified in the {@link #name name} config.
            Defaults to 'app'
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.autoCreateViewport">
            <summary>
            True to automatically load and instantiate AppName.view.Viewport
            before firing the launch function (defaults to false).
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.defaultUrl">
            <summary>
            When the app is first loaded, this url will be redirected to. Defaults to undefined
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.enableQuickTips">
            <summary>
            True to automatically set up Ext.tip.QuickTip support (defaults to true)
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.name">
            <summary>
            The name of your application. This will also be the namespace for your views, controllers
            models and stores. Don't use spaces or special characters in the name.
            </summary>
        </member>
        <member name="P:Ext.app.ApplicationConfig.scope">
            <summary>
            The scope to execute the {@link #launch} function in. Defaults to the Application
            instance.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.#ctor(System.Object)">
            <summary>
            Creates new Controller.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.control(System.Object,System.Object)">
            <summary>
            Adds listeners to components selected via {@link Ext.ComponentQuery}. Accepts an
            object containing component paths mapped to a hash of listener functions.
            *
            In the following example the `updateUser` function is mapped to to the `click`
            event on a button component, which is a child of the `useredit` component.
            *
            Ext.define('AM.controller.Users', {
            init: function() {
            this.control({
            'useredit button[action=save]': {
            click: this.updateUser
            }
            });
            },
            *
            updateUser: function(button) {
            console.log('clicked the Save button');
            }
            });
            *
            See {@link Ext.ComponentQuery} for more information on component selectors.
            *
            @param {String/Object} selectors If a String, the second argument is used as the
            listeners, otherwise an object of selectors -> listeners is assumed
            @param {Object} listeners
            </summary>
        </member>
        <member name="M:Ext.app.Controller.createGetters(Ext.app.Application,System.Object)">
            <summary>
            A template method like {@link #init}, but called after the viewport is created.
            This is called after the {@link Ext.app.Application#launch launch} method of Application is executed.
            *
            @param {Ext.app.Application} application
            @protected
            </summary>
        </member>
        <member name="M:Ext.app.Controller.getController(SharpKit.JavaScript.JsString)">
            <summary>
            Returns instance of a {@link Ext.app.Controller controller} with the given name.
            When controller doesn't exist yet, it's created.
            @param {String} name
            @return {Ext.app.Controller} a controller instance.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.getModel(SharpKit.JavaScript.JsString)">
            <summary>
            Returns a {@link Ext.data.Model Model} class with the given name.
            A shorthand for using {@link Ext.ModelManager#getModel}.
            @param {String} name
            @return {Ext.data.Model} a model class.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.getStore(SharpKit.JavaScript.JsString)">
            <summary>
            Returns instance of a {@link Ext.data.Store Store} with the given name.
            When store doesn't exist yet, it's created.
            @param {String} name
            @return {Ext.data.Store} a store instance.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.getView(SharpKit.JavaScript.JsString)">
            <summary>
            Returns a View class with the given name.  To create an instance of the view,
            you can use it like it's used by Application to create the Viewport:
            *
            this.getView('Viewport').create();
            *
            @param {String} name
            @return {Ext.Base} a view class.
            </summary>
        </member>
        <member name="M:Ext.app.Controller.init(Ext.app.Application)">
            <summary>
            A template method that is called when your application boots. It is called before the
            {@link Ext.app.Application Application}'s launch function is executed so gives a hook point to run any code before
            your Viewport is created.
            *
            @param {Ext.app.Application} application
            @protected
            </summary>
        </member>
        <member name="M:Ext.app.Controller.launch(Ext.app.Application)">
            <summary>
            A template method like {@link #init}, but called after the viewport is created.
            This is called after the {@link Ext.app.Application#launch launch} method of Application is executed.
            *
            @param {Ext.app.Application} application
            @protected
            </summary>
        </member>
        <member name="M:Ext.app.Controller.onClassExtended(System.Object,System.Object,System.Object)">
            <summary>
            @cfg {String} id The id of this controller. You can use this id when dispatching.
            </summary>
        </member>
        <member name="P:Ext.app.Controller.alternateClassName">
            <summary>
            Controllers are the glue that binds an application together. All they really do is listen for events (usually from
            views) and take some action. Here's how we might create a Controller to manage Users:
            *
            Ext.define('MyApp.controller.Users', {
            extend: 'Ext.app.Controller',
            *
            init: function() {
            console.log('Initialized Users! This happens before the Application launch function is called');
            }
            });
            *
            The init function is a special method that is called when your application boots. It is called before the
            {@link Ext.app.Application Application}'s launch function is executed so gives a hook point to run any code before
            your Viewport is created.
            *
            The init function is a great place to set up how your controller interacts with the view, and is usually used in
            conjunction with another Controller function - {@link Ext.app.Controller#control control}. The control function
            makes it easy to listen to events on your view classes and take some action with a handler function. Let's update
            our Users controller to tell us when the panel is rendered:
            *
            Ext.define('MyApp.controller.Users', {
            extend: 'Ext.app.Controller',
            *
            init: function() {
            this.control({
            'viewport > panel': {
            render: this.onPanelRendered
            }
            });
            },
            *
            onPanelRendered: function() {
            console.log('The panel was rendered');
            }
            });
            *
            We've updated the init function to use this.control to set up listeners on views in our application. The control
            function uses the new ComponentQuery engine to quickly and easily get references to components on the page. If you
            are not familiar with ComponentQuery yet, be sure to check out the {@link Ext.ComponentQuery documentation}. In brief though,
            it allows us to pass a CSS-like selector that will find every matching component on the page.
            *
            In our init function above we supplied 'viewport > panel', which translates to "find me every Panel that is a direct
            child of a Viewport". We then supplied an object that maps event names (just 'render' in this case) to handler
            functions. The overall effect is that whenever any component that matches our selector fires a 'render' event, our
            onPanelRendered function is called.
            *
            ## Using refs
            *
            One of the most useful parts of Controllers is the new ref system. These use the new {@link Ext.ComponentQuery} to
            make it really easy to get references to Views on your page. Let's look at an example of this now:
            *
            Ext.define('MyApp.controller.Users', {
            extend: 'Ext.app.Controller',
            *
            refs: [
            {
            ref: 'list',
            selector: 'grid'
            }
            ],
            *
            init: function() {
            this.control({
            'button': {
            click: this.refreshGrid
            }
            });
            },
            *
            refreshGrid: function() {
            this.getList().store.load();
            }
            });
            *
            This example assumes the existence of a Grid on the page, which contains a single button to
            refresh the Grid when clicked. In our refs array, we set up a reference to the grid. There are two parts to this -
            the 'selector', which is a {@link Ext.ComponentQuery ComponentQuery} selector which finds any grid on the page and
            assigns it to the reference 'list'.
            *
            By giving the reference a name, we get a number of things for free. The first is the getList function that we use in
            the refreshGrid method above. This is generated automatically by the Controller based on the name of our ref, which
            was capitalized and prepended with get to go from 'list' to 'getList'.
            *
            The way this works is that the first time getList is called by your code, the ComponentQuery selector is run and the
            first component that matches the selector ('grid' in this case) will be returned. All future calls to getList will
            use a cached reference to that grid. Usually it is advised to use a specific ComponentQuery selector that will only
            match a single View in your application (in the case above our selector will match any grid on the page).
            *
            Bringing it all together, our init function is called when the application boots, at which time we call this.control
            to listen to any click on a {@link Ext.Button button} and call our refreshGrid function (again, this will
            match any button on the page so we advise a more specific selector than just 'button', but have left it this way for
            simplicity). When the button is clicked we use out getList function to refresh the grid.
            *
            You can create any number of refs and control any number of components this way, simply adding more functions to
            your Controller as you go. For an example of real-world usage of Controllers see the Feed Viewer example in the
            examples/app/feed-viewer folder in the SDK download.
            *
            ## Generated getter methods
            *
            Refs aren't the only thing that generate convenient getter methods. Controllers often have to deal with Models and
            Stores so the framework offers a couple of easy ways to get access to those too. Let's look at another example:
            *
            Ext.define('MyApp.controller.Users', {
            extend: 'Ext.app.Controller',
            *
            models: ['User'],
            stores: ['AllUsers', 'AdminUsers'],
            *
            init: function() {
            var User = this.getUserModel(),
            allUsers = this.getAllUsersStore();
            *
            var ed = new User({name: 'Ed'});
            allUsers.add(ed);
            }
            });
            *
            By specifying Models and Stores that the Controller cares about, it again dynamically loads them from the appropriate
            locations (app/model/User.js, app/store/AllUsers.js and app/store/AdminUsers.js in this case) and creates getter
            functions for them all. The example above will create a new User model instance and add it to the AllUsers Store.
            Of course, you could do anything in this function but in this case we just did something simple to demonstrate the
            functionality.
            *
            ## Further Reading
            *
            Controllers usually exist inside an {@link Ext.app.Application}.
            *
            @docauthor Ed Spencer
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.getActiveIndex">
            <summary>
            Returns the index of the currently active card.
            @return {Number} The index of the currently active card.
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.getCardIndexOffset(System.Object,System.Object,System.Object)">
            <summary>
            Returns the difference between the index of the active card and the passed card.
            @private
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.getCardOffset(System.Object,System.Object,System.Object)">
            <summary>
            Returns the amount of pixels from the current drag to a card.
            @private
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.isCardInRange(System.Object)">
            <summary>
            Returns true if the passed card is within 2 cards from the active card.
            @private
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.next">
            <summary>
            Switches to the next card
            @return {Ext.carousel.Carousel} this
            </summary>
        </member>
        <member name="M:Ext.carousel.Carousel.previous">
            <summary>
            Switches to the previous card
            @return {Ext.carousel.Carousel} this
            </summary>
        </member>
        <member name="P:Ext.carousel.Carousel.ActiveIndex">
            <summary>
            Returns the index of the currently active card.
            @return {Number} The index of the currently active card.
            </summary>
        </member>
        <member name="P:Ext.carousel.Carousel.extend">
            <summary>
            @class Ext.carousel.Carousel
            @extends Ext.Panel
            *
            Carousels, like [tabs](#!/guide/tabs), are a great way to allow the user to swipe through multiple full-screen pages.
            A Carousel shows only one of its pages at a time but allows you to swipe through with your finger.
            Carousels can be oriented either horizontally or vertically and are easy to configure - they just work like any other
            Container. Here's how to set up a simple horizontal Carousel:
            @example
            Ext.create('Ext.Carousel', {
            fullscreen: true,
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            html : 'Item 1',
            style: 'background-color: #5E99CC'
            },
            {
            html : 'Item 2',
            style: 'background-color: #759E60'
            },
            {
            html : 'Item 3'
            }
            ]
            });
            We can also make Carousels orient themselves vertically:
            *
            @example preview
            Ext.create('Ext.Carousel', {
            fullscreen: true,
            direction: 'vertical',
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            html : 'Item 1',
            style: 'background-color: #759E60'
            },
            {
            html : 'Item 2',
            style: 'background-color: #5E99CC'
            }
            ]
            });
            ### Common Configurations
            * {@link #ui} defines the style of the carousel
            * {@link #direction} defines the direction of the carousel
            * {@link #indicator} defines if the indicator show be shown
            *
            ### Useful Methods
            * {@link #next} moves to the next card
            * {@link #previous} moves to the previous card
            * {@link #setActiveItem} moves to the passed card
            *
            ## Further Reading
            For more information about Carousels see the [Carousel guide](#!/guide/carousel).
            </summary>
        </member>
        <member name="P:Ext.carousel.Carousel.xtype">
            <summary>
            @class Ext.carousel.Carousel
            @extends Ext.Panel
            *
            Carousels, like [tabs](#!/guide/tabs), are a great way to allow the user to swipe through multiple full-screen pages.
            A Carousel shows only one of its pages at a time but allows you to swipe through with your finger.
            Carousels can be oriented either horizontally or vertically and are easy to configure - they just work like any other
            Container. Here's how to set up a simple horizontal Carousel:
            @example
            Ext.create('Ext.Carousel', {
            fullscreen: true,
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            html : 'Item 1',
            style: 'background-color: #5E99CC'
            },
            {
            html : 'Item 2',
            style: 'background-color: #759E60'
            },
            {
            html : 'Item 3'
            }
            ]
            });
            We can also make Carousels orient themselves vertically:
            *
            @example preview
            Ext.create('Ext.Carousel', {
            fullscreen: true,
            direction: 'vertical',
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            html : 'Item 1',
            style: 'background-color: #759E60'
            },
            {
            html : 'Item 2',
            style: 'background-color: #5E99CC'
            }
            ]
            });
            ### Common Configurations
            * {@link #ui} defines the style of the carousel
            * {@link #direction} defines the direction of the carousel
            * {@link #indicator} defines if the indicator show be shown
            *
            ### Useful Methods
            * {@link #next} moves to the next card
            * {@link #previous} moves to the previous card
            * {@link #setActiveItem} moves to the passed card
            *
            ## Further Reading
            For more information about Carousels see the [Carousel guide](#!/guide/carousel).
            </summary>
        </member>
        <member name="P:Ext.carousel.CarouselConfig.baseCls">
            <summary>
            The base CSS class to apply to the Carousel's element
            @accessor
            </summary>
        </member>
        <member name="P:Ext.carousel.CarouselConfig.direction">
            <summary>
            The direction of the Carousel. Default is 'horizontal'. 'vertical' also available.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.carousel.CarouselConfig.indicator">
            <summary>
            Provides an indicator while toggling between child items to let the user
            know where they are in the card stack.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.carousel.CarouselConfig.itemCls">
            <summary>
            The CSS class to apply each card in the carousel
            @accessor
            </summary>
        </member>
        <member name="P:Ext.carousel.CarouselConfig.ui">
            <summary>
            Style options for Carousel. Default is 'dark'. 'light' is also available.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.carousel.Indicator.extend">
            <summary>
            A private utility class used by Ext.Carousel to create indicators.
            @private
            </summary>
        </member>
        <member name="P:Ext.carousel.Indicator.xtype">
            <summary>
            A private utility class used by Ext.Carousel to create indicators.
            @private
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.afterCommit(Ext.data.Model)">
            <summary>
            @private
            A model instance should call this method on the Store it has been {@link Ext.data.Model#join joined} to.
            @param {Ext.data.Model} record The model instance that was edited
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.afterEdit(Ext.data.Model,System.Object)">
            <summary>
            @private
            A model instance should call this method on the Store it has been {@link Ext.data.Model#join joined} to.
            @param {Ext.data.Model} record The model instance that was edited
            @param {String[]} modifiedFieldNames Array of field names changed during edit.
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.afterReject(Ext.data.Model)">
            <summary>
            @private
            A model instance should call this method on the Store it has been {@link Ext.data.Model#join joined} to..
            @param {Ext.data.Model} record The model instance that was edited
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.decodeFilters(System.Object)">
            <summary>
            @private
            Normalizes an array of filter objects, ensuring that they are all Ext.util.Filter instances
            @param {Object[]} filters The filters array
            @return {Ext.util.Filter[]} Array of Ext.util.Filter objects
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.filterNew(System.Object)">
            <summary>
            @private
            Filter function for new records.
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.filterUpdated(System.Object)">
            <summary>
            @private
            Filter function for updated records.
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.getBatchListeners">
            <summary>
            @private
            Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
            This is broken out into a separate function to allow for customisation of the listeners
            @return {Object} The listeners object
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.getNewRecords">
            <summary>
            Returns all Model instances that are either currently a phantom (e.g. have no id), or have an ID but have not
            yet been saved on this Store (this happens when adding a non-phantom record from another Store into this one)
            @return {Ext.data.Model[]} The Model instances
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.getProxy">
            <summary>
            Returns the proxy currently attached to this proxy instance
            @return {Ext.data.proxy.Proxy} The Proxy instance
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.getRemovedRecords">
            <summary>
            Returns any records that have been removed from the store but not yet destroyed on the proxy.
            @return {Ext.data.Model[]} The removed Model instances
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.getUpdatedRecords">
            <summary>
            Returns all Model instances that have been updated in the Store but not yet synchronized with the Proxy
            @return {Ext.data.Model[]} The updated Model instances
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.isLoading">
            <summary>
            Returns true if the Store is currently performing a load operation
            @return {Boolean} True if the Store is currently loading
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.load(System.Object)">
            <summary>
            Loads the Store using its configured {@link #proxy}.
            @param {Object} options (optional) config object. This is passed into the {@link Ext.data.Operation Operation}
            object that is created and then sent to the proxy's {@link Ext.data.proxy.Proxy#read} function
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.onBatchComplete(System.Object,System.Object)">
            <summary>
            @private
            Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
            and updates the Store's internal data MixedCollection.
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.onBatchOperationComplete(System.Object,System.Object)">
            <summary>
            @private
            Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
            to onProxyWrite.
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.onProxyWrite(System.Object)">
            <summary>
            @private
            Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
            the updates provided by the Proxy
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.setProxy(System.Object)">
            <summary>
            Sets the Store's Proxy by string, config object or Proxy instance
            @param {String/Object/Ext.data.proxy.Proxy} proxy The new Proxy, which can be either a type string, a configuration object
            or an Ext.data.proxy.Proxy instance
            @return {Ext.data.proxy.Proxy} The attached Proxy object
            </summary>
        </member>
        <member name="M:Ext.data.AbstractStore.sync">
            <summary>
            Synchronizes the Store with its Proxy. This asks the Proxy to batch together any new, updated
            and deleted records in the store, updating the Store's internal representation of the records
            as each operation completes.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.autoLoad">
            <summary>
            @cfg {Boolean/Object} autoLoad
            If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
            after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
            Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.autoSync">
            <summary>
            @cfg {Boolean} autoSync
            True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.BatchListeners">
            <summary>
            @private
            Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
            This is broken out into a separate function to allow for customisation of the listeners
            @return {Object} The listeners object
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.batchUpdateMode">
            <summary>
            @property {String} batchUpdateMode
            Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
            internal representation of the data after each operation of the batch has completed, 'complete' will wait until
            the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
            storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.defaultProxyType">
            <summary>
            @property {String} defaultProxyType
            The string type of the Proxy to create if none is specified. This defaults to creating a
            {@link Ext.data.proxy.Memory memory proxy}.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.filterOnLoad">
            <summary>
            @property {Boolean} filterOnLoad
            If true, any filters attached to this Store will be run after loading data, before the datachanged event is fired.
            Defaults to true, ignored if {@link Ext.data.Store#remoteFilter remoteFilter} is true
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.implicitModel">
            <summary>
            @property {Boolean} implicitModel
            True if a model was created implicitly for this Store. This happens if a fields array is passed to the Store's
            constructor instead of a model constructor or name.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.isDestroyed">
            <summary>
            @property {Boolean} isDestroyed
            True if the Store has already been destroyed. If this is true, the reference to Store should be deleted
            as it will not function correctly any more.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.isStore">
            <summary>
            @property {Boolean} isDestroyed
            True if the Store has already been destroyed. If this is true, the reference to Store should be deleted
            as it will not function correctly any more.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.Proxy">
            <summary>
            Sets the Store's Proxy by string, config object or Proxy instance
            @param {String/Object/Ext.data.proxy.Proxy} proxy The new Proxy, which can be either a type string, a configuration object
            or an Ext.data.proxy.Proxy instance
            @return {Ext.data.proxy.Proxy} The attached Proxy object
            Returns the proxy currently attached to this proxy instance
            @return {Ext.data.proxy.Proxy} The Proxy instance
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.sortOnLoad">
            <summary>
            @property {Boolean} sortOnLoad
            If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
            Defaults to true, igored if {@link Ext.data.Store#remoteSort remoteSort} is true
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStore.sortRoot">
            <summary>
            @cfg {String} model
            Name of the {@link Ext.data.Model Model} associated with this store.
            The string is used as an argument for {@link Ext.ModelManager#getModel}.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.autoLoad">
            <summary>
            If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
            after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
            Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.autoSync">
            <summary>
            True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.fields">
            <summary>
            This may be used in place of specifying a {@link #model} configuration. The fields should be a
            set of {@link Ext.data.Field} configuration objects. The store will automatically create a {@link Ext.data.Model}
            with these fields. In general this configuration option should be avoided, it exists for the purposes of
            backwards compatibility. For anything more complicated, such as specifying a particular id property or
            associations, a {@link Ext.data.Model} should be defined and specified for the {@link #model}
            config.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.model">
            <summary>
            Name of the {@link Ext.data.Model Model} associated with this store.
            The string is used as an argument for {@link Ext.ModelManager#getModel}.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.proxy">
            <summary>
            The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
            see {@link #setProxy} for details.
            </summary>
        </member>
        <member name="P:Ext.data.AbstractStoreConfig.storeId">
            <summary>
            Unique identifier for this store. If present, this Store will be registered with the {@link Ext.data.StoreManager},
            making it easy to reuse elsewhere. Defaults to undefined.
            </summary>
        </member>
        <member name="P:Ext.data.ArrayStore.alias">
            <summary>
            @author Ed Spencer
            *
            Small helper class to make creating {@link Ext.data.Store}s from Array data easier. An ArrayStore will be
            automatically configured with a {@link Ext.data.reader.Array}.
            *
            A store configuration would be something like:
            *
            var store = Ext.create('Ext.data.ArrayStore', {
            // store configs
            autoDestroy: true,
            storeId: 'myStore',
            // reader configs
            idIndex: 0,
            fields: [
            'company',
            {name: 'price', type: 'float'},
            {name: 'change', type: 'float'},
            {name: 'pctChange', type: 'float'},
            {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
            ]
            });
            *
            This store is configured to consume a returned object of the form:
            *
            var myData = [
            ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
            ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
            ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
            ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
            ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
            ];
            *
            An object literal of this form could also be used as the {@link #data} config option.
            *
            **Note:** Although not listed here, this class accepts all of the configuration options of
            **{@link Ext.data.reader.Array ArrayReader}**.
            </summary>
        </member>
        <member name="P:Ext.data.ArrayStore.extend">
            <summary>
            @author Ed Spencer
            *
            Small helper class to make creating {@link Ext.data.Store}s from Array data easier. An ArrayStore will be
            automatically configured with a {@link Ext.data.reader.Array}.
            *
            A store configuration would be something like:
            *
            var store = Ext.create('Ext.data.ArrayStore', {
            // store configs
            autoDestroy: true,
            storeId: 'myStore',
            // reader configs
            idIndex: 0,
            fields: [
            'company',
            {name: 'price', type: 'float'},
            {name: 'change', type: 'float'},
            {name: 'pctChange', type: 'float'},
            {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
            ]
            });
            *
            This store is configured to consume a returned object of the form:
            *
            var myData = [
            ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
            ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
            ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
            ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
            ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
            ];
            *
            An object literal of this form could also be used as the {@link #data} config option.
            *
            **Note:** Although not listed here, this class accepts all of the configuration options of
            **{@link Ext.data.reader.Array ArrayReader}**.
            </summary>
        </member>
        <member name="M:Ext.data.Batch.add(System.Object)">
            <summary>
            Adds a new operation to this batch
            @param {Object} operation The {@link Ext.data.Operation Operation} object
            </summary>
        </member>
        <member name="M:Ext.data.Batch.#ctor(System.Object)">
            <summary>
            Creates new Batch object.
            @param {Object} config (optional) Config object
            </summary>
        </member>
        <member name="M:Ext.data.Batch.pause">
            <summary>
            Pauses execution of the batch, but does not cancel the current operation
            </summary>
        </member>
        <member name="M:Ext.data.Batch.runNextOperation">
            <summary>
            @private
            Runs the next operation, relative to this.current.
            </summary>
        </member>
        <member name="M:Ext.data.Batch.runOperation(SharpKit.JavaScript.JsNumber)">
            <summary>
            Executes a operation by its numeric index
            @param {Number} index The operation index to run
            </summary>
        </member>
        <member name="M:Ext.data.Batch.start">
            <summary>
            Kicks off the execution of the batch, continuing from the next operation if the previous
            operation encountered an exception, or if execution was paused
            </summary>
        </member>
        <member name="P:Ext.data.Batch.autoStart">
            <summary>
            True to immediately start processing the batch as soon as it is constructed (defaults to false)
            @property autoStart
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.data.Batch.hasException">
            <summary>
            True if this batch has encountered an exception. This is cleared at the start of each operation
            @property hasException
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.data.Batch.isComplete">
            <summary>
            True if this batch has been executed completely
            @property isComplete
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.data.Batch.isRunning">
            <summary>
            True if the batch is currently running
            @property isRunning
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.data.Batch.pauseOnException">
            <summary>
            True to automatically pause the execution of the batch if any operation encounters an exception (defaults to true)
            @property pauseOnException
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.data.Batch.total">
            <summary>
            The total number of operations in this batch. Read only
            @property total
            @type Number
            </summary>
        </member>
        <member name="P:Ext.data.BufferStore.alias">
            <summary>
            @class Ext.data.BufferStore
            @extends Ext.data.Store
            @ignore
            </summary>
        </member>
        <member name="P:Ext.data.BufferStore.extend">
            <summary>
            @class Ext.data.BufferStore
            @extends Ext.data.Store
            @ignore
            </summary>
        </member>
        <member name="M:Ext.data.Connection.abort(System.Object)">
            <summary>
            Aborts any outstanding request.
            @param {Object} request (Optional) defaults to the last request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.cleanup(System.Object)">
            <summary>
            Cleans up any left over information from the request
            @private
            @param {Object} The request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.clearTimeout(System.Object)">
            <summary>
            Clears the timeout on the request
            @private
            @param {Object} The request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.createException(System.Object)">
            <summary>
            Creates the exception object
            @private
            @param {Object} request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.createResponse(System.Object)">
            <summary>
            Creates the response object
            @private
            @param {Object} request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.getForm(System.Object)">
            <summary>
            Gets the form object from options.
            @private
            @param {Object} options The request options
            @return {HTMLElement} The form, null if not passed
            </summary>
        </member>
        <member name="M:Ext.data.Connection.isFormUpload(System.Object)">
            <summary>
            Detects whether the form is intended to be used for an upload.
            @private
            </summary>
        </member>
        <member name="M:Ext.data.Connection.isLoading(System.Object)">
            <summary>
            Determines whether this object has a request outstanding.
            @param {Object} request (Optional) defaults to the last transaction
            @return {Boolean} True if there is an outstanding request.
            </summary>
        </member>
        <member name="M:Ext.data.Connection.onComplete(System.Object)">
            <summary>
            To be called when the request has come back from the server
            @private
            @param {Object} request
            @return {Object} The response
            </summary>
        </member>
        <member name="M:Ext.data.Connection.onStateChange(System.Object)">
            <summary>
            Fires when the state of the xhr changes
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.parseStatus(SharpKit.JavaScript.JsNumber)">
            <summary>
            Checks if the response status was successful
            @param {Number} status The status code
            @return {Object} An object containing success/status state
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.data.Connection.request(System.Object)" -->
        <member name="M:Ext.data.Connection.setOptions(System.Object,System.Object)">
            <summary>
            Sets various options such as the url, params for the request
            @param {Object} options The initial options
            @param {Object} scope The scope to execute in
            @return {Object} The params for the request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.setupHeaders(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Setup all the headers for the request
            @private
            @param {Object} xhr The xhr object
            @param {Object} options The options for the request
            @param {Object} data The data for the request
            @param {Object} params The params for the request
            </summary>
        </member>
        <member name="M:Ext.data.Connection.setupMethod(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Template method for overriding method
            @private
            @param {Object} options
            @param {String} method
            @return {String} The modified method
            </summary>
        </member>
        <member name="M:Ext.data.Connection.setupParams(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Template method for overriding params
            @private
            @param {Object} options
            @param {String} params
            @return {String} The modified params
            </summary>
        </member>
        <member name="M:Ext.data.Connection.setupUrl(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Template method for overriding url
            @private
            @param {Object} options
            @param {String} url
            @return {String} The modified url
            </summary>
        </member>
        <member name="M:Ext.data.Connection.upload(System.Object,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Uploads a form using a hidden iframe.
            @param {String/HTMLElement/Ext.Element} form The form to upload
            @param {String} url The url to post to
            @param {String} params Any extra parameters to pass
            @param {Object} options The initial options
            </summary>
        </member>
        <member name="P:Ext.data.Connection.defaultPostHeader">
            <summary>
            @cfg {Object} extraParams
            Any parameters to be appended to the request.
            </summary>
        </member>
        <member name="P:Ext.data.Connection.disableCaching">
            <summary>
            @cfg {Boolean} disableCaching
            True to add a unique cache-buster param to GET requests. (defaults to true)
            </summary>
        </member>
        <member name="P:Ext.data.Connection.disableCachingParam">
            <summary>
            @cfg {String} disableCachingParam
            Change the parameter which is sent went disabling caching through a cache buster. Defaults to '_dc'
            </summary>
        </member>
        <member name="P:Ext.data.Connection.timeout">
            <summary>
            @cfg {Number} timeout
            The timeout in milliseconds to be used for requests. (defaults to 30000)
            </summary>
        </member>
        <member name="P:Ext.data.Connection.useDefaultHeader">
            <summary>
            @cfg {Object} extraParams
            Any parameters to be appended to the request.
            </summary>
        </member>
        <member name="P:Ext.data.ConnectionConfig.disableCaching">
            <summary>
            True to add a unique cache-buster param to GET requests. (defaults to true)
            </summary>
        </member>
        <member name="P:Ext.data.ConnectionConfig.disableCachingParam">
            <summary>
            Change the parameter which is sent went disabling caching through a cache buster. Defaults to '_dc'
            </summary>
        </member>
        <member name="P:Ext.data.ConnectionConfig.timeout">
            <summary>
            The timeout in milliseconds to be used for requests. (defaults to 30000)
            </summary>
        </member>
        <member name="M:Ext.data.DirectStore.#ctor(System.Object)">
            <summary>
            End Definitions
            </summary>
        </member>
        <member name="P:Ext.data.DirectStore.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.data.Errors.getByField(SharpKit.JavaScript.JsString)">
            <summary>
            Returns all of the errors for the given field
            @param {String} fieldName The field to get errors for
            @return {Object[]} All errors for the given field
            </summary>
        </member>
        <member name="M:Ext.data.Errors.isValid">
            <summary>
            Returns true if there are no errors in the collection
            @return {Boolean}
            </summary>
        </member>
        <member name="P:Ext.data.Errors.extend">
            <summary>
            @author Ed Spencer
            @class Ext.data.Errors
            @extends Ext.util.MixedCollection
            *
            <p>Wraps a collection of validation error responses and provides convenient functions for
            accessing and errors for specific fields.</p>
            *
            <p>Usually this class does not need to be instantiated directly - instances are instead created
            automatically when {@link Ext.data.Model#validate validate} on a model instance:</p>
            *
            <pre><code>
            //validate some existing model instance - in this case it returned 2 failures messages
            var errors = myModel.validate();
            errors.isValid(); //false
            errors.length; //2
            errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
            errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.data.Field.alias">
            <summary>
            @extends Object
            @author Ed Spencer
            *
            Fields are used to define what a Model is. They aren't instantiated directly - instead, when we create a class that
            extends {@link Ext.data.Model}, it will automatically create a Field instance for each field configured in a {@link
            Ext.data.Model Model}. For example, we might set up a model like this:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            'name', 'email',
            {name: 'age', type: 'int'},
            {name: 'gender', type: 'string', defaultValue: 'Unknown'}
            ]
            });
            *
            Four fields will have been created for the User Model - name, email, age and gender. Note that we specified a couple
            of different formats here; if we only pass in the string name of the field (as with name and email), the field is set
            up with the 'auto' type. It's as if we'd done this instead:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'name', type: 'auto'},
            {name: 'email', type: 'auto'},
            {name: 'age', type: 'int'},
            {name: 'gender', type: 'string', defaultValue: 'Unknown'}
            ]
            });
            *
            # Types and conversion
            *
            The {@link #type} is important - it's used to automatically convert data passed to the field into the correct format.
            In our example above, the name and email fields used the 'auto' type and will just accept anything that is passed
            into them. The 'age' field had an 'int' type however, so if we passed 25.4 this would be rounded to 25.
            *
            Sometimes a simple type isn't enough, or we want to perform some processing when we load a Field's data. We can do
            this using a {@link #convert} function. Here, we're going to create a new field based on another:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            'name', 'email',
            {name: 'age', type: 'int'},
            {name: 'gender', type: 'string', defaultValue: 'Unknown'},
            *
            {
            name: 'firstName',
            convert: function(value, record) {
            var fullName  = record.get('name'),
            splits    = fullName.split(" "),
            firstName = splits[0];
            *
            return firstName;
            }
            }
            ]
            });
            *
            Now when we create a new User, the firstName is populated automatically based on the name:
            *
            var ed = Ext.create('User', {name: 'Ed Spencer'});
            *
            console.log(ed.get('firstName')); //logs 'Ed', based on our convert function
            *
            In fact, if we log out all of the data inside ed, we'll see this:
            *
            console.log(ed.data);
            *
            //outputs this:
            {
            age: 0,
            email: "",
            firstName: "Ed",
            gender: "Unknown",
            name: "Ed Spencer"
            }
            *
            The age field has been given a default of zero because we made it an int type. As an auto field, email has defaulted
            to an empty string. When we registered the User model we set gender's {@link #defaultValue} to 'Unknown' so we see
            that now. Let's correct that and satisfy ourselves that the types work as we expect:
            *
            ed.set('gender', 'Male');
            ed.get('gender'); //returns 'Male'
            *
            ed.set('age', 25.4);
            ed.get('age'); //returns 25 - we wanted an int, not a float, so no decimal places allowed
            </summary>
        </member>
        <member name="P:Ext.data.Field.allowBlank">
            <summary>
            @cfg {Boolean} allowBlank
            @private
            *
            Used for validating a {@link Ext.data.Model model}. Defaults to true. An empty value here will cause
            {@link Ext.data.Model}.{@link Ext.data.Model#isValid isValid} to evaluate to false.
            </summary>
        </member>
        <member name="P:Ext.data.Field.dateFormat">
            <summary>
            @cfg {String} dateFormat
            *
            Used when converting received data into a Date when the {@link #type} is specified as `"date"`.
            *
            A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
            the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
            timestamp. See {@link Ext.Date}.
            </summary>
        </member>
        <member name="P:Ext.data.Field.defaultValue">
            <summary>
            @cfg {Object} defaultValue
            *
            The default value used **when a Model is being created by a {@link Ext.data.reader.Reader Reader}**
            when the item referenced by the `{@link Ext.data.Field#mapping mapping}` does not exist in the data object
            (i.e. undefined). Defaults to "".
            </summary>
        </member>
        <member name="P:Ext.data.Field.mapping">
            <summary>
            @cfg {String/Number} mapping
            *
            (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
            {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
            as the field name, the mapping may be omitted.
            *
            The form of the mapping expression depends on the Reader being used.
            *
            - {@link Ext.data.reader.Json}
            *
            The mapping is a string containing the javascript expression to reference the data from an element of the data
            item's {@link Ext.data.reader.Json#root root} Array. Defaults to the field name.
            *
            - {@link Ext.data.reader.Xml}
            *
            The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
            {@link Ext.data.reader.Xml#record record}. Defaults to the field name.
            *
            - {@link Ext.data.reader.Array}
            *
            The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
            Array position.
            *
            If a more complex value extraction strategy is required, then configure the Field with a {@link #convert}
            function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
            return the desired data.
            </summary>
        </member>
        <member name="P:Ext.data.Field.persist">
            <summary>
            @cfg {Boolean} persist
            *
            False to exclude this field from the {@link Ext.data.Model#modified} fields in a model. This will also exclude
            the field from being written using a {@link Ext.data.writer.Writer}. This option is useful when model fields are
            used to keep state on the client but do not need to be persisted to the server. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.Field.sortDir">
            <summary>
            @cfg {String} sortDir
            *
            Initial direction to sort (`"ASC"` or `"DESC"`). Defaults to `"ASC"`.
            </summary>
        </member>
        <member name="P:Ext.data.Field.sortType">
            <summary>
            @cfg {Function} sortType
            *
            A function which converts a Field's value to a comparable value in order to ensure correct sort ordering.
            Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
            *
            // current sort     after sort we want
            // +-+------+          +-+------+
            // |1|First |          |1|First |
            // |2|Last  |          |3|Second|
            // |3|Second|          |2|Last  |
            // +-+------+          +-+------+
            *
            sortType: function(value) {
            switch (value.toLowerCase()) // native toLowerCase():
            {
            case 'first': return 1;
            case 'second': return 2;
            default: return 3;
            }
            }
            </summary>
        </member>
        <member name="P:Ext.data.Field.useNull">
            <summary>
            @cfg {Boolean} useNull
            *
            Use when converting received data into a Number type (either int or float). If the value cannot be
            parsed, null will be used if useNull is true, otherwise the value will be 0. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.allowBlank">
            <summary>
            @private
            *
            Used for validating a {@link Ext.data.Model model}. Defaults to true. An empty value here will cause
            {@link Ext.data.Model}.{@link Ext.data.Model#isValid isValid} to evaluate to false.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.convert">
            <summary>
            *
            A function which converts the value provided by the Reader into an object that will be stored in the Model.
            It is passed the following parameters:
            *
            - **v** : Mixed
            *
            The data value as read by the Reader, if undefined will use the configured `{@link Ext.data.Field#defaultValue
            defaultValue}`.
            *
            - **rec** : Ext.data.Model
            *
            The data object containing the Model as read so far by the Reader. Note that the Model may not be fully populated
            at this point as the fields are read in the order that they are defined in your
            {@link Ext.data.Model#fields fields} array.
            *
            Example of convert functions:
            *
            function fullName(v, record){
            return record.name.last + ', ' + record.name.first;
            }
            *
            function location(v, record){
            return !record.city ? '' : (record.city + ', ' + record.state);
            }
            *
            Ext.define('Dude', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'fullname',  convert: fullName},
            {name: 'firstname', mapping: 'name.first'},
            {name: 'lastname',  mapping: 'name.last'},
            {name: 'city', defaultValue: 'homeless'},
            'state',
            {name: 'location',  convert: location}
            ]
            });
            *
            // create the data store
            var store = Ext.create('Ext.data.Store', {
            reader: {
            type: 'json',
            model: 'Dude',
            idProperty: 'key',
            root: 'daRoot',
            totalProperty: 'total'
            }
            });
            *
            var myData = [
            { key: 1,
            name: { first: 'Fat',    last:  'Albert' }
            // notice no city, state provided in data object
            },
            { key: 2,
            name: { first: 'Barney', last:  'Rubble' },
            city: 'Bedrock', state: 'Stoneridge'
            },
            { key: 3,
            name: { first: 'Cliff',  last:  'Claven' },
            city: 'Boston',  state: 'MA'
            }
            ];
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.dateFormat">
            <summary>
            *
            Used when converting received data into a Date when the {@link #type} is specified as `"date"`.
            *
            A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
            the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
            timestamp. See {@link Ext.Date}.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.defaultValue">
            <summary>
            *
            The default value used **when a Model is being created by a {@link Ext.data.reader.Reader Reader}**
            when the item referenced by the `{@link Ext.data.Field#mapping mapping}` does not exist in the data object
            (i.e. undefined). Defaults to "".
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.mapping">
            <summary>
            *
            (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
            {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
            as the field name, the mapping may be omitted.
            *
            The form of the mapping expression depends on the Reader being used.
            *
            - {@link Ext.data.reader.Json}
            *
            The mapping is a string containing the javascript expression to reference the data from an element of the data
            item's {@link Ext.data.reader.Json#root root} Array. Defaults to the field name.
            *
            - {@link Ext.data.reader.Xml}
            *
            The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
            {@link Ext.data.reader.Xml#record record}. Defaults to the field name.
            *
            - {@link Ext.data.reader.Array}
            *
            The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
            Array position.
            *
            If a more complex value extraction strategy is required, then configure the Field with a {@link #convert}
            function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
            return the desired data.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.name">
            <summary>
            *
            The name by which the field is referenced within the Model. This is referenced by, for example, the `dataIndex`
            property in column definition objects passed to Ext.grid.property.HeaderContainer.
            *
            Note: In the simplest case, if no properties other than `name` are required, a field definition may consist of
            just a String for the field name.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.persist">
            <summary>
            *
            False to exclude this field from the {@link Ext.data.Model#modified} fields in a model. This will also exclude
            the field from being written using a {@link Ext.data.writer.Writer}. This option is useful when model fields are
            used to keep state on the client but do not need to be persisted to the server. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.sortDir">
            <summary>
            *
            Initial direction to sort (`"ASC"` or `"DESC"`). Defaults to `"ASC"`.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.sortType">
            <summary>
            *
            A function which converts a Field's value to a comparable value in order to ensure correct sort ordering.
            Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
            *
            // current sort     after sort we want
            // +-+------+          +-+------+
            // |1|First |          |1|First |
            // |2|Last  |          |3|Second|
            // |3|Second|          |2|Last  |
            // +-+------+          +-+------+
            *
            sortType: function(value) {
            switch (value.toLowerCase()) // native toLowerCase():
            {
            case 'first': return 1;
            case 'second': return 2;
            default: return 3;
            }
            }
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.type">
            <summary>
            *
            The data type for automatic conversion from received data to the *stored* value if
            `{@link Ext.data.Field#convert convert}` has not been specified. This may be specified as a string value.
            Possible values are
            *
            - auto (Default, implies no conversion)
            - string
            - int
            - float
            - boolean
            - date
            *
            This may also be specified by referencing a member of the {@link Ext.data.Types} class.
            *
            Developers may create their own application-specific data types by defining new members of the {@link
            Ext.data.Types} class.
            </summary>
        </member>
        <member name="P:Ext.data.FieldConfig.useNull">
            <summary>
            *
            Use when converting received data into a Number type (either int or float). If the value cannot be
            parsed, null will be used if useNull is true, otherwise the value will be 0. Defaults to false.
            </summary>
        </member>
        <member name="M:Ext.data.IdGenerator.#ctor(System.Object)">
            <summary>
            Initializes a new instance.
            @param {Object} config (optional) Configuration object to be applied to the new instance.
            </summary>
        </member>
        <member name="M:Ext.data.IdGenerator.getRecId(System.Object)">
            <summary>
            @cfg {String} id
            The id by which to register a new instance. This instance can be found using the
            {@link Ext.data.IdGenerator#get} static method.
            </summary>
        </member>
        <member name="P:Ext.data.IdGenerator.isGenerator">
            <summary>
            @author Don Griffin
            *
            This class is a base for all id generators. It also provides lookup of id generators by
            their id.
            Generally, id generators are used to generate a primary key for new model instances. There
            are different approaches to solving this problem, so this mechanism has both simple use
            cases and is open to custom implementations. A {@link Ext.data.Model} requests id generation
            using the {@link Ext.data.Model#idgen} property.
            *
            # Identity, Type and Shared IdGenerators
            *
            It is often desirable to share IdGenerators to ensure uniqueness or common configuration.
            This is done by giving IdGenerator instances an id property by which they can be looked
            up using the {@link #get} method. To configure two {@link Ext.data.Model Model} classes
            to share one {@link Ext.data.SequentialIdGenerator sequential} id generator, you simply
            assign them the same id:
            *
            Ext.define('MyApp.data.MyModelA', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            id: 'foo'
            }
            });
            *
            Ext.define('MyApp.data.MyModelB', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            id: 'foo'
            }
            });
            *
            To make this as simple as possible for generator types that are shared by many (or all)
            Models, the IdGenerator types (such as 'sequential' or 'uuid') are also reserved as
            generator id's. This is used by the {@link Ext.data.UuidGenerator} which has an id equal
            to its type ('uuid'). In other words, the following Models share the same generator:
            *
            Ext.define('MyApp.data.MyModelX', {
            extend: 'Ext.data.Model',
            idgen: 'uuid'
            });
            *
            Ext.define('MyApp.data.MyModelY', {
            extend: 'Ext.data.Model',
            idgen: 'uuid'
            });
            *
            This can be overridden (by specifying the id explicitly), but there is no particularly
            good reason to do so for this generator type.
            *
            # Creating Custom Generators
            An id generator should derive from this class and implement the {@link #generate} method.
            The constructor will apply config properties on new instances, so a constructor is often
            not necessary.
            *
            To register an id generator type, a derived class should provide an `alias` like so:
            *
            Ext.define('MyApp.data.CustomIdGenerator', {
            extend: 'Ext.data.IdGenerator',
            alias: 'idgen.custom',
            *
            configProp: 42, // some config property w/default value
            *
            generate: function () {
            return ... // a new id
            }
            });
            *
            Using the custom id generator is then straightforward:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: 'custom'
            });
            // or...
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'custom',
            configProp: value
            }
            });
            *
            It is not recommended to mix shared generators with generator configuration. This leads
            to unpredictable results unless all configurations match (which is also redundant). In
            such cases, a custom generator with a default id is the best approach.
            *
            Ext.define('MyApp.data.CustomIdGenerator', {
            extend: 'Ext.data.SequentialIdGenerator',
            alias: 'idgen.custom',
            *
            id: 'custom', // shared by default
            *
            prefix: 'ID_',
            seed: 1000
            });
            *
            Ext.define('MyApp.data.MyModelX', {
            extend: 'Ext.data.Model',
            idgen: 'custom'
            });
            *
            Ext.define('MyApp.data.MyModelY', {
            extend: 'Ext.data.Model',
            idgen: 'custom'
            });
            *
            // the above models share a generator that produces ID_1000, ID_1001, etc..
            *
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.abort(System.Object)">
            <summary>
            Abort a request. If the request parameter is not specified all open requests will
            be aborted.
            @param {Object/String} request (Optional) The request to abort
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.cleanupErrorHandling(System.Object)">
            <summary>
            Cleans up anu script handling errors
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.createScript(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Create the script tag
            @private
            @param {String} url The url of the request
            @param {Object} params Any extra params to be sent
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.handleAbort(System.Object)">
            <summary>
            Handles any aborts when loading the script
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.handleError(System.Object)">
            <summary>
            Handles any script errors when loading the script
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.handleResponse(System.Object,System.Object)">
            <summary>
            Handle a successful response
            @private
            @param {Object} result The result from the request
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.handleTimeout(System.Object)">
            <summary>
            Handle any script timeouts
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.request(System.Object)">
            <summary>
            Makes a JSONP request.
            @param {Object} options An object which may contain the following properties. Note that options will
            take priority over any defaults that are specified in the class.
            <ul>
            <li><b>url</b> : String <div class="sub-desc">The URL to request.</div></li>
            <li><b>params</b> : Object (Optional)<div class="sub-desc">An object containing a series of
            key value pairs that will be sent along with the request.</div></li>
            <li><b>timeout</b> : Number (Optional) <div class="sub-desc">See {@link #timeout}</div></li>
            <li><b>callbackKey</b> : String (Optional) <div class="sub-desc">See {@link #callbackKey}</div></li>
            <li><b>callbackName</b> : String (Optional) <div class="sub-desc">The function name to use for this request.
            By default this name will be auto-generated: Ext.data.JsonP.callback1, Ext.data.JsonP.callback2, etc.
            Setting this option to "my_name" will force the function name to be Ext.data.JsonP.my_name.
            Use this if you want deterministic behavior, but be careful - the callbackName should be different
            in each JsonP request that you make.</div></li>
            <li><b>disableCaching</b> : Boolean (Optional) <div class="sub-desc">See {@link #disableCaching}</div></li>
            <li><b>disableCachingParam</b> : String (Optional) <div class="sub-desc">See {@link #disableCachingParam}</div></li>
            <li><b>success</b> : Function (Optional) <div class="sub-desc">A function to execute if the request succeeds.</div></li>
            <li><b>failure</b> : Function (Optional) <div class="sub-desc">A function to execute if the request fails.</div></li>
            <li><b>callback</b> : Function (Optional) <div class="sub-desc">A function to execute when the request
            completes, whether it is a success or failure.</div></li>
            <li><b>scope</b> : Object (Optional)<div class="sub-desc">The scope in
            which to execute the callbacks: The "this" object for the callback function. Defaults to the browser window.</div></li>
            </ul>
            @return {Object} request An object containing the request details.
            </summary>
        </member>
        <member name="M:Ext.data.JsonP.setupErrorHandling(System.Object)">
            <summary>
            Sets up error handling for the script
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.callbackKey">
            <summary>
            @property callbackKey
            @type String
            Specifies the GET parameter that will be sent to the server containing the function name to be executed when
            the request completes. Defaults to <tt>callback</tt>. Thus, a common request will be in the form of
            url?callback=Ext.data.JsonP.callback1
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.disableCaching">
            <summary>
            @property disableCaching
            @type Boolean
            True to add a unique cache-buster param to requests. Defaults to <tt>true</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.disableCachingParam">
            <summary>
            @property disableCachingParam
            @type String
            Change the parameter which is sent went disabling caching through a cache buster. Defaults to <tt>'_dc'</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.singleton">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.timeout">
            <summary>
            @property timeout
            @type Number
            A default timeout for any JsonP requests. If the request has not completed in this time the
            failure callback will be fired. The timeout is in ms. Defaults to <tt>30000</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.JsonP.upErrorHandling">
            <summary>
            Sets up error handling for the script
            @private
            @param {Object} request The request
            </summary>
        </member>
        <member name="M:Ext.data.JsonPStore.#ctor(System.Object)">
            <summary>
            @cfg {Ext.data.DataReader} reader @hide
            </summary>
        </member>
        <member name="P:Ext.data.JsonPStore.alias">
            <summary>
            @class Ext.data.JsonPStore
            @extends Ext.data.Store
            @ignore
            @private
            <p><b>NOTE:</b> This class is in need of migration to the new API.</p>
            <p>Small helper class to make creating {@link Ext.data.Store}s from different domain JSON data easier.
            A JsonPStore will be automatically configured with a {@link Ext.data.reader.Json} and a {@link Ext.data.proxy.JsonP JsonPProxy}.</p>
            <p>A store configuration would be something like:<pre><code>
            var store = new Ext.data.JsonPStore({
            // store configs
            autoDestroy: true,
            storeId: 'myStore',
            // proxy configs
            url: 'get-images.php',
            // reader configs
            root: 'images',
            idProperty: 'name',
            fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
            });
            </code></pre></p>
            <p>This store is configured to consume a returned object of the form:<pre><code>
            stcCallback({
            images: [
            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
            ]
            })
            </code></pre>
            <p>Where stcCallback is the callback name passed in the request to the remote domain. See {@link Ext.data.proxy.JsonP JsonPProxy}
            for details of how this works.</p>
            An object literal of this form could also be used as the {@link #data} config option.</p>
            <p><b>*Note:</b> Although not listed here, this class accepts all of the configuration options of
            <b>{@link Ext.data.reader.Json JsonReader}</b> and <b>{@link Ext.data.proxy.JsonP JsonPProxy}</b>.</p>
            @xtype jsonpstore
            </summary>
        </member>
        <member name="P:Ext.data.JsonPStore.extend">
            <summary>
            @class Ext.data.JsonPStore
            @extends Ext.data.Store
            @ignore
            @private
            <p><b>NOTE:</b> This class is in need of migration to the new API.</p>
            <p>Small helper class to make creating {@link Ext.data.Store}s from different domain JSON data easier.
            A JsonPStore will be automatically configured with a {@link Ext.data.reader.Json} and a {@link Ext.data.proxy.JsonP JsonPProxy}.</p>
            <p>A store configuration would be something like:<pre><code>
            var store = new Ext.data.JsonPStore({
            // store configs
            autoDestroy: true,
            storeId: 'myStore',
            // proxy configs
            url: 'get-images.php',
            // reader configs
            root: 'images',
            idProperty: 'name',
            fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
            });
            </code></pre></p>
            <p>This store is configured to consume a returned object of the form:<pre><code>
            stcCallback({
            images: [
            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
            ]
            })
            </code></pre>
            <p>Where stcCallback is the callback name passed in the request to the remote domain. See {@link Ext.data.proxy.JsonP JsonPProxy}
            for details of how this works.</p>
            An object literal of this form could also be used as the {@link #data} config option.</p>
            <p><b>*Note:</b> Although not listed here, this class accepts all of the configuration options of
            <b>{@link Ext.data.reader.Json JsonReader}</b> and <b>{@link Ext.data.proxy.JsonP JsonPProxy}</b>.</p>
            @xtype jsonpstore
            </summary>
        </member>
        <member name="M:Ext.data.JsonStore.#ctor(System.Object)">
            <summary>
            @cfg {Ext.data.DataReader} reader @hide
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.JsonStore.alias" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.data.JsonStore.extend" -->
        <member name="M:Ext.data.Model.afterCommit">
            <summary>
            @private
            If this Model instance has been {@link #join joined} to a {@link Ext.data.Store store}, the store's
            afterCommit method is called
            </summary>
        </member>
        <member name="M:Ext.data.Model.afterEdit(System.Object)">
            <summary>
            @private
            If this Model instance has been {@link #join joined} to a {@link Ext.data.Store store}, the store's
            afterEdit method is called
            @param {String[]} modifiedFieldNames Array of field names changed during edit.
            </summary>
        </member>
        <member name="M:Ext.data.Model.afterReject">
            <summary>
            @private
            If this Model instance has been {@link #join joined} to a {@link Ext.data.Store store}, the store's
            afterReject method is called
            </summary>
        </member>
        <member name="M:Ext.data.Model.beginEdit">
            <summary>
            Begins an edit. While in edit mode, no events (e.g.. the `update` event) are relayed to the containing store.
            When an edit has begun, it must be followed by either {@link #endEdit} or {@link #cancelEdit}.
            </summary>
        </member>
        <member name="M:Ext.data.Model.callStore(SharpKit.JavaScript.JsString)">
            <summary>
            @private
            Helper function used by afterEdit, afterReject and afterCommit. Calls the given method on the
            {@link Ext.data.Store store} that this instance has {@link #join joined}, if any. The store function
            will always be called with the model instance as its single argument.
            @param {String} fn The function to call on the store
            </summary>
        </member>
        <member name="M:Ext.data.Model.cancelEdit">
            <summary>
            Cancels all changes made in the current edit operation.
            </summary>
        </member>
        <member name="M:Ext.data.Model.commit(System.Boolean)">
            <summary>
            Usually called by the {@link Ext.data.Store} which owns the model instance. Commits all changes made to the
            instance since either creation or the last commit operation.
            *
            Developers should subscribe to the {@link Ext.data.Store#update} event to have their code notified of commit
            operations.
            *
            @param {Boolean} silent (optional) True to skip notification of the owning store of the change.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Ext.data.Model.#ctor(System.Object,System.Object,System.Object)">
            <summary>
            @cfg {String/Object/Ext.data.proxy.Proxy} proxy
            The {@link Ext.data.proxy.Proxy proxy} to use for this model.
            </summary>
        </member>
        <member name="M:Ext.data.Model.copy(SharpKit.JavaScript.JsString)">
            <summary>
            Creates a copy (clone) of this Model instance.
            *
            @param {String} id (optional) A new id, defaults to the id of the instance being copied.
            See `{@link Ext.data.Model#id id}`. To generate a phantom instance with a new id use:
            *
            var rec = record.copy(); // clone the record
            Ext.data.Model.id(rec); // automatically generate a unique sequential id
            *
            @return {Ext.data.Model}
            </summary>
        </member>
        <member name="M:Ext.data.Model.destroy(System.Object)">
            <summary>
            Destroys the model using the configured proxy.
            @param {Object} options Options to pass to the proxy. Config object for {@link Ext.data.Operation}.
            @return {Ext.data.Model} The Model instance
            </summary>
        </member>
        <member name="M:Ext.data.Model.endEdit(System.Boolean,System.Object)">
            <summary>
            Ends an edit. If any data was modified, the containing store is notified (ie, the store's `update` event will
            fire).
            @param {Boolean} silent True to not notify the store of the change
            @param {String[]} modifiedFieldNames Array of field names changed during edit.
            </summary>
        </member>
        <member name="M:Ext.data.Model.get(SharpKit.JavaScript.JsString)">
            <summary>
            Returns the value of the given field
            @param {String} fieldName The field to fetch the value for
            @return {Object} The value
            </summary>
        </member>
        <member name="M:Ext.data.Model.getAssociatedData">
            <summary>
            Gets all of the data from this Models *loaded* associations. It does this recursively - for example if we have a
            User which hasMany Orders, and each Order hasMany OrderItems, it will return an object like this:
            *
            {
            orders: [
            {
            id: 123,
            status: 'shipped',
            orderItems: [
            ...
            ]
            }
            ]
            }
            *
            @return {Object} The nested data set for the Model's loaded associations
            </summary>
        </member>
        <member name="M:Ext.data.Model.getChanges">
            <summary>
            Gets a hash of only the fields that have been modified since this Model was created or commited.
            @return {Object}
            </summary>
        </member>
        <member name="M:Ext.data.Model.getData(System.Boolean)">
            <summary>
            Gets all values for each field in this model and returns an object
            containing the current data.
            @param {Boolean} includeAssociated True to also include associated data. Defaults to false.
            @return {Object} An object hash containing all the values in this model
            </summary>
        </member>
        <member name="M:Ext.data.Model.getId">
            <summary>
            Returns the unique ID allocated to this model instance as defined by {@link #idProperty}.
            @return {Number} The id
            </summary>
        </member>
        <member name="M:Ext.data.Model.getProxy">
            <summary>
            Returns the configured Proxy for this Model.
            @return {Ext.data.proxy.Proxy} The proxy
            </summary>
        </member>
        <member name="M:Ext.data.Model.isEqual(System.Object,System.Object)">
            <summary>
            Checks if two values are equal, taking into account certain
            special factors, for example dates.
            @private
            @param {Object} a The first value
            @param {Object} b The second value
            @return {Boolean} True if the values are equal
            </summary>
        </member>
        <member name="M:Ext.data.Model.isModified(SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the passed field name has been `{@link #modified}` since the load or last commit.
            @param {String} fieldName {@link Ext.data.Field#name}
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.data.Model.isValid">
            <summary>
            Checks if the model is valid. See {@link #validate}.
            @return {Boolean} True if the model is valid.
            </summary>
        </member>
        <member name="M:Ext.data.Model.join(Ext.data.Store)">
            <summary>
            Tells this model instance that it has been added to a store.
            @param {Ext.data.Store} store The store to which this model has been added.
            </summary>
        </member>
        <member name="M:Ext.data.Model.prepareAssociatedData(Ext.data.Model,System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            @private
            This complex-looking method takes a given Model instance and returns an object containing all data from
            all of that Model's *loaded* associations. See {@link #getAssociatedData}
            @param {Ext.data.Model} record The Model instance
            @param {String[]} ids PRIVATE. The set of Model instance internalIds that have already been loaded
            @param {String} associationType (optional) The name of the type of association to limit to.
            @return {Object} The nested data set for the Model's loaded associations
            </summary>
        </member>
        <member name="M:Ext.data.Model.reject(System.Boolean)">
            <summary>
            Usually called by the {@link Ext.data.Store} to which this model instance has been {@link #join joined}. Rejects
            all changes made to the model instance since either creation, or the last commit operation. Modified fields are
            reverted to their original values.
            *
            Developers should subscribe to the {@link Ext.data.Store#update} event to have their code notified of reject
            operations.
            *
            @param {Boolean} silent (optional) True to skip notification of the owning store of the change.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Ext.data.Model.save(System.Object)">
            <summary>
            Saves the model instance using the configured proxy.
            @param {Object} options Options to pass to the proxy. Config object for {@link Ext.data.Operation}.
            @return {Ext.data.Model} The Model instance
            </summary>
        </member>
        <member name="M:Ext.data.Model.set(System.Object,System.Object)">
            <summary>
            Sets the given field to the given value, marks the instance as dirty
            @param {String/Object} fieldName The field to set, or an object containing key/value pairs
            @param {Object} value The value to set
            </summary>
        </member>
        <member name="M:Ext.data.Model.setDirty">
            <summary>
            Marks this **Record** as `{@link #dirty}`. This method is used interally when adding `{@link #phantom}` records
            to a {@link Ext.data.proxy.Server#writer writer enabled store}.
            *
            Marking a record `{@link #dirty}` causes the phantom to be returned by {@link Ext.data.Store#getUpdatedRecords}
            where it will have a create action composed for it during {@link Ext.data.Model#save model save} operations.
            </summary>
        </member>
        <member name="M:Ext.data.Model.setId(SharpKit.JavaScript.JsNumber)">
            <summary>
            Sets the model instance's id field to the given id.
            @param {Number} id The new id
            </summary>
        </member>
        <member name="M:Ext.data.Model.setProxy(System.Object)">
            <summary>
            Sets the Proxy to use for this model. Accepts any options that can be accepted by
            {@link Ext#createByAlias Ext.createByAlias}.
            *
            @param {String/Object/Ext.data.proxy.Proxy} proxy The proxy
            @return {Ext.data.proxy.Proxy}
            </summary>
        </member>
        <member name="M:Ext.data.Model.unjoin(Ext.data.Store)">
            <summary>
            Tells this model instance that it has been removed from the store.
            @param {Ext.data.Store} store The store from which this model has been removed.
            </summary>
        </member>
        <member name="M:Ext.data.Model.validate">
            <summary>
            Validates the current data against all of its configured {@link #validations}.
            @return {Ext.data.Errors} The errors object
            </summary>
        </member>
        <member name="P:Ext.data.Model.alternateClassName">
            <summary>
            @author Ed Spencer
            *
            A Model represents some object that your application manages. For example, one might define a Model for Users,
            Products, Cars, or any other real-world object that we want to model in the system. Models are registered via the
            {@link Ext.ModelManager model manager}, and are used by {@link Ext.data.Store stores}, which are in turn used by many
            of the data-bound components in Ext.
            *
            Models are defined as a set of fields and any arbitrary methods and properties relevant to the model. For example:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'name',  type: 'string'},
            {name: 'age',   type: 'int'},
            {name: 'phone', type: 'string'},
            {name: 'alive', type: 'boolean', defaultValue: true}
            ],
            *
            changeName: function() {
            var oldName = this.get('name'),
            newName = oldName + " The Barbarian";
            *
            this.set('name', newName);
            }
            });
            *
            The fields array is turned into a {@link Ext.util.MixedCollection MixedCollection} automatically by the {@link
            Ext.ModelManager ModelManager}, and all other functions and properties are copied to the new Model's prototype.
            *
            Now we can create instances of our User model and call any model logic we defined:
            *
            var user = Ext.create('User', {
            name : 'Conan',
            age  : 24,
            phone: '555-555-5555'
            });
            *
            user.changeName();
            user.get('name'); //returns "Conan The Barbarian"
            *
            # Validations
            *
            Models have built-in support for validations, which are executed against the validator functions in {@link
            Ext.data.validations} ({@link Ext.data.validations see all validation functions}). Validations are easy to add to
            models:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'name',     type: 'string'},
            {name: 'age',      type: 'int'},
            {name: 'phone',    type: 'string'},
            {name: 'gender',   type: 'string'},
            {name: 'username', type: 'string'},
            {name: 'alive',    type: 'boolean', defaultValue: true}
            ],
            *
            validations: [
            {type: 'presence',  field: 'age'},
            {type: 'length',    field: 'name',     min: 2},
            {type: 'inclusion', field: 'gender',   list: ['Male', 'Female']},
            {type: 'exclusion', field: 'username', list: ['Admin', 'Operator']},
            {type: 'format',    field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}
            ]
            });
            *
            The validations can be run by simply calling the {@link #validate} function, which returns a {@link Ext.data.Errors}
            object:
            *
            var instance = Ext.create('User', {
            name: 'Ed',
            gender: 'Male',
            username: 'edspencer'
            });
            *
            var errors = instance.validate();
            *
            # Associations
            *
            Models can have associations with other Models via {@link Ext.data.association.HasOne},
            {@link Ext.data.association.BelongsTo belongsTo} and {@link Ext.data.association.HasMany hasMany} associations.
            For example, let's say we're writing a blog administration application which deals with Users, Posts and Comments.
            We can express the relationships between these models like this:
            *
            Ext.define('Post', {
            extend: 'Ext.data.Model',
            fields: ['id', 'user_id'],
            *
            belongsTo: 'User',
            hasMany  : {model: 'Comment', name: 'comments'}
            });
            *
            Ext.define('Comment', {
            extend: 'Ext.data.Model',
            fields: ['id', 'user_id', 'post_id'],
            *
            belongsTo: 'Post'
            });
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id'],
            *
            hasMany: [
            'Post',
            {model: 'Comment', name: 'comments'}
            ]
            });
            *
            See the docs for {@link Ext.data.association.HasOne}, {@link Ext.data.association.BelongsTo} and
            {@link Ext.data.association.HasMany} for details on the usage and configuration of associations.
            Note that associations can also be specified like this:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id'],
            *
            associations: [
            {type: 'hasMany', model: 'Post',    name: 'posts'},
            {type: 'hasMany', model: 'Comment', name: 'comments'}
            ]
            });
            *
            # Using a Proxy
            *
            Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
            save that data somewhere. All loading and saving of data is handled via a {@link Ext.data.proxy.Proxy Proxy}, which
            can be set directly on the Model:
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'email'],
            *
            proxy: {
            type: 'rest',
            url : '/users'
            }
            });
            *
            Here we've set up a {@link Ext.data.proxy.Rest Rest Proxy}, which knows how to load and save data to and from a
            RESTful backend. Let's see how this works:
            *
            var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
            *
            user.save(); //POST /users
            *
            Calling {@link #save} on the new Model instance tells the configured RestProxy that we wish to persist this Model's
            data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
            and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
            configure any Proxy on any Model and always follow this API - see {@link Ext.data.proxy.Proxy} for a full list.
            *
            Loading data via the Proxy is equally easy:
            *
            //get a reference to the User model class
            var User = Ext.ModelManager.getModel('User');
            *
            //Uses the configured RestProxy to make a GET request to /users/123
            User.load(123, {
            success: function(user) {
            console.log(user.getId()); //logs 123
            }
            });
            *
            Models can also be updated and destroyed easily:
            *
            //the user Model we loaded in the last snippet:
            user.set('name', 'Edward Spencer');
            *
            //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
            user.save({
            success: function() {
            console.log('The User was updated');
            }
            });
            *
            //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
            user.destroy({
            success: function() {
            console.log('The User was destroyed!');
            }
            });
            *
            # Usage in Stores
            *
            It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
            creating a {@link Ext.data.Store Store}:
            *
            var store = Ext.create('Ext.data.Store', {
            model: 'User'
            });
            *
            //uses the Proxy we set up on Model to load the Store data
            store.load();
            *
            A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
            set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the {@link
            Ext.data.Store Store docs} for more information on Stores.
            *
            @constructor
            Creates new Model instance.
            @param {Object} data An object containing keys corresponding to this model's fields, and their associated values
            @param {Number} id (optional) Unique ID to assign to this model instance
            </summary>
        </member>
        <member name="P:Ext.data.Model.AssociatedData">
            <summary>
            Gets all of the data from this Models *loaded* associations. It does this recursively - for example if we have a
            User which hasMany Orders, and each Order hasMany OrderItems, it will return an object like this:
            *
            {
            orders: [
            {
            id: 123,
            status: 'shipped',
            orderItems: [
            ...
            ]
            }
            ]
            }
            *
            @return {Object} The nested data set for the Model's loaded associations
            </summary>
        </member>
        <member name="P:Ext.data.Model.defaultProxyType">
            <summary>
            @cfg {String} defaultProxyType
            The string type of the default Model Proxy. Defaults to 'ajax'.
            </summary>
        </member>
        <member name="P:Ext.data.Model.dirty">
            <summary>
            @property {Boolean} dirty
            True if this Record has been modified. Read-only.
            </summary>
        </member>
        <member name="P:Ext.data.Model.editing">
            <summary>
            @property {Boolean} editing
            Internal flag used to track whether or not the model instance is currently being edited. Read-only.
            </summary>
        </member>
        <member name="P:Ext.data.Model.evented">
            <summary>
            @cfg {String} persistenceProperty
            The property on this Persistable object that its data is saved to. Defaults to 'data'
            (e.g. all persistable data resides in this.data.)
            </summary>
        </member>
        <member name="P:Ext.data.Model.Id">
            <summary>
            Returns the unique ID allocated to this model instance as defined by {@link #idProperty}.
            @return {Number} The id
            Sets the model instance's id field to the given id.
            @param {Number} id The new id
            </summary>
        </member>
        <member name="P:Ext.data.Model.idProperty">
            <summary>
            @cfg {String} idProperty
            The name of the field treated as this Model's unique id. Defaults to 'id'.
            </summary>
        </member>
        <member name="P:Ext.data.Model.persistenceProperty">
            <summary>
            @cfg {String} persistenceProperty
            The property on this Persistable object that its data is saved to. Defaults to 'data'
            (e.g. all persistable data resides in this.data.)
            </summary>
        </member>
        <member name="P:Ext.data.Model.phantom">
            <summary>
            @property {Boolean} phantom
            True when the record does not yet exist in a server-side database (see {@link #setDirty}).
            Any record which has a real database pk set as its id property is NOT a phantom -- it's real.
            </summary>
        </member>
        <member name="P:Ext.data.Model.Proxy">
            <summary>
            Sets the Proxy to use for this model. Accepts any options that can be accepted by
            {@link Ext#createByAlias Ext.createByAlias}.
            *
            @param {String/Object/Ext.data.proxy.Proxy} proxy The proxy
            @return {Ext.data.proxy.Proxy}
            Returns the configured Proxy for this Model.
            @return {Ext.data.proxy.Proxy} The proxy
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.associations">
            <summary>
            An array of {@link Ext.data.Association associations} for this model.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.belongsTo">
            <summary>
            One or more {@link Ext.data.BelongsToAssociation BelongsTo associations} for this model.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.defaultProxyType">
            <summary>
            The string type of the default Model Proxy. Defaults to 'ajax'.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.fields">
            <summary>
            The fields for this model.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.hasMany">
            <summary>
            One or more {@link Ext.data.HasManyAssociation HasMany associations} for this model.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.idgen">
            <summary>
            The id generator to use for this model. The default id generator does not generate
            values for the {@link #idProperty}.
            *
            This can be overridden at the model level to provide a custom generator for a model.
            The simplest form of this would be:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            requires: ['Ext.data.SequentialIdGenerator'],
            idgen: 'sequential',
            ...
            });
            *
            The above would generate {@link Ext.data.SequentialIdGenerator sequential} id's such
            as 1, 2, 3 etc..
            *
            Another useful id generator is {@link Ext.data.UuidGenerator}:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            requires: ['Ext.data.UuidGenerator'],
            idgen: 'uuid',
            ...
            });
            *
            An id generation can also be further configured:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            seed: 1000,
            prefix: 'ID_'
            }
            });
            *
            The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
            *
            If multiple models share an id space, a single generator can be shared:
            *
            Ext.define('MyApp.data.MyModelX', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            id: 'xy'
            }
            });
            *
            Ext.define('MyApp.data.MyModelY', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            id: 'xy'
            }
            });
            *
            For more complex, shared id generators, a custom generator is the best approach.
            See {@link Ext.data.IdGenerator} for details on creating custom id generators.
            *
            @markdown
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.idProperty">
            <summary>
            The name of the field treated as this Model's unique id. Defaults to 'id'.
            </summary>
        </member>
        <member name="P:Ext.data.ModelConfig.validations">
            <summary>
            An array of {@link Ext.data.validations validations} for this model.
            </summary>
        </member>
        <member name="M:Ext.data.NodeStore.#ctor(System.Object)">
            <summary>
            @cfg {Boolean} rootVisible <tt>false</tt> to not include the root node in this Stores collection (defaults to <tt>true</tt>)
            </summary>
        </member>
        <member name="P:Ext.data.NodeStore.alias">
            <summary>
            @class Ext.data.NodeStore
            @extends Ext.data.AbstractStore
            Node Store
            @ignore
            </summary>
        </member>
        <member name="P:Ext.data.NodeStore.extend">
            <summary>
            @class Ext.data.NodeStore
            @extends Ext.data.AbstractStore
            Node Store
            @ignore
            </summary>
        </member>
        <member name="P:Ext.data.NodeStore.node">
            <summary>
            @cfg {Ext.data.Model} node The Record you want to bind this Store to. Note that
            this record will be decorated with the Ext.data.NodeInterface if this is not the
            case yet.
            </summary>
        </member>
        <member name="P:Ext.data.NodeStore.recursive">
            <summary>
            @cfg {Boolean} recursive Set this to true if you want this NodeStore to represent
            all the descendents of the node in its flat data collection. This is useful for
            rendering a tree structure to a DataView and is being used internally by
            the TreeView. Any records that are moved, removed, inserted or appended to the
            node at any depth below the node this store is bound to will be automatically
            updated in this Store's internal flat data structure.
            </summary>
        </member>
        <member name="P:Ext.data.NodeStore.rootVisible">
            <summary>
            @cfg {Boolean} rootVisible <tt>false</tt> to not include the root node in this Stores collection (defaults to <tt>true</tt>)
            </summary>
        </member>
        <member name="P:Ext.data.NodeStoreConfig.node">
            <summary>
            The Record you want to bind this Store to. Note that
            this record will be decorated with the Ext.data.NodeInterface if this is not the
            case yet.
            </summary>
        </member>
        <member name="P:Ext.data.NodeStoreConfig.recursive">
            <summary>
            Set this to true if you want this NodeStore to represent
            all the descendents of the node in its flat data collection. This is useful for
            rendering a tree structure to a DataView and is being used internally by
            the TreeView. Any records that are moved, removed, inserted or appended to the
            node at any depth below the node this store is bound to will be automatically
            updated in this Store's internal flat data structure.
            </summary>
        </member>
        <member name="P:Ext.data.NodeStoreConfig.rootVisible">
            <summary>
            <tt>false</tt> to not include the root node in this Stores collection (defaults to <tt>true</tt>)
            </summary>
        </member>
        <member name="M:Ext.data.Operation.allowWrite">
            <summary>
            Checks whether this operation should cause writing to occur.
            @return {Boolean} Whether the operation should cause a write to occur.
            </summary>
        </member>
        <member name="M:Ext.data.Operation.commitRecords(System.Object)">
            <summary>
            This method is called to commit data to this instance's records given the records in
            the server response. This is followed by calling {@link Ext.data.Model#commit} on all
            those records (for 'create' and 'update' actions).
            *
            If this {@link #action} is 'destroy', any server records are ignored and the
            {@link Ext.data.Model#commit} method is not called.
            *
            @param {Ext.data.Model[]} serverRecords An array of {@link Ext.data.Model} objects returned by
            the server.
            @markdown
            </summary>
        </member>
        <member name="M:Ext.data.Operation.#ctor(System.Object)">
            <summary>
            Creates new Operation object.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.Operation.getError">
            <summary>
            Returns the error string or object that was set using {@link #setException}
            @return {String/Object} The error object
            </summary>
        </member>
        <member name="M:Ext.data.Operation.getRecords">
            <summary>
            Returns an array of Ext.data.Model instances as set by the Proxy.
            @return {Ext.data.Model[]} Any loaded Records
            </summary>
        </member>
        <member name="M:Ext.data.Operation.getResultSet">
            <summary>
            Returns the ResultSet object (if set by the Proxy). This object will contain the {@link Ext.data.Model model}
            instances as well as meta data such as number of instances fetched, number available etc
            @return {Ext.data.ResultSet} The ResultSet object
            </summary>
        </member>
        <member name="M:Ext.data.Operation.hasException">
            <summary>
            Returns true if this Operation encountered an exception (see also {@link #getError})
            @return {Boolean} True if there was an exception
            </summary>
        </member>
        <member name="M:Ext.data.Operation.isComplete">
            <summary>
            Returns true if the Operation has been completed
            @return {Boolean} True if the Operation is complete
            </summary>
        </member>
        <member name="M:Ext.data.Operation.isRunning">
            <summary>
            Returns true if the Operation has been started but has not yet completed.
            @return {Boolean} True if the Operation is currently running
            </summary>
        </member>
        <member name="M:Ext.data.Operation.isStarted">
            <summary>
            Returns true if the Operation has been started. Note that the Operation may have started AND completed, see
            {@link #isRunning} to test if the Operation is currently running.
            @return {Boolean} True if the Operation has started
            </summary>
        </member>
        <member name="M:Ext.data.Operation.setBatch(Ext.data.Batch)">
            <summary>
            @private
            Associates this Operation with a Batch
            @param {Ext.data.Batch} batch The batch
            </summary>
        </member>
        <member name="M:Ext.data.Operation.setCompleted">
            <summary>
            Marks the Operation as completed.
            </summary>
        </member>
        <member name="M:Ext.data.Operation.setException(System.Object)">
            <summary>
            Marks the Operation as having experienced an exception. Can be supplied with an option error message/object.
            @param {String/Object} error (optional) error string/object
            </summary>
        </member>
        <member name="M:Ext.data.Operation.setStarted">
            <summary>
            Marks the Operation as started.
            </summary>
        </member>
        <member name="M:Ext.data.Operation.setSuccessful">
            <summary>
            Marks the Operation as successful.
            </summary>
        </member>
        <member name="M:Ext.data.Operation.wasSuccessful">
            <summary>
            Returns true if the Operation has completed and was successful
            @return {Boolean} True if successful
            </summary>
        </member>
        <member name="P:Ext.data.Operation.actionCommitRecordsRe">
            <summary>
            @property {RegExp} actionCommitRecordsRe
            The RegExp used to categorize actions that require_ record commits. This defaults to
            match 'create' and 'update'.
            </summary>
        </member>
        <member name="P:Ext.data.Operation.actionSkipSyncRe">
            <summary>
            @property {RegExp} actionSkipSyncRe
            The RegExp used to categorize actions that skip local record synchronization. This defaults
            to match 'destroy'.
            </summary>
        </member>
        <member name="P:Ext.data.Operation.Batch">
            <summary>
            @private
            Associates this Operation with a Batch
            @param {Ext.data.Batch} batch The batch
            </summary>
        </member>
        <member name="P:Ext.data.Operation.complete">
            <summary>
            @property {Boolean} complete
            Read-only property tracking the completion status of this Operation. Use {@link #isComplete}.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.Operation.Error">
            <summary>
            Returns the error string or object that was set using {@link #setException}
            @return {String/Object} The error object
            </summary>
        </member>
        <member name="P:Ext.data.Operation.exception">
            <summary>
            @property {Boolean} exception
            Read-only property tracking the exception status of this Operation. Use {@link #hasException} and see {@link #getError}.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.Operation.Exception">
            <summary>
            Marks the Operation as having experienced an exception. Can be supplied with an option error message/object.
            @param {String/Object} error (optional) error string/object
            </summary>
        </member>
        <member name="P:Ext.data.Operation.ResultSet">
            <summary>
            Returns the ResultSet object (if set by the Proxy). This object will contain the {@link Ext.data.Model model}
            instances as well as meta data such as number of instances fetched, number available etc
            @return {Ext.data.ResultSet} The ResultSet object
            </summary>
        </member>
        <member name="P:Ext.data.Operation.running">
            <summary>
            @property {Boolean} running
            Read-only property tracking the run status of this Operation. Use {@link #isRunning}.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.Operation.started">
            <summary>
            @property {Boolean} started
            Read-only property tracking the start status of this Operation. Use {@link #isStarted}.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.Operation.synchronous">
            <summary>
            @cfg {Boolean} synchronous
            True if this Operation is to be executed synchronously (defaults to true). This property is inspected by a
            {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.action">
            <summary>
            The action being performed by this Operation. Should be one of 'create', 'read', 'update' or 'destroy'.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.batch">
            <summary>
            The batch that this Operation is a part of.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.callback">
            <summary>
            Function to execute when operation completed.  Will be called with the following parameters:
            *
            - records : Array of Ext.data.Model objects.
            - operation : The Ext.data.Operation itself.
            - success : True when operation completed successfully.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.filters">
            <summary>
            Optional array of filter objects. Only applies to 'read' actions.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.group">
            <summary>
            Optional grouping configuration. Only applies to 'read' actions where grouping is desired.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.limit">
            <summary>
            The number of records to load. Used on 'read' actions when paging is being used.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.scope">
            <summary>
            Scope for the {@link #callback} function.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.sorters">
            <summary>
            Optional array of sorter objects. Only applies to 'read' actions.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.start">
            <summary>
            The start index (offset), used in paging when running a 'read' action.
            </summary>
        </member>
        <member name="P:Ext.data.OperationConfig.synchronous">
            <summary>
            True if this Operation is to be executed synchronously (defaults to true). This property is inspected by a
            {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
            </summary>
        </member>
        <member name="M:Ext.data.Request.#ctor(System.Object)">
            <summary>
            Creates the Request object.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="P:Ext.data.Request.method">
            <summary>
            @cfg {String} method The HTTP method to use on this Request (defaults to 'GET'). Should be one of 'GET', 'POST', 'PUT' or 'DELETE'
            </summary>
        </member>
        <member name="P:Ext.data.RequestConfig.action">
            <summary>
            The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'
            </summary>
        </member>
        <member name="P:Ext.data.RequestConfig.method">
            <summary>
            The HTTP method to use on this Request (defaults to 'GET'). Should be one of 'GET', 'POST', 'PUT' or 'DELETE'
            </summary>
        </member>
        <member name="P:Ext.data.RequestConfig.params">
            <summary>
            HTTP request params. The Proxy and its Writer have access to and can modify this object.
            </summary>
        </member>
        <member name="P:Ext.data.RequestConfig.url">
            <summary>
            The url to access on this Request
            </summary>
        </member>
        <member name="M:Ext.data.ResultSet.#ctor(System.Object)">
            <summary>
            Creates the resultSet
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="P:Ext.data.ResultSet.count">
            <summary>
            @cfg {Number} count
            The number of records in this ResultSet. Note that total may differ from this number
            </summary>
        </member>
        <member name="P:Ext.data.ResultSet.loaded">
            <summary>
            @cfg {Boolean} loaded
            True if the records have already been loaded. This is only meaningful when dealing with
            SQL-backed proxies
            </summary>
        </member>
        <member name="P:Ext.data.ResultSet.success">
            <summary>
            @cfg {Boolean} success
            True if the ResultSet loaded successfully, false if any errors were encountered
            </summary>
        </member>
        <member name="P:Ext.data.ResultSet.total">
            <summary>
            @cfg {Number} total
            The total number of records reported by the data source. This ResultSet may form a subset of
            those records (see count)
            </summary>
        </member>
        <member name="P:Ext.data.ResultSetConfig.count">
            <summary>
            The number of records in this ResultSet. Note that total may differ from this number
            </summary>
        </member>
        <member name="P:Ext.data.ResultSetConfig.loaded">
            <summary>
            True if the records have already been loaded. This is only meaningful when dealing with
            SQL-backed proxies
            </summary>
        </member>
        <member name="P:Ext.data.ResultSetConfig.records">
            <summary>
            The array of record instances. Required
            </summary>
        </member>
        <member name="P:Ext.data.ResultSetConfig.success">
            <summary>
            True if the ResultSet loaded successfully, false if any errors were encountered
            </summary>
        </member>
        <member name="P:Ext.data.ResultSetConfig.total">
            <summary>
            The total number of records reported by the data source. This ResultSet may form a subset of
            those records (see count)
            </summary>
        </member>
        <member name="M:Ext.data.SequentialIdGenerator.generate">
            <summary>
            Generates and returns the next id.
            @return {String} The next id.
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGenerator.alias">
            <summary>
            @author Don Griffin
            *
            This class is a sequential id generator. A simple use of this class would be like so:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: 'sequential'
            });
            // assign id's of 1, 2, 3, etc.
            *
            An example of a configured generator would be:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            prefix: 'ID_',
            seed: 1000
            }
            });
            // assign id's of ID_1000, ID_1001, ID_1002, etc.
            *
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGenerator.extend">
            <summary>
            @author Don Griffin
            *
            This class is a sequential id generator. A simple use of this class would be like so:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: 'sequential'
            });
            // assign id's of 1, 2, 3, etc.
            *
            An example of a configured generator would be:
            *
            Ext.define('MyApp.data.MyModel', {
            extend: 'Ext.data.Model',
            idgen: {
            type: 'sequential',
            prefix: 'ID_',
            seed: 1000
            }
            });
            // assign id's of ID_1000, ID_1001, ID_1002, etc.
            *
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGenerator.prefix">
            <summary>
            @cfg {String} prefix
            The string to place in front of the sequential number for each generated id. The
            default is blank.
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGenerator.seed">
            <summary>
            @cfg {Number} seed
            The number at which to start generating sequential id's. The default is 1.
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGeneratorConfig.prefix">
            <summary>
            The string to place in front of the sequential number for each generated id. The
            default is blank.
            </summary>
        </member>
        <member name="P:Ext.data.SequentialIdGeneratorConfig.seed">
            <summary>
            The number at which to start generating sequential id's. The default is 1.
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asDate(System.Object)">
            <summary>
            Date sorting
            @param {Object} s The value being converted
            @return {Number} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asFloat(System.Object)">
            <summary>
            Float sorting
            @param {Object} s The value being converted
            @return {Number} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asInt(System.Object)">
            <summary>
            Integer sorting
            @param {Object} s The value being converted
            @return {Number} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asText(System.Object)">
            <summary>
            Strips all HTML tags to sort on text only
            @param {Object} s The value being converted
            @return {String} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asUCString(System.Object)">
            <summary>
            Case insensitive string
            @param {Object} s The value being converted
            @return {String} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.asUCText(System.Object)">
            <summary>
            Strips all HTML tags to sort on text only - Case insensitive
            @param {Object} s The value being converted
            @return {String} The comparison value
            </summary>
        </member>
        <member name="M:Ext.data.SortTypes.none(System.Object)">
            <summary>
            Default sort that does nothing
            @param {Object} s The value being converted
            @return {Object} The comparison value
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.SortTypes.singleton" -->
        <member name="P:Ext.data.SortTypes.stripTagsRE">
            <summary>
            The regular expression used to strip tags
            @type {RegExp}
            @property
            </summary>
        </member>
        <member name="M:Ext.data.Store.add(System.Object)">
            <summary>
            Adds Model instance to the Store. This method accepts either:
            *
            - An array of Model instances or Model configuration objects.
            - Any number of Model instance or Model configuration object arguments.
            *
            The new Model instances will be added at the end of the existing collection.
            *
            Sample usage:
            *
            myStore.add({some: 'data'}, {some: 'other data'});
            *
            @param {Ext.data.Model[]/Ext.data.Model...} model An array of Model instances
            or Model configuration objects, or variable number of Model instance or config arguments.
            @return {Ext.data.Model[]} The model instances that were added
            </summary>
        </member>
        <member name="M:Ext.data.Store.aggregate(SharpKit.JavaScript.JsAction,System.Object,System.Boolean,SharpKit.JavaScript.JsArray)">
            <summary>
            Runs the aggregate function for all the records in the store.
            @param {Function} fn The function to execute. The function is called with a single parameter,
            an array of records for that group.
            @param {Object} scope (optional) The scope to execute the function in. Defaults to the store.
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the group average being the value. The grouped parameter is only honored if
            the store has a groupField.
            @param {Array} args (optional) Any arguments to append to the function call
            @return {Object} An object literal with the group names and their appropriate values.
            </summary>
        </member>
        <member name="M:Ext.data.Store.average(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Gets the average value in the store.
            @param {String} field The field in each record
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the group average being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Object} The average value, if no items exist, 0.
            </summary>
        </member>
        <member name="M:Ext.data.Store.cacheRecords(System.Object,Ext.data.Operation)">
            <summary>
            Caches the records in the prefetch and stripes them with their server-side
            index.
            @private
            @param {Ext.data.Model[]} records The records to cache
            @param {Ext.data.Operation} The associated operation
            </summary>
        </member>
        <member name="M:Ext.data.Store.clearFilter(System.Boolean)">
            <summary>
            Revert to a view of the Record cache with no filtering applied.
            @param {Boolean} suppressEvent If <tt>true</tt> the filter is cleared silently without firing the
            {@link #datachanged} event.
            </summary>
        </member>
        <member name="M:Ext.data.Store.clearGrouping">
            <summary>
            Clear any groupers in the store
            </summary>
        </member>
        <member name="M:Ext.data.Store.collect(SharpKit.JavaScript.JsString,System.Boolean,System.Boolean)">
            <summary>
            Collects unique values for a particular dataIndex from this store.
            @param {String} dataIndex The property to collect
            @param {Boolean} allowNull (optional) Pass true to allow null, undefined or empty string values
            @param {Boolean} bypassFilter (optional) Pass true to collect from all records, even ones which are filtered
            @return {Object[]} An array of the unique values
            </summary>
        </member>
        <member name="M:Ext.data.Store.#ctor(System.Object)">
            <summary>
            Creates the store.
            @param {Object} config (optional) Config object
            </summary>
        </member>
        <member name="M:Ext.data.Store.count(System.Boolean)">
            <summary>
            Gets the count of items in the store.
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the count for each group being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Number} the count
            </summary>
        </member>
        <member name="M:Ext.data.Store.createFilterFn(SharpKit.JavaScript.JsString,System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            @private
            Returns a filter function used to test a the given property's value. Defers most of the work to
            Ext.util.MixedCollection's createValueMatcher function
            @param {String} property The property to create the filter function for
            @param {String/RegExp} value The string/regex to compare the property value to
            @param {Boolean} anyMatch True if we don't care if the filter value is not the full value (defaults to false)
            @param {Boolean} caseSensitive True to create a case-sensitive regex (defaults to false)
            @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false.
            Ignored if anyMatch is true.
            </summary>
        </member>
        <member name="M:Ext.data.Store.createModel(System.Object)">
            <summary>
            Converts a literal to a model, if it's not a model already
            @private
            @param record {Ext.data.Model/Object} The record to create
            @return {Ext.data.Model}
            </summary>
        </member>
        <member name="M:Ext.data.Store.decodeGroupers(System.Object)">
            <summary>
            @private
            Normalizes an array of grouper objects, ensuring that they are all Ext.util.Grouper instances
            @param {Object[]} groupers The groupers array
            @return {Ext.util.Grouper[]} Array of Ext.util.Grouper objects
            </summary>
        </member>
        <member name="M:Ext.data.Store.each(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Calls the specified function for each of the {@link Ext.data.Model Records} in the cache.
            @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
            Returning <tt>false</tt> aborts and exits the iteration.
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed.
            Defaults to the current {@link Ext.data.Model Record} in the iteration.
            </summary>
        </member>
        <member name="M:Ext.data.Store.filter(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Filters the loaded set of records by a given set of filters.
            *
            Filtering by single field:
            *
            store.filter("email", /\.com$/);
            *
            Using multiple filters:
            *
            store.filter([
            {property: "email", value: /\.com$/},
            {filterFn: function(item) { return item.get("age") > 10; }}
            ]);
            *
            Using Ext.util.Filter instances instead of config objects
            (note that we need to specify the {@link Ext.util.Filter#root root} config option in this case):
            *
            store.filter([
            Ext.create('Ext.util.Filter', {property: "email", value: /\.com$/, root: 'data'}),
            Ext.create('Ext.util.Filter', {filterFn: function(item) { return item.get("age") > 10; }, root: 'data'})
            ]);
            *
            @param {Object[]/Ext.util.Filter[]/String} filters The set of filters to apply to the data. These are stored internally on the store,
            but the filtering itself is done on the Store's {@link Ext.util.MixedCollection MixedCollection}. See
            MixedCollection's {@link Ext.util.MixedCollection#filter filter} method for filter syntax. Alternatively,
            pass in a property string
            @param {String} value (optional) value to filter by (only if using a property string as the first argument)
            </summary>
        </member>
        <member name="M:Ext.data.Store.filterBy(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Filter by a function. The specified function will be called for each
            Record in this Store. If the function returns <tt>true</tt> the Record is included,
            otherwise it is filtered out.
            @param {Function} fn The function to be called. It will be passed the following parameters:<ul>
            <li><b>record</b> : Ext.data.Model<p class="sub-desc">The {@link Ext.data.Model record}
            to test for filtering. Access field values using {@link Ext.data.Model#get}.</p></li>
            <li><b>id</b> : Object<p class="sub-desc">The ID of the Record passed.</p></li>
            </ul>
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to this Store.
            </summary>
        </member>
        <member name="M:Ext.data.Store.find(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsNumber,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Finds the index of the first matching Record in this store by a specific field value.
            @param {String} fieldName The name of the Record field to test.
            @param {String/RegExp} value Either a string that the field value
            should begin with, or a RegExp to test against the field.
            @param {Number} startIndex (optional) The index to start searching at
            @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
            @param {Boolean} caseSensitive (optional) True for case sensitive comparison
            @param {Boolean} exactMatch (optional) True to force exact match (^ and $ characters added to the regex). Defaults to false.
            @return {Number} The matched index or -1
            </summary>
        </member>
        <member name="M:Ext.data.Store.findBy(SharpKit.JavaScript.JsAction,System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            Find the index of the first matching Record in this Store by a function.
            If the function returns <tt>true</tt> it is considered a match.
            @param {Function} fn The function to be called. It will be passed the following parameters:<ul>
            <li><b>record</b> : Ext.data.Model<p class="sub-desc">The {@link Ext.data.Model record}
            to test for filtering. Access field values using {@link Ext.data.Model#get}.</p></li>
            <li><b>id</b> : Object<p class="sub-desc">The ID of the Record passed.</p></li>
            </ul>
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to this Store.
            @param {Number} startIndex (optional) The index to start searching at
            @return {Number} The matched index or -1
            </summary>
        </member>
        <member name="M:Ext.data.Store.findExact(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            Finds the index of the first matching Record in this store by a specific field value.
            @param {String} fieldName The name of the Record field to test.
            @param {Object} value The value to match the field against.
            @param {Number} startIndex (optional) The index to start searching at
            @return {Number} The matched index or -1
            </summary>
        </member>
        <member name="M:Ext.data.Store.findRecord">
            <summary>
            Finds the first matching Record in this store by a specific field value.
            @param {String} fieldName The name of the Record field to test.
            @param {String/RegExp} value Either a string that the field value
            should begin with, or a RegExp to test against the field.
            @param {Number} startIndex (optional) The index to start searching at
            @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
            @param {Boolean} caseSensitive (optional) True for case sensitive comparison
            @param {Boolean} exactMatch (optional) True to force exact match (^ and $ characters added to the regex). Defaults to false.
            @return {Ext.data.Model} The matched record or null
            </summary>
        </member>
        <member name="M:Ext.data.Store.fireGroupChange">
            <summary>
            Fires the groupchange event. Abstracted out so we can use it
            as a callback
            @private
            </summary>
        </member>
        <member name="M:Ext.data.Store.first(System.Boolean)">
            <summary>
            Convenience function for getting the first model instance in the store
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the first record being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Ext.data.Model/undefined} The first model instance in the store, or undefined
            </summary>
        </member>
        <member name="M:Ext.data.Store.getAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Get the Record at the specified index.
            @param {Number} index The index of the Record to find.
            @return {Ext.data.Model} The Record at the passed index. Returns undefined if not found.
            </summary>
        </member>
        <member name="M:Ext.data.Store.getById(SharpKit.JavaScript.JsString)">
            <summary>
            Get the Record with the specified id.
            @param {String} id The id of the Record to find.
            @return {Ext.data.Model} The Record with the passed id. Returns undefined if not found.
            </summary>
        </member>
        <member name="M:Ext.data.Store.getCount">
            <summary>
            Gets the number of cached records.
            <p>If using paging, this may not be the total size of the dataset. If the data object
            used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
            the dataset size.  <b>Note</b>: see the Important note in {@link #load}.</p>
            @return {Number} The number of Records in the Store's cache.
            </summary>
        </member>
        <member name="M:Ext.data.Store.getGroupData(System.Boolean)">
            <summary>
            @private
            <p>Returns records grouped by the configured {@link #groupers grouper} configuration. Sample return value (in
            this case grouping by genre and then author in a fictional books dataset):</p>
            <pre><code>
            [
            {
            name: 'Fantasy',
            depth: 0,
            records: [
            //book1, book2, book3, book4
            ],
            children: [
            {
            name: 'Rowling',
            depth: 1,
            records: [
            //book1, book2
            ]
            },
            {
            name: 'Tolkein',
            depth: 1,
            records: [
            //book3, book4
            ]
            }
            ]
            }
            ]
            </code></pre>
            @param {Boolean} sort True to call {@link #sort} before finding groups. Sorting is required to make grouping
            function correctly so this should only be set to false if the Store is known to already be sorted correctly
            (defaults to true)
            @return {Object[]} The group data
            </summary>
        </member>
        <member name="M:Ext.data.Store.getGroups(SharpKit.JavaScript.JsString)">
            <summary>
            Returns an array containing the result of applying grouping to the records in this store. See {@link #groupField},
            {@link #groupDir} and {@link #getGroupString}. Example for a store containing records with a color field:
            <pre><code>
            var myStore = Ext.create('Ext.data.Store', {
            groupField: 'color',
            groupDir  : 'DESC'
            });
            myStore.getGroups(); //returns:
            [
            {
            name: 'yellow',
            children: [
            //all records where the color field is 'yellow'
            ]
            },
            {
            name: 'red',
            children: [
            //all records where the color field is 'red'
            ]
            }
            ]
            </code></pre>
            @param {String} groupName (Optional) Pass in an optional groupName argument to access a specific group as defined by {@link #getGroupString}
            @return {Object/Object[]} The grouped data
            </summary>
        </member>
        <member name="M:Ext.data.Store.getGroupsForGrouper(System.Object,System.Object)">
            <summary>
            @private
            For a given set of records and a Grouper, returns an array of arrays - each of which is the set of records
            matching a certain group.
            </summary>
        </member>
        <member name="M:Ext.data.Store.getGroupsForGrouperIndex(System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            @private
            This is used recursively to gather the records into the configured Groupers. The data MUST have been sorted for
            this to work properly (see {@link #getGroupData} and {@link #getGroupsForGrouper}) Most of the work is done by
            {@link #getGroupsForGrouper} - this function largely just handles the recursion.
            @param {Ext.data.Model[]} records The set or subset of records to group
            @param {Number} grouperIndex The grouper index to retrieve
            @return {Object[]} The grouped records
            </summary>
        </member>
        <member name="M:Ext.data.Store.getGroupString(Ext.data.Model)">
            <summary>
            <p>Returns the string to group on for a given model instance. The default implementation of this method returns
            the model's {@link #groupField}, but this can be overridden to group by an arbitrary string. For example, to
            group by the first letter of a model's 'name' field, use the following code:</p>
            <pre><code>
            Ext.create('Ext.data.Store', {
            groupDir: 'ASC',
            getGroupString: function(instance) {
            return instance.get('name')[0];
            }
            });
            </code></pre>
            @param {Ext.data.Model} instance The model instance
            @return {String} The string to compare when forming groups
            </summary>
        </member>
        <member name="M:Ext.data.Store.getPageFromRecordIndex(SharpKit.JavaScript.JsNumber)">
            <summary>
            Determines the page from a record index
            @param {Number} index The record index
            @return {Number} The page the record belongs to
            </summary>
        </member>
        <member name="M:Ext.data.Store.getRange(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns a range of Records between specified indices.
            @param {Number} startIndex (optional) The starting index (defaults to 0)
            @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store)
            @return {Ext.data.Model[]} An array of Records
            </summary>
        </member>
        <member name="M:Ext.data.Store.getRequestId">
            <summary>
            Returns a unique requestId to track requests.
            @private
            </summary>
        </member>
        <member name="M:Ext.data.Store.getTotalCount">
            <summary>
            Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.proxy.Proxy Proxy}
            indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the
            number of records loaded into the Store at the moment, getTotalCount returns the number of records that
            could be loaded into the Store if the Store contained all data
            @return {Number} The total number of Model instances available via the Proxy
            </summary>
        </member>
        <member name="M:Ext.data.Store.group(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Group data in the store
            @param {String/Object[]} groupers Either a string name of one of the fields in this Store's configured {@link Ext.data.Model Model},
            or an Array of grouper configurations.
            @param {String} direction The overall direction to group the data by. Defaults to "ASC".
            </summary>
        </member>
        <member name="M:Ext.data.Store.guaranteeRange(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Guarantee a specific range, this will load the store with a range (that
            must be the pageSize or smaller) and take care of any loading that may
            be necessary.
            </summary>
        </member>
        <member name="M:Ext.data.Store.hasPendingRequests">
            <summary>
            Returns the number of pending requests out.
            </summary>
        </member>
        <member name="M:Ext.data.Store.indexOf(Ext.data.Model)">
            <summary>
            Get the index within the cache of the passed Record.
            @param {Ext.data.Model} record The Ext.data.Model object to find.
            @return {Number} The index of the passed Record. Returns -1 if not found.
            </summary>
        </member>
        <member name="M:Ext.data.Store.indexOfId(SharpKit.JavaScript.JsString)">
            <summary>
            Get the index within the cache of the Record with the passed id.
            @param {String} id The id of the Record to find.
            @return {Number} The index of the Record. Returns -1 if not found.
            </summary>
        </member>
        <member name="M:Ext.data.Store.indexOfTotal(Ext.data.Model)">
            <summary>
            Get the index within the entire dataset. From 0 to the totalCount.
            @param {Ext.data.Model} record The Ext.data.Model object to find.
            @return {Number} The index of the passed Record. Returns -1 if not found.
            </summary>
        </member>
        <member name="M:Ext.data.Store.insert(SharpKit.JavaScript.JsNumber,System.Object)">
            <summary>
            Inserts Model instances into the Store at the given index and fires the {@link #add} event.
            See also <code>{@link #add}</code>.
            @param {Number} index The start index at which to insert the passed Records.
            @param {Ext.data.Model[]} records An Array of Ext.data.Model objects to add to the cache.
            </summary>
        </member>
        <member name="M:Ext.data.Store.isFiltered">
            <summary>
            Returns true if this store is currently filtered
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.data.Store.isGrouped">
            <summary>
            Checks if the store is currently grouped
            @return {Boolean} True if the store is grouped.
            </summary>
        </member>
        <member name="M:Ext.data.Store.last(System.Boolean)">
            <summary>
            Convenience function for getting the last model instance in the store
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the last record being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Ext.data.Model/undefined} The last model instance in the store, or undefined
            </summary>
        </member>
        <member name="M:Ext.data.Store.load(System.Object)">
            <summary>
            <p>Loads data into the Store via the configured {@link #proxy}. This uses the Proxy to make an
            asynchronous call to whatever storage backend the Proxy uses, automatically adding the retrieved
            instances into the Store and calling an optional callback if required. Example usage:</p>
            *
            <pre><code>
            store.load({
            scope   : this,
            callback: function(records, operation, success) {
            //the {@link Ext.data.Operation operation} object contains all of the details of the load operation
            console.log(records);
            }
            });
            </code></pre>
            *
            <p>If the callback scope does not need to be set, a function can simply be passed:</p>
            *
            <pre><code>
            store.load(function(records, operation, success) {
            console.log('loaded records');
            });
            </code></pre>
            *
            @param {Object/Function} options (Optional) config object, passed into the Ext.data.Operation object before loading.
            </summary>
        </member>
        <member name="M:Ext.data.Store.loadData(System.Object,System.Boolean)">
            <summary>
            Loads an array of data straight into the Store
            @param {Ext.data.Model[]/Object[]} data Array of data to load. Any non-model instances will be cast into model instances first
            @param {Boolean} append True to add the records to the existing records in the store, false to remove the old ones first
            </summary>
        </member>
        <member name="M:Ext.data.Store.loadPage(SharpKit.JavaScript.JsNumber,System.Object)">
            <summary>
            Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
            load operation, passing in calculated 'start' and 'limit' params
            @param {Number} page The number of the page to load
            @param {Object} options See options for {@link #load}
            </summary>
        </member>
        <member name="M:Ext.data.Store.loadRecords(System.Object,System.Object)">
            <summary>
            Loads an array of {@Ext.data.Model model} instances into the store, fires the datachanged event. This should only usually
            be called internally when loading from the {@link Ext.data.proxy.Proxy Proxy}, when adding records manually use {@link #add} instead
            @param {Ext.data.Model[]} records The array of records to load
            @param {Object} options {addRecords: true} to add these records to the existing records, false to remove the Store's existing records first
            </summary>
        </member>
        <member name="M:Ext.data.Store.max(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Gets the maximum value in the store.
            @param {String} field The field in each record
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the maximum in the group being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Object} The maximum value, if no items exist, undefined.
            </summary>
        </member>
        <member name="M:Ext.data.Store.min(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Gets the minimum value in the store.
            @param {String} field The field in each record
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the minimum in the group being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Object} The minimum value, if no items exist, undefined.
            </summary>
        </member>
        <member name="M:Ext.data.Store.nextPage(System.Object)">
            <summary>
            Loads the next 'page' in the current data set
            @param {Object} options See options for {@link #load}
            </summary>
        </member>
        <member name="M:Ext.data.Store.onCreateRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Create any new records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of new records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.Store.onDestroyRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Remove any records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of removed records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.Store.onGuaranteedRange">
            <summary>
            Handles a guaranteed range being loaded
            @private
            </summary>
        </member>
        <member name="M:Ext.data.Store.onProxyLoad(System.Object)">
            <summary>
            @private
            Called internally when a Proxy has completed a load request
            </summary>
        </member>
        <member name="M:Ext.data.Store.onProxyPrefetch(Ext.data.Operation)">
            <summary>
            Called after the configured proxy completes a prefetch operation.
            @private
            @param {Ext.data.Operation} operation The operation that completed
            </summary>
        </member>
        <member name="M:Ext.data.Store.onUpdateRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Update any records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of updated records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.Store.prefetch(System.Object)">
            <summary>
            Prefetches data into the store using its configured {@link #proxy}.
            @param {Object} options (Optional) config object, passed into the Ext.data.Operation object before loading.
            See {@link #load}
            </summary>
        </member>
        <member name="M:Ext.data.Store.prefetchPage(SharpKit.JavaScript.JsNumber,System.Object)">
            <summary>
            Prefetches a page of data.
            @param {Number} page The page to prefetch
            @param {Object} options (Optional) config object, passed into the Ext.data.Operation object before loading.
            See {@link #load}
            </summary>
        </member>
        <member name="M:Ext.data.Store.previousPage(System.Object)">
            <summary>
            Loads the previous 'page' in the current data set
            @param {Object} options See options for {@link #load}
            </summary>
        </member>
        <member name="M:Ext.data.Store.purgeRecords">
            <summary>
            Purge the least recently used records in the prefetch if the purgeCount
            has been exceeded.
            </summary>
        </member>
        <member name="M:Ext.data.Store.queryBy(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Query the cached records in this Store using a filtering function. The specified function
            will be called with each record in this Store. If the function returns <tt>true</tt> the record is
            included in the results.
            @param {Function} fn The function to be called. It will be passed the following parameters:<ul>
            <li><b>record</b> : Ext.data.Model<p class="sub-desc">The {@link Ext.data.Model record}
            to test for filtering. Access field values using {@link Ext.data.Model#get}.</p></li>
            <li><b>id</b> : Object<p class="sub-desc">The ID of the Record passed.</p></li>
            </ul>
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to this Store.
            @return {Ext.util.MixedCollection} Returns an Ext.util.MixedCollection of the matched records
            </summary>
        </member>
        <member name="M:Ext.data.Store.rangeSatisfied(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Determines if the range has already been satisfied in the prefetchData.
            @private
            @param {Number} start The start index
            @param {Number} end The end index in the range
            </summary>
        </member>
        <member name="M:Ext.data.Store.remove(System.Object,System.Object)">
            <summary>
            private
            </summary>
        </member>
        <member name="M:Ext.data.Store.removeAll(System.Boolean)">
            <summary>
            Remove all items from the store.
            @param {Boolean} silent Prevent the `clear` event from being fired.
            </summary>
        </member>
        <member name="M:Ext.data.Store.removeAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Removes the model instance at the given index
            @param {Number} index The record index
            </summary>
        </member>
        <member name="M:Ext.data.Store.sum(SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Sums the value of <tt>property</tt> for each {@link Ext.data.Model record} between <tt>start</tt>
            and <tt>end</tt> and returns the result.
            @param {String} field A field in each record
            @param {Boolean} grouped (Optional) True to perform the operation for each group
            in the store. The value returned will be an object literal with the key being the group
            name and the sum for that group being the value. The grouped parameter is only honored if
            the store has a groupField.
            @return {Number} The sum
            </summary>
        </member>
        <member name="P:Ext.data.Store.buffered">
            <summary>
            @cfg {Boolean} buffered
            Allow the store to buffer and pre-fetch pages of records. This is to be used in conjunction with a view will
            tell the store to pre-fetch records ahead of a time.
            </summary>
        </member>
        <member name="P:Ext.data.Store.clearOnPageLoad">
            <summary>
            @cfg {Boolean} clearOnPageLoad True to empty the store when loading another page via {@link #loadPage},
            {@link #nextPage} or {@link #previousPage} (defaults to true). Setting to false keeps existing records, allowing
            large data sets to be loaded one page at a time but rendered all together.
            </summary>
        </member>
        <member name="P:Ext.data.Store.Count">
            <summary>
            Gets the number of cached records.
            <p>If using paging, this may not be the total size of the dataset. If the data object
            used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
            the dataset size.  <b>Note</b>: see the Important note in {@link #load}.</p>
            @return {Number} The number of Records in the Store's cache.
            </summary>
        </member>
        <member name="P:Ext.data.Store.currentPage">
            <summary>
            The page that the Store has most recently loaded (see {@link #loadPage})
            @property currentPage
            @type Number
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.Store.extend" -->
        <member name="P:Ext.data.Store.groupDir">
            <summary>
            The direction in which sorting should be applied when grouping. Defaults to "ASC" - the other supported value is "DESC"
            @property groupDir
            @type String
            </summary>
        </member>
        <member name="P:Ext.data.Store.isStore">
            <summary>
            @cfg {Number} purgePageCount
            The number of pages to keep in the cache before purging additional records. A value of 0 indicates to never purge the prefetched data.
            This option is only relevant when the {@link #buffered} option is set to true.
            </summary>
        </member>
        <member name="P:Ext.data.Store.loading">
            <summary>
            True if the Store is currently loading via its Proxy
            @property loading
            @type Boolean
            @private
            </summary>
        </member>
        <member name="P:Ext.data.Store.pageSize">
            <summary>
            @cfg {Number} pageSize
            The number of records considered to form a 'page'. This is used to power the built-in
            paging using the nextPage and previousPage functions. Defaults to 25.
            </summary>
        </member>
        <member name="P:Ext.data.Store.purgePageCount">
            <summary>
            @cfg {Number} purgePageCount
            The number of pages to keep in the cache before purging additional records. A value of 0 indicates to never purge the prefetched data.
            This option is only relevant when the {@link #buffered} option is set to true.
            </summary>
        </member>
        <member name="P:Ext.data.Store.remoteFilter">
            <summary>
            @cfg {Boolean} remoteFilter
            True to defer any filtering operation to the server. If false, filtering is done locally on the client. Defaults to <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.Store.remoteGroup">
            <summary>
            @cfg {Boolean} remoteGroup
            True if the grouping should apply on the server side, false if it is local only (defaults to false).  If the
            grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
            helper, automatically sending the grouping information to the server.
            </summary>
        </member>
        <member name="P:Ext.data.Store.remoteSort">
            <summary>
            @cfg {Boolean} remoteSort
            True to defer any sorting operation to the server. If false, sorting is done locally on the client. Defaults to <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.Store.sortOnFilter">
            <summary>
            @cfg {Boolean} sortOnFilter For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
            causing the sorters to be reapplied after filtering. Defaults to true
            </summary>
        </member>
        <member name="P:Ext.data.Store.TotalCount">
            <summary>
            Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.proxy.Proxy Proxy}
            indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the
            number of records loaded into the Store at the moment, getTotalCount returns the number of records that
            could be loaded into the Store if the Store contained all data
            @return {Number} The total number of Model instances available via the Proxy
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.buffered">
            <summary>
            Allow the store to buffer and pre-fetch pages of records. This is to be used in conjunction with a view will
            tell the store to pre-fetch records ahead of a time.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.clearOnPageLoad">
            <summary>
            True to empty the store when loading another page via {@link #loadPage},
            {@link #nextPage} or {@link #previousPage} (defaults to true). Setting to false keeps existing records, allowing
            large data sets to be loaded one page at a time but rendered all together.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.data">
            <summary>
            Optional array of Model instances or data objects to load locally. See "Inline data" above for details.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.pageSize">
            <summary>
            The number of records considered to form a 'page'. This is used to power the built-in
            paging using the nextPage and previousPage functions. Defaults to 25.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.proxy">
            <summary>
            The Proxy to use for this Store. This can be either a string, a config
            object or a Proxy instance - see {@link #setProxy} for details.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.remoteFilter">
            <summary>
            True to defer any filtering operation to the server. If false, filtering is done locally on the client. Defaults to <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.remoteGroup">
            <summary>
            True if the grouping should apply on the server side, false if it is local only (defaults to false).  If the
            grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
            helper, automatically sending the grouping information to the server.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.remoteSort">
            <summary>
            True to defer any sorting operation to the server. If false, sorting is done locally on the client. Defaults to <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.StoreConfig.sortOnFilter">
            <summary>
            For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
            causing the sorters to be reapplied after filtering. Defaults to true
            </summary>
        </member>
        <member name="M:Ext.data.StoreManager.lookup(System.Object)">
            <summary>
            Gets a registered Store by id
            @param {String/Object} store The id of the Store, or a Store instance, or a store configuration
            @return {Ext.data.Store}
            </summary>
        </member>
        <member name="M:Ext.data.StoreManager.register">
            <summary>
            Registers one or more Stores with the StoreManager. You do not normally need to register stores manually. Any
            store initialized with a {@link Ext.data.Store#storeId} will be auto-registered.
            @param {Ext.data.Store...} stores Any number of Store instances
            </summary>
        </member>
        <member name="M:Ext.data.StoreManager.unregister">
            <summary>
            Unregisters one or more Stores with the StoreManager
            @param {String/Object...} stores Any number of Store instances or ID-s
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.StoreManager.extend" -->
        <member name="P:Ext.data.StoreManagerConfig.listeners">
            <summary>
            @hide
            </summary>
        </member>
        <member name="M:Ext.data.Tree.#ctor(Ext.data.NodeInterface)">
            <summary>
            Creates new Tree object.
            @param {Ext.data.NodeInterface} root (optional) The root node
            </summary>
        </member>
        <member name="M:Ext.data.Tree.filter(SharpKit.JavaScript.JsAction,System.Boolean)">
            <summary>
            Filters this tree
            @private
            @param {Function} sorterFn The function to use for filtering
            @param {Boolean} recursive True to perform recursive filtering
            </summary>
        </member>
        <member name="M:Ext.data.Tree.flatten">
            <summary>
            Flattens all the nodes in the tree into an array.
            @private
            @return {Ext.data.NodeInterface[]} The flattened nodes.
            </summary>
        </member>
        <member name="M:Ext.data.Tree.getNodeById(SharpKit.JavaScript.JsString)">
            <summary>
            Gets a node in this tree by its id.
            @param {String} id
            @return {Ext.data.NodeInterface} The match node.
            </summary>
        </member>
        <member name="M:Ext.data.Tree.getRootNode">
            <summary>
            Returns the root node for this tree.
            @return {Ext.data.NodeInterface}
            </summary>
        </member>
        <member name="M:Ext.data.Tree.onNodeAppend(Ext.data.NodeInterface,Ext.data.NodeInterface)">
            <summary>
            Fired when a node is appended into the root or one of it's children
            @private
            @param {Ext.data.NodeInterface} parent The parent node
            @param {Ext.data.NodeInterface} node The appended node
            </summary>
        </member>
        <member name="M:Ext.data.Tree.onNodeInsert(Ext.data.NodeInterface,Ext.data.NodeInterface)">
            <summary>
            Fired when a node is inserted into the root or one of it's children
            @private
            @param {Ext.data.NodeInterface} parent The parent node
            @param {Ext.data.NodeInterface} node The inserted node
            </summary>
        </member>
        <member name="M:Ext.data.Tree.onNodeRemove(Ext.data.NodeInterface,Ext.data.NodeInterface)">
            <summary>
            Fired when a node is removed from the root or one of it's children
            @private
            @param {Ext.data.NodeInterface} parent The parent node
            @param {Ext.data.NodeInterface} node The removed node
            </summary>
        </member>
        <member name="M:Ext.data.Tree.registerNode(Ext.data.NodeInterface)">
            <summary>
            Registers a node with the tree
            @private
            @param {Ext.data.NodeInterface} The node to register
            </summary>
        </member>
        <member name="M:Ext.data.Tree.setRootNode(Ext.data.NodeInterface)">
            <summary>
            Sets the root node for this tree.
            @param {Ext.data.NodeInterface} node
            @return {Ext.data.NodeInterface} The root node
            </summary>
        </member>
        <member name="M:Ext.data.Tree.sort(SharpKit.JavaScript.JsAction,System.Boolean)">
            <summary>
            Sorts this tree
            @private
            @param {Function} sorterFn The function to use for sorting
            @param {Boolean} recursive True to perform recursive sorting
            </summary>
        </member>
        <member name="M:Ext.data.Tree.unregisterNode(Ext.data.NodeInterface)">
            <summary>
            Unregisters a node with the tree
            @private
            @param {Ext.data.NodeInterface} The node to unregister
            </summary>
        </member>
        <member name="P:Ext.data.Tree.alias">
            <summary>
            @class Ext.data.Tree
            *
            This class is used as a container for a series of nodes. The nodes themselves maintain
            the relationship between parent/child. The tree itself acts as a manager. It gives functionality
            to retrieve a node by its identifier: {@link #getNodeById}.
            *
            The tree also relays events from any of it's child nodes, allowing them to be handled in a
            centralized fashion. In general this class is not used directly, rather used internally
            by other parts of the framework.
            *
            </summary>
        </member>
        <member name="P:Ext.data.Tree.root">
            <summary>
            @property {Ext.data.NodeInterface}
            The root node for this tree
            </summary>
        </member>
        <member name="P:Ext.data.Tree.RootNode">
            <summary>
            Sets the root node for this tree.
            @param {Ext.data.NodeInterface} node
            @return {Ext.data.NodeInterface} The root node
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.#ctor(System.Object)">
            <summary>
            @cfg {Boolean} folderSort
            Set to true to automatically prepend a leaf sorter. Defaults to `undefined`.
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.fillNode(Ext.data.NodeInterface,System.Object)">
            <summary>
            Fills a node with a series of child records.
            @private
            @param {Ext.data.NodeInterface} node The node to fill
            @param {Ext.data.Model[]} records The records to add
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.getNodeById(System.Object)">
            <summary>
            Returns the record node by id
            @return {Ext.data.NodeInterface}
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.getRootNode">
            <summary>
            Returns the root node for this tree.
            @return {Ext.data.NodeInterface}
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.load(System.Object)">
            <summary>
            Loads the Store using its configured {@link #proxy}.
            @param {Object} options (Optional) config object. This is passed into the {@link Ext.data.Operation Operation}
            object that is created and then sent to the proxy's {@link Ext.data.proxy.Proxy#read} function.
            The options can also contain a node, which indicates which node is to be loaded. If not specified, it will
            default to the root node.
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.onBeforeNodeCollapse(Ext.data.NodeInterface,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Called before a node is collapsed.
            @private
            @param {Ext.data.NodeInterface} node The node being collapsed.
            @param {Function} callback The function to run after the collapse finishes
            @param {Object} scope The scope in which to run the callback function
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.onBeforeNodeExpand(Ext.data.NodeInterface,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Called before a node is expanded.
            @private
            @param {Ext.data.NodeInterface} node The node being expanded.
            @param {Function} callback The function to run after the expand finishes
            @param {Object} scope The scope in which to run the callback function
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.onCreateRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Creates any new records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of new records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.onDestroyRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Removes any records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of removed records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.onUpdateRecords(System.Object,Ext.data.Operation,System.Boolean)">
            <summary>
            Updates any records when a write is returned from the server.
            @private
            @param {Ext.data.Model[]} records The array of updated records
            @param {Ext.data.Operation} operation The operation that just completed
            @param {Boolean} success True if the operation was successful
            </summary>
        </member>
        <member name="M:Ext.data.TreeStore.setRootNode(System.Object)">
            <summary>
            Sets the root node for this store.  See also the {@link #root} config option.
            @param {Ext.data.Model/Ext.data.NodeInterface/Object} root
            @return {Ext.data.NodeInterface} The new root
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.alias">
            <summary>
            The TreeStore is a store implementation that is backed by by an {@link Ext.data.Tree}.
            It provides convenience methods for loading nodes, as well as the ability to use
            the hierarchical tree structure combined with a store. This class also relays many events from
            the Tree for convenience.
            *
            # Using Models
            *
            If no Model is specified, an implicit model will be created that implements {@link Ext.data.NodeInterface}.
            The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
            in the {@link Ext.data.NodeInterface} documentation.
            *
            # Reading Nested Data
            *
            For the tree to read nested data, the {@link Ext.data.reader.Reader} must be configured with a root property,
            so the reader can find nested data for each node. If a root is not specified, it will default to
            'children'.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.clearOnLoad">
            <summary>
            @cfg {Boolean} clearOnLoad
            Remove previously existing child nodes before loading. Default to true.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.defaultRootId">
            <summary>
            @cfg {String} defaultRootId
            The default root id. Defaults to 'root'
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.defaultRootProperty">
            <summary>
            @cfg {String} defaultRootProperty
            The root property to specify on the reader if one is not explicitly defined.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.extend">
            <summary>
            The TreeStore is a store implementation that is backed by by an {@link Ext.data.Tree}.
            It provides convenience methods for loading nodes, as well as the ability to use
            the hierarchical tree structure combined with a store. This class also relays many events from
            the Tree for convenience.
            *
            # Using Models
            *
            If no Model is specified, an implicit model will be created that implements {@link Ext.data.NodeInterface}.
            The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
            in the {@link Ext.data.NodeInterface} documentation.
            *
            # Reading Nested Data
            *
            For the tree to read nested data, the {@link Ext.data.reader.Reader} must be configured with a root property,
            so the reader can find nested data for each node. If a root is not specified, it will default to
            'children'.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.folderSort">
            <summary>
            @cfg {Boolean} folderSort
            Set to true to automatically prepend a leaf sorter. Defaults to `undefined`.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.nodeParam">
            <summary>
            @cfg {String} nodeParam
            The name of the parameter sent to the server which contains the identifier of the node.
            Defaults to 'node'.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStore.RootNode">
            <summary>
            Sets the root node for this store.  See also the {@link #root} config option.
            @param {Ext.data.Model/Ext.data.NodeInterface/Object} root
            @return {Ext.data.NodeInterface} The new root
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.clearOnLoad">
            <summary>
            Remove previously existing child nodes before loading. Default to true.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.defaultRootId">
            <summary>
            The default root id. Defaults to 'root'
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.defaultRootProperty">
            <summary>
            The root property to specify on the reader if one is not explicitly defined.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.folderSort">
            <summary>
            Set to true to automatically prepend a leaf sorter. Defaults to `undefined`.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.nodeParam">
            <summary>
            The name of the parameter sent to the server which contains the identifier of the node.
            Defaults to 'node'.
            </summary>
        </member>
        <member name="P:Ext.data.TreeStoreConfig.root">
            <summary>
            The root node for this store. For example:
            *
            root: {
            expanded: true,
            text: "My Root",
            children: [
            { text: "Child 1", leaf: true },
            { text: "Child 2", expanded: true, children: [
            { text: "GrandChild", leaf: true }
            ] }
            ]
            }
            *
            Setting the `root` config option is the same as calling {@link #setRootNode}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.Types.singleton" -->
        <member name="M:Ext.data.UuidGenerator.#ctor">
            <summary>
            @cfg {Number} version
            The Version of UUID. Supported values are:
            *
            * 1 : Time-based, "sequential" UUID.
            * 4 : Pseudo-random UUID.
            *
            The default is 4.
            </summary>
        </member>
        <member name="M:Ext.data.UuidGenerator.init">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.data.UuidGenerator.reconfigure(System.Object)">
            <summary>
            Reconfigures this generator given new config properties.
            </summary>
        </member>
        <member name="P:Ext.data.UuidGenerator.version">
            <summary>
            @cfg {Number} version
            The Version of UUID. Supported values are:
            *
            * 1 : Time-based, "sequential" UUID.
            * 4 : Pseudo-random UUID.
            *
            The default is 4.
            </summary>
        </member>
        <member name="P:Ext.data.UuidGeneratorConfig.version">
            <summary>
            The Version of UUID. Supported values are:
            *
            * 1 : Time-based, "sequential" UUID.
            * 4 : Pseudo-random UUID.
            *
            The default is 4.
            </summary>
        </member>
        <member name="M:Ext.data.validations.email(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Validates that an email string is in the correct format
            @param {Object} config Config object
            @param {String} email The email address
            @return {Boolean} True if the value passes validation
            </summary>
        </member>
        <member name="M:Ext.data.validations.exclusion(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Validates that the given value is present in the configured `list`.
            For example:
            *
            validations: [{type: 'exclusion', field: 'username', list: ['Admin', 'Operator']}]
            *
            @param {Object} config Config object
            @param {String} value The value to validate
            @return {Boolean} True if the value is not present in the list
            </summary>
        </member>
        <member name="M:Ext.data.validations.format(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the given value passes validation against the configured `matcher` regex.
            For example:
            *
            validations: [{type: 'format', field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}]
            *
            @param {Object} config Config object
            @param {String} value The value to validate
            @return {Boolean} True if the value passes the format validation
            </summary>
        </member>
        <member name="M:Ext.data.validations.inclusion(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Validates that the given value is present in the configured `list`.
            For example:
            *
            validations: [{type: 'inclusion', field: 'gender', list: ['Male', 'Female']}]
            *
            @param {Object} config Config object
            @param {String} value The value to validate
            @return {Boolean} True if the value is present in the list
            </summary>
        </member>
        <member name="M:Ext.data.validations.length(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the given value is between the configured min and max values.
            For example:
            *
            validations: [{type: 'length', field: 'name', min: 2}]
            *
            @param {Object} config Config object
            @param {String} value The value to validate
            @return {Boolean} True if the value passes validation
            </summary>
        </member>
        <member name="M:Ext.data.validations.presence(System.Object,System.Object)">
            <summary>
            Validates that the given value is present.
            For example:
            *
            validations: [{type: 'presence', field: 'age'}]
            *
            @param {Object} config Config object
            @param {Object} value The value to validate
            @return {Boolean} True if validation passed
            </summary>
        </member>
        <member name="P:Ext.data.validations.emailMessage">
            <summary>
            @property {String} emailMessage
            The default error message used when an email validation fails
            </summary>
        </member>
        <member name="P:Ext.data.validations.emailRe">
            <summary>
            The regular expression used to validate email addresses
            @property emailRe
            @type RegExp
            </summary>
        </member>
        <member name="P:Ext.data.validations.exclusionMessage">
            <summary>
            @property {String} exclusionMessage
            The default error message used when an exclusion validation fails.
            </summary>
        </member>
        <member name="P:Ext.data.validations.formatMessage">
            <summary>
            @property {Boolean} formatMessage
            The default error message used when a format validation fails.
            </summary>
        </member>
        <member name="P:Ext.data.validations.inclusionMessage">
            <summary>
            @property {String} inclusionMessage
            The default error message used when an inclusion validation fails.
            </summary>
        </member>
        <member name="P:Ext.data.validations.lengthMessage">
            <summary>
            @property {String} lengthMessage
            The default error message used when a length validation fails.
            </summary>
        </member>
        <member name="P:Ext.data.validations.presenceMessage">
            <summary>
            @property {String} presenceMessage
            The default error message used when a presence validation fails.
            </summary>
        </member>
        <member name="P:Ext.data.validations.singleton">
            <summary>
            @extends Object
            @author Ed Spencer
            *
            This singleton contains a set of validation functions that can be used to validate any type of data. They are most
            often used in {@link Ext.data.Model Models}, where they are automatically set up and executed.
            </summary>
        </member>
        <member name="M:Ext.data.XmlStore.#ctor(System.Object)">
            <summary>
            @cfg {Ext.data.DataReader} reader @hide
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.XmlStore.alternateClassName" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.data.XmlStore.extend" -->
        <member name="M:Ext.data.association.Association.#ctor(System.Object)">
            <summary>
            Creates the Association object.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.association.Association.getReader">
            <summary>
            Get a specialized reader for reading associated data
            @return {Ext.data.reader.Reader} The reader, null if not supplied
            </summary>
        </member>
        <member name="P:Ext.data.association.Association.alternateClassName">
            <summary>
            @author Ed Spencer
            @class Ext.data.association.Association
            @extends Object
            *
            <p>Associations enable you to express relationships between different {@link Ext.data.Model Models}. Let's say we're
            writing an ecommerce system where Users can make Orders - there's a relationship between these Models that we can
            express like this:</p>
            *
            <pre><code>
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'email'],
            hasMany: {model: 'Order', name: 'orders'}
            });
            Ext.define('Order', {
            extend: 'Ext.data.Model',
            fields: ['id', 'user_id', 'status', 'price'],
            belongsTo: 'User'
            });
            </code></pre>
            *
            <p>We've set up two models - User and Order - and told them about each other. You can set up as many associations on
            each Model as you need using the two default types - {@link Ext.data.association.HasMany hasMany} and
            {@link Ext.data.association.BelongsTo belongsTo}. There's much more detail on the usage of each of those inside their
            documentation pages. If you're not familiar with Models already, {@link Ext.data.Model there is plenty on those too}.</p>
            *
            <p><u>Further Reading</u></p>
            *
            <ul style="list-style-type: disc; padding-left: 20px;">
            <li>{@link Ext.data.association.HasMany hasMany associations}</li>
            <li>{@link Ext.data.association.BelongsTo belongsTo associations}</li>
            <li>{@link Ext.data.association.HasOne hasOne associations}</li>
            <li>{@link Ext.data.Model using Models}</li>
            </ul>
            <b>Self association models</b>
            <p>We can also have models that create parent/child associations between the same type. Below is an example, where
            groups can be nested inside other groups:</p>
            <pre><code>
            // Server Data
            {
            "groups": {
            "id": 10,
            "parent_id": 100,
            "name": "Main Group",
            "parent_group": {
            "id": 100,
            "parent_id": null,
            "name": "Parent Group"
            },
            "child_groups": [{
            "id": 2,
            "parent_id": 10,
            "name": "Child Group 1"
            },{
            "id": 3,
            "parent_id": 10,
            "name": "Child Group 2"
            },{
            "id": 4,
            "parent_id": 10,
            "name": "Child Group 3"
            }]
            }
            }
            // Client code
            Ext.define('Group', {
            extend: 'Ext.data.Model',
            fields: ['id', 'parent_id', 'name'],
            proxy: {
            type: 'ajax',
            url: 'data.json',
            reader: {
            type: 'json',
            root: 'groups'
            }
            },
            associations: [{
            type: 'hasMany',
            model: 'Group',
            primaryKey: 'id',
            foreignKey: 'parent_id',
            autoLoad: true,
            associationKey: 'child_groups' // read child data from child_groups
            }, {
            type: 'belongsTo',
            model: 'Group',
            primaryKey: 'id',
            foreignKey: 'parent_id',
            associationKey: 'parent_group' // read parent data from parent_group
            }]
            });
            Ext.onReady(function(){
            Group.load(10, {
            success: function(group){
            console.log(group.getGroup().get('name'));
            group.groups().each(function(rec){
            console.log(rec.get('name'));
            });
            }
            });
            });
            </code></pre>
            *
            </summary>
        </member>
        <member name="P:Ext.data.association.Association.defaultReaderType">
            <summary>
            @cfg {String} associationKey The name of the property in the data to read the association from.
            Defaults to the name of the associated model.
            </summary>
        </member>
        <member name="P:Ext.data.association.Association.primaryKey">
            <summary>
            @cfg {String} primaryKey The name of the primary key on the associated model. Defaults to 'id'.
            In general this will be the {@link Ext.data.Model#idProperty} of the Model.
            </summary>
        </member>
        <member name="P:Ext.data.association.Association.Reader">
            <summary>
            Get a specialized reader for reading associated data
            @return {Ext.data.reader.Reader} The reader, null if not supplied
            </summary>
        </member>
        <member name="P:Ext.data.association.AssociationConfig.associatedModel">
            <summary>
            The string name of the model that is being associated with. Required
            </summary>
        </member>
        <member name="P:Ext.data.association.AssociationConfig.associationKey">
            <summary>
            The name of the property in the data to read the association from.
            Defaults to the name of the associated model.
            </summary>
        </member>
        <member name="P:Ext.data.association.AssociationConfig.ownerModel">
            <summary>
            The string name of the model that owns the association. Required
            </summary>
        </member>
        <member name="P:Ext.data.association.AssociationConfig.primaryKey">
            <summary>
            The name of the primary key on the associated model. Defaults to 'id'.
            In general this will be the {@link Ext.data.Model#idProperty} of the Model.
            </summary>
        </member>
        <member name="P:Ext.data.association.AssociationConfig.reader">
            <summary>
            A special reader to read associated data
            </summary>
        </member>
        <member name="M:Ext.data.association.BelongsTo.#ctor(System.Object)">
            <summary>
            @cfg {String} type The type configuration can be used when creating associations using a configuration object.
            Use 'belongsTo' to create a BelongsTo association.
            *
            associations: [{
            type: 'belongsTo',
            model: 'User'
            }]
            </summary>
        </member>
        <member name="M:Ext.data.association.BelongsTo.createGetter">
            <summary>
            @private
            Returns a getter function to be placed on the owner model's prototype. We cache the loaded instance
            the first time it is loaded so that subsequent calls to the getter always receive the same reference.
            @return {Function} The getter function
            </summary>
        </member>
        <member name="M:Ext.data.association.BelongsTo.createSetter">
            <summary>
            @private
            Returns a setter function to be placed on the owner model's prototype
            @return {Function} The setter function
            </summary>
        </member>
        <member name="M:Ext.data.association.BelongsTo.read(Ext.data.Model,Ext.data.reader.Reader,System.Object)">
            <summary>
            Read associated data
            @private
            @param {Ext.data.Model} record The record we're writing to
            @param {Ext.data.reader.Reader} reader The reader for the associated model
            @param {Object} associationData The raw associated data
            </summary>
        </member>
        <member name="P:Ext.data.association.BelongsTo.alternateClassName">
            <summary>
            @author Ed Spencer
            @class Ext.data.association.BelongsTo
            @extends Ext.data.association.Association
            *
            Represents a many to one association with another model. The owner model is expected to have
            a foreign key which references the primary key of the associated model:
            *
            Ext.define('Category', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',   type: 'int' },
            { name: 'name', type: 'string' }
            ]
            });
            *
            Ext.define('Product', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',          type: 'int' },
            { name: 'category_id', type: 'int' },
            { name: 'name',        type: 'string' }
            ],
            // we can use the belongsTo shortcut on the model to create a belongsTo association
            associations: { type: 'belongsTo', model: 'Category' }
            });
            *
            In the example above we have created models for Products and Categories, and linked them together
            by saying that each Product belongs to a Category. This automatically links each Product to a Category
            based on the Product's category_id, and provides new functions on the Product model:
            *
            ## Generated getter function
            *
            The first function that is added to the owner model is a getter function:
            *
            var product = new Product({
            id: 100,
            category_id: 20,
            name: 'Sneakers'
            });
            *
            product.getCategory(function(category, operation) {
            // do something with the category object
            alert(category.get('id')); // alerts 20
            }, this);
            *
            The getCategory function was created on the Product model when we defined the association. This uses the
            Category's configured {@link Ext.data.proxy.Proxy proxy} to load the Category asynchronously, calling the provided
            callback when it has loaded.
            *
            The new getCategory function will also accept an object containing success, failure and callback properties
            - callback will always be called, success will only be called if the associated model was loaded successfully
            and failure will only be called if the associatied model could not be loaded:
            *
            product.getCategory({
            reload: true, // force a reload if the owner model is already cached
            callback: function(category, operation) {}, // a function that will always be called
            success : function(category, operation) {}, // a function that will only be called if the load succeeded
            failure : function(category, operation) {}, // a function that will only be called if the load did not succeed
            scope   : this // optionally pass in a scope object to execute the callbacks in
            });
            *
            In each case above the callbacks are called with two arguments - the associated model instance and the
            {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
            useful when the instance could not be loaded.
            Once the getter has been called on the model, it will be cached if the getter is called a second time. To
            force the model to reload, specify reload: true in the options object.
            *
            ## Generated setter function
            *
            The second generated function sets the associated model instance - if only a single argument is passed to
            the setter then the following two calls are identical:
            *
            // this call...
            product.setCategory(10);
            *
            // is equivalent to this call:
            product.set('category_id', 10);
            An instance of the owner model can also be passed as a parameter.
            *
            If we pass in a second argument, the model will be automatically saved and the second argument passed to
            the owner model's {@link Ext.data.Model#save save} method:
            *
            product.setCategory(10, function(product, operation) {
            // the product has been saved
            alert(product.get('category_id')); //now alerts 10
            });
            *
            //alternative syntax:
            product.setCategory(10, {
            callback: function(product, operation), // a function that will always be called
            success : function(product, operation), // a function that will only be called if the load succeeded
            failure : function(product, operation), // a function that will only be called if the load did not succeed
            scope   : this //optionally pass in a scope object to execute the callbacks in
            })
            *
            ## Customisation
            *
            Associations reflect on the models they are linking to automatically set up properties such as the
            {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
            *
            Ext.define('Product', {
            fields: [...],
            *
            associations: [
            { type: 'belongsTo', model: 'Category', primaryKey: 'unique_id', foreignKey: 'cat_id' }
            ]
            });
            *
            Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'category_id')
            with our own settings. Usually this will not be needed.
            </summary>
        </member>
        <member name="P:Ext.data.association.BelongsTo.extend">
            <summary>
            @author Ed Spencer
            @class Ext.data.association.BelongsTo
            @extends Ext.data.association.Association
            *
            Represents a many to one association with another model. The owner model is expected to have
            a foreign key which references the primary key of the associated model:
            *
            Ext.define('Category', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',   type: 'int' },
            { name: 'name', type: 'string' }
            ]
            });
            *
            Ext.define('Product', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',          type: 'int' },
            { name: 'category_id', type: 'int' },
            { name: 'name',        type: 'string' }
            ],
            // we can use the belongsTo shortcut on the model to create a belongsTo association
            associations: { type: 'belongsTo', model: 'Category' }
            });
            *
            In the example above we have created models for Products and Categories, and linked them together
            by saying that each Product belongs to a Category. This automatically links each Product to a Category
            based on the Product's category_id, and provides new functions on the Product model:
            *
            ## Generated getter function
            *
            The first function that is added to the owner model is a getter function:
            *
            var product = new Product({
            id: 100,
            category_id: 20,
            name: 'Sneakers'
            });
            *
            product.getCategory(function(category, operation) {
            // do something with the category object
            alert(category.get('id')); // alerts 20
            }, this);
            *
            The getCategory function was created on the Product model when we defined the association. This uses the
            Category's configured {@link Ext.data.proxy.Proxy proxy} to load the Category asynchronously, calling the provided
            callback when it has loaded.
            *
            The new getCategory function will also accept an object containing success, failure and callback properties
            - callback will always be called, success will only be called if the associated model was loaded successfully
            and failure will only be called if the associatied model could not be loaded:
            *
            product.getCategory({
            reload: true, // force a reload if the owner model is already cached
            callback: function(category, operation) {}, // a function that will always be called
            success : function(category, operation) {}, // a function that will only be called if the load succeeded
            failure : function(category, operation) {}, // a function that will only be called if the load did not succeed
            scope   : this // optionally pass in a scope object to execute the callbacks in
            });
            *
            In each case above the callbacks are called with two arguments - the associated model instance and the
            {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
            useful when the instance could not be loaded.
            Once the getter has been called on the model, it will be cached if the getter is called a second time. To
            force the model to reload, specify reload: true in the options object.
            *
            ## Generated setter function
            *
            The second generated function sets the associated model instance - if only a single argument is passed to
            the setter then the following two calls are identical:
            *
            // this call...
            product.setCategory(10);
            *
            // is equivalent to this call:
            product.set('category_id', 10);
            An instance of the owner model can also be passed as a parameter.
            *
            If we pass in a second argument, the model will be automatically saved and the second argument passed to
            the owner model's {@link Ext.data.Model#save save} method:
            *
            product.setCategory(10, function(product, operation) {
            // the product has been saved
            alert(product.get('category_id')); //now alerts 10
            });
            *
            //alternative syntax:
            product.setCategory(10, {
            callback: function(product, operation), // a function that will always be called
            success : function(product, operation), // a function that will only be called if the load succeeded
            failure : function(product, operation), // a function that will only be called if the load did not succeed
            scope   : this //optionally pass in a scope object to execute the callbacks in
            })
            *
            ## Customisation
            *
            Associations reflect on the models they are linking to automatically set up properties such as the
            {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
            *
            Ext.define('Product', {
            fields: [...],
            *
            associations: [
            { type: 'belongsTo', model: 'Category', primaryKey: 'unique_id', foreignKey: 'cat_id' }
            ]
            });
            *
            Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'category_id')
            with our own settings. Usually this will not be needed.
            </summary>
        </member>
        <member name="P:Ext.data.association.BelongsToConfig.foreignKey">
            <summary>
            The name of the foreign key on the owner model that links it to the associated
            model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
            model called Product would set up a product_id foreign key.
            *
            Ext.define('Order', {
            extend: 'Ext.data.Model',
            fields: ['id', 'date'],
            hasMany: 'Product'
            });
            *
            Ext.define('Product', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'order_id'], // refers to the id of the order that this product belongs to
            belongsTo: 'Group'
            });
            var product = new Product({
            id: 1,
            name: 'Product 1',
            order_id: 22
            }, 1);
            product.getOrder(); // Will make a call to the server asking for order_id 22
            *
            </summary>
        </member>
        <member name="P:Ext.data.association.BelongsToConfig.getterName">
            <summary>
            The name of the getter function that will be added to the local model's prototype.
            Defaults to 'get' + the name of the foreign model, e.g. getCategory
            </summary>
        </member>
        <member name="P:Ext.data.association.BelongsToConfig.setterName">
            <summary>
            The name of the setter function that will be added to the local model's prototype.
            Defaults to 'set' + the name of the foreign model, e.g. setCategory
            </summary>
        </member>
        <member name="M:Ext.data.association.HasMany.#ctor(System.Object)">
            <summary>
            @cfg {String} type The type configuration can be used when creating associations using a configuration object.
            Use 'hasMany' to create a HasMany association
            <pre><code>
            associations: [{
            type: 'hasMany',
            model: 'User'
            }]
            </code></pre>
            </summary>
        </member>
        <member name="M:Ext.data.association.HasMany.createStore">
            <summary>
            @private
            Creates a function that returns an Ext.data.Store which is configured to load a set of data filtered
            by the owner model's primary key - e.g. in a hasMany association where Group hasMany Users, this function
            returns a Store configured to return the filtered set of a single Group's Users.
            @return {Function} The store-generating function
            </summary>
        </member>
        <member name="M:Ext.data.association.HasMany.read(Ext.data.Model,Ext.data.reader.Reader,System.Object)">
            <summary>
            Read associated data
            @private
            @param {Ext.data.Model} record The record we're writing to
            @param {Ext.data.reader.Reader} reader The reader for the associated model
            @param {Object} associationData The raw associated data
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.association.HasMany.alternateClassName" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.data.association.HasMany.extend" -->
        <member name="P:Ext.data.association.HasManyConfig.autoLoad">
            <summary>
            True to automatically load the related store from a remote source when instantiated.
            Defaults to <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.association.HasManyConfig.filterProperty">
            <summary>
            Optionally overrides the default filter that is set up on the associated Store. If
            this is not set, a filter is automatically created which filters the association based on the configured
            {@link #foreignKey}. See intro docs for more details. Defaults to undefined
            </summary>
        </member>
        <member name="P:Ext.data.association.HasManyConfig.foreignKey">
            <summary>
            The name of the foreign key on the associated model that links it to the owner
            model. Defaults to the lowercased name of the owner model plus "_id", e.g. an association with a where a
            model called Group hasMany Users would create 'group_id' as the foreign key. When the remote store is loaded,
            the store is automatically filtered so that only records with a matching foreign key are included in the
            resulting child store. This can be overridden by specifying the {@link #filterProperty}.
            <pre><code>
            Ext.define('Group', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name'],
            hasMany: 'User'
            });
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'group_id'], // refers to the id of the group that this user belongs to
            belongsTo: 'Group'
            });
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.data.association.HasManyConfig.name">
            <summary>
            The name of the function to create on the owner model to retrieve the child store.
            If not specified, the pluralized name of the child model is used.
            <pre><code>
            // This will create a users() method on any Group model instance
            Ext.define('Group', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name'],
            hasMany: 'User'
            });
            var group = new Group();
            console.log(group.users());
            // The method to retrieve the users will now be getUserList
            Ext.define('Group', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name'],
            hasMany: {model: 'User', name: 'getUserList'}
            });
            var group = new Group();
            console.log(group.getUserList());
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.data.association.HasManyConfig.storeConfig">
            <summary>
            Optional configuration object that will be passed to the generated Store. Defaults to
            undefined.
            </summary>
        </member>
        <member name="M:Ext.data.association.HasOne.#ctor(System.Object)">
            <summary>
            @cfg {String} type The type configuration can be used when creating associations using a configuration object.
            Use 'hasOne' to create a HasOne association.
            *
            associations: [{
            type: 'hasOne',
            model: 'Address'
            }]
            </summary>
        </member>
        <member name="M:Ext.data.association.HasOne.createGetter">
            <summary>
            @private
            Returns a getter function to be placed on the owner model's prototype. We cache the loaded instance
            the first time it is loaded so that subsequent calls to the getter always receive the same reference.
            @return {Function} The getter function
            </summary>
        </member>
        <member name="M:Ext.data.association.HasOne.createSetter">
            <summary>
            @private
            Returns a setter function to be placed on the owner model's prototype
            @return {Function} The setter function
            </summary>
        </member>
        <member name="M:Ext.data.association.HasOne.read(Ext.data.Model,Ext.data.reader.Reader,System.Object)">
            <summary>
            Read associated data
            @private
            @param {Ext.data.Model} record The record we're writing to
            @param {Ext.data.reader.Reader} reader The reader for the associated model
            @param {Object} associationData The raw associated data
            </summary>
        </member>
        <member name="P:Ext.data.association.HasOne.alternameClassName">
            <summary>
            @class Ext.data.association.HasOne
            @extends Ext.data.association.Association
            Represents a one to one association with another model. The owner model is expected to have
            a foreign key which references the primary key of the associated model:
            *
            Ext.define('Person', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',   type: 'int' },
            { name: 'name', type: 'string' },
            { name: 'address_id', type: 'int'}
            ]
            });
            *
            Ext.define('Address', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',          type: 'int' },
            { name: 'number', type: 'string' },
            { name: 'street', type: 'string' },
            { name: 'city', type: 'string' },
            { name: 'zip', type: 'string' },
            ],
            // we can use the hasOne shortcut on the model to create a hasOne association
            associations: { type: 'hasOne', model: 'Address' }
            });
            *
            In the example above we have created models for People and Addresses, and linked them together
            by saying that each Person has a single Address. This automatically links each Person to an Address
            based on the Persons address_id, and provides new functions on the Person model:
            *
            ## Generated getter function
            *
            The first function that is added to the owner model is a getter function:
            *
            var person = new Person({
            id: 100,
            address_id: 20,
            name: 'John Smith'
            });
            *
            person.getAddress(function(address, operation) {
            // do something with the address object
            alert(address.get('id')); // alerts 20
            }, this);
            *
            The getAddress function was created on the Person model when we defined the association. This uses the
            Persons configured {@link Ext.data.proxy.Proxy proxy} to load the Address asynchronously, calling the provided
            callback when it has loaded.
            *
            The new getAddress function will also accept an object containing success, failure and callback properties
            - callback will always be called, success will only be called if the associated model was loaded successfully
            and failure will only be called if the associatied model could not be loaded:
            *
            person.getAddress({
            reload: true, // force a reload if the owner model is already cached
            callback: function(address, operation) {}, // a function that will always be called
            success : function(address, operation) {}, // a function that will only be called if the load succeeded
            failure : function(address, operation) {}, // a function that will only be called if the load did not succeed
            scope   : this // optionally pass in a scope object to execute the callbacks in
            });
            *
            In each case above the callbacks are called with two arguments - the associated model instance and the
            {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
            useful when the instance could not be loaded.
            Once the getter has been called on the model, it will be cached if the getter is called a second time. To
            force the model to reload, specify reload: true in the options object.
            *
            ## Generated setter function
            *
            The second generated function sets the associated model instance - if only a single argument is passed to
            the setter then the following two calls are identical:
            *
            // this call...
            person.setAddress(10);
            *
            // is equivalent to this call:
            person.set('address_id', 10);
            An instance of the owner model can also be passed as a parameter.
            *
            If we pass in a second argument, the model will be automatically saved and the second argument passed to
            the owner model's {@link Ext.data.Model#save save} method:
            *
            person.setAddress(10, function(address, operation) {
            // the address has been saved
            alert(address.get('address_id')); //now alerts 10
            });
            *
            //alternative syntax:
            person.setAddress(10, {
            callback: function(address, operation), // a function that will always be called
            success : function(address, operation), // a function that will only be called if the load succeeded
            failure : function(address, operation), // a function that will only be called if the load did not succeed
            scope   : this //optionally pass in a scope object to execute the callbacks in
            })
            *
            ## Customisation
            *
            Associations reflect on the models they are linking to automatically set up properties such as the
            {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
            *
            Ext.define('Person', {
            fields: [...],
            *
            associations: [
            { type: 'hasOne', model: 'Address', primaryKey: 'unique_id', foreignKey: 'addr_id' }
            ]
            });
            *
            Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'address_id')
            with our own settings. Usually this will not be needed.
            </summary>
        </member>
        <member name="P:Ext.data.association.HasOne.extend">
            <summary>
            @class Ext.data.association.HasOne
            @extends Ext.data.association.Association
            Represents a one to one association with another model. The owner model is expected to have
            a foreign key which references the primary key of the associated model:
            *
            Ext.define('Person', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',   type: 'int' },
            { name: 'name', type: 'string' },
            { name: 'address_id', type: 'int'}
            ]
            });
            *
            Ext.define('Address', {
            extend: 'Ext.data.Model',
            fields: [
            { name: 'id',          type: 'int' },
            { name: 'number', type: 'string' },
            { name: 'street', type: 'string' },
            { name: 'city', type: 'string' },
            { name: 'zip', type: 'string' },
            ],
            // we can use the hasOne shortcut on the model to create a hasOne association
            associations: { type: 'hasOne', model: 'Address' }
            });
            *
            In the example above we have created models for People and Addresses, and linked them together
            by saying that each Person has a single Address. This automatically links each Person to an Address
            based on the Persons address_id, and provides new functions on the Person model:
            *
            ## Generated getter function
            *
            The first function that is added to the owner model is a getter function:
            *
            var person = new Person({
            id: 100,
            address_id: 20,
            name: 'John Smith'
            });
            *
            person.getAddress(function(address, operation) {
            // do something with the address object
            alert(address.get('id')); // alerts 20
            }, this);
            *
            The getAddress function was created on the Person model when we defined the association. This uses the
            Persons configured {@link Ext.data.proxy.Proxy proxy} to load the Address asynchronously, calling the provided
            callback when it has loaded.
            *
            The new getAddress function will also accept an object containing success, failure and callback properties
            - callback will always be called, success will only be called if the associated model was loaded successfully
            and failure will only be called if the associatied model could not be loaded:
            *
            person.getAddress({
            reload: true, // force a reload if the owner model is already cached
            callback: function(address, operation) {}, // a function that will always be called
            success : function(address, operation) {}, // a function that will only be called if the load succeeded
            failure : function(address, operation) {}, // a function that will only be called if the load did not succeed
            scope   : this // optionally pass in a scope object to execute the callbacks in
            });
            *
            In each case above the callbacks are called with two arguments - the associated model instance and the
            {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
            useful when the instance could not be loaded.
            Once the getter has been called on the model, it will be cached if the getter is called a second time. To
            force the model to reload, specify reload: true in the options object.
            *
            ## Generated setter function
            *
            The second generated function sets the associated model instance - if only a single argument is passed to
            the setter then the following two calls are identical:
            *
            // this call...
            person.setAddress(10);
            *
            // is equivalent to this call:
            person.set('address_id', 10);
            An instance of the owner model can also be passed as a parameter.
            *
            If we pass in a second argument, the model will be automatically saved and the second argument passed to
            the owner model's {@link Ext.data.Model#save save} method:
            *
            person.setAddress(10, function(address, operation) {
            // the address has been saved
            alert(address.get('address_id')); //now alerts 10
            });
            *
            //alternative syntax:
            person.setAddress(10, {
            callback: function(address, operation), // a function that will always be called
            success : function(address, operation), // a function that will only be called if the load succeeded
            failure : function(address, operation), // a function that will only be called if the load did not succeed
            scope   : this //optionally pass in a scope object to execute the callbacks in
            })
            *
            ## Customisation
            *
            Associations reflect on the models they are linking to automatically set up properties such as the
            {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
            *
            Ext.define('Person', {
            fields: [...],
            *
            associations: [
            { type: 'hasOne', model: 'Address', primaryKey: 'unique_id', foreignKey: 'addr_id' }
            ]
            });
            *
            Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'address_id')
            with our own settings. Usually this will not be needed.
            </summary>
        </member>
        <member name="P:Ext.data.association.HasOneConfig.foreignKey">
            <summary>
            The name of the foreign key on the owner model that links it to the associated
            model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
            model called Person would set up a address_id foreign key.
            *
            Ext.define('Person', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'address_id'], // refers to the id of the address object
            hasOne: 'Address'
            });
            *
            Ext.define('Address', {
            extend: 'Ext.data.Model',
            fields: ['id', 'number', 'street', 'city', 'zip'],
            belongsTo: 'Person'
            });
            var Person = new Person({
            id: 1,
            name: 'John Smith',
            address_id: 13
            }, 1);
            person.getAddress(); // Will make a call to the server asking for address_id 13
            *
            </summary>
        </member>
        <member name="P:Ext.data.association.HasOneConfig.getterName">
            <summary>
            The name of the getter function that will be added to the local model's prototype.
            Defaults to 'get' + the name of the foreign model, e.g. getAddress
            </summary>
        </member>
        <member name="P:Ext.data.association.HasOneConfig.setterName">
            <summary>
            The name of the setter function that will be added to the local model's prototype.
            Defaults to 'set' + the name of the foreign model, e.g. setAddress
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Ajax.createRequestCallback(Ext.data.Request,Ext.data.Operation,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            @private
            TODO: This is currently identical to the JsonPProxy version except for the return function's signature. There is a lot
            of code duplication inside the returned function so we need to find a way to DRY this up.
            @param {Ext.data.Request} request The Request object
            @param {Ext.data.Operation} operation The Operation being executed
            @param {Function} callback The callback function to be called when the request completes. This is usually the callback
            passed to doRequest
            @param {Object} scope The scope in which to execute the callback function
            @return {Function} The callback function
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Ajax.doRequest(System.Object,System.Object,System.Object)">
            <summary>
            @ignore
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Ajax.getMethod(Ext.data.Request)">
            <summary>
            Returns the HTTP method name for a given request. By default this returns based on a lookup on
            {@link #actionMethods}.
            @param {Ext.data.Request} request The request object
            @return {String} The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.proxy.Ajax.extend" -->
        <member name="P:Ext.data.proxy.AjaxConfig.headers">
            <summary>
            Any headers to add to the Ajax request. Defaults to undefined.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Client.clear">
            <summary>
            Abstract function that must be implemented by each ClientProxy subclass. This should purge all record data
            from the client side storage, as well as removing any supporting data (such as lists of record IDs)
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Client.alternateClassName">
            <summary>
            @author Ed Spencer
            Base class for any client-side storage. Used as a superclass for {@link Ext.data.proxy.Memory Memory} and
            {@link Ext.data.proxy.WebStorage Web Storage} proxies. Do not use directly, use one of the subclasses instead.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Client.extend">
            <summary>
            @author Ed Spencer
            Base class for any client-side storage. Used as a superclass for {@link Ext.data.proxy.Memory Memory} and
            {@link Ext.data.proxy.WebStorage Web Storage} proxies. Do not use directly, use one of the subclasses instead.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Direct.applyEncoding(System.Object)">
            <summary>
            Inherit docs. We don't apply any encoding here because
            all of the direct requests go out as jsonData
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Direct.alternateClassName">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Direct.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Direct.paramOrderRe">
            <summary>
            @cfg {Object} extraParams
            Extra parameters that will be included on every read request. Individual requests with params
            of the same name will override these params when they are in conflict.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Direct.paramsAsHash">
            <summary>
            @cfg {Boolean} paramsAsHash
            Send parameters as a collection of named arguments (defaults to true).
            Providing a {@link #paramOrder} nullifies this configuration.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.DirectConfig.api">
            <summary>
            The same as {@link Ext.data.proxy.Server#api}, however instead of providing urls, you should provide a direct
            function call.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.DirectConfig.directFn">
            <summary>
            Function to call when executing a request.  directFn is a simple alternative to defining the api configuration-parameter
            for Store's which will not implement a full CRUD api.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.DirectConfig.extraParams">
            <summary>
            Extra parameters that will be included on every read request. Individual requests with params
            of the same name will override these params when they are in conflict.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.DirectConfig.paramOrder">
            <summary>
            Defaults to undefined. A list of params to be executed server side.  Specify the params in the order in
            which they must be executed on the server-side as either (1) an Array of String values, or (2) a String
            of params delimited by either whitespace, comma, or pipe. For example, any of the following would be
            acceptable:
            *
            paramOrder: ['param1','param2','param3']
            paramOrder: 'param1 param2 param3'
            paramOrder: 'param1,param2,param3'
            paramOrder: 'param1|param2|param'
            </summary>
        </member>
        <member name="P:Ext.data.proxy.DirectConfig.paramsAsHash">
            <summary>
            Send parameters as a collection of named arguments (defaults to true).
            Providing a {@link #paramOrder} nullifies this configuration.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.JsonP.abort">
            <summary>
            Aborts the current server request if one is currently running
            </summary>
        </member>
        <member name="M:Ext.data.proxy.JsonP.buildUrl(Ext.data.Request)">
            <summary>
            Generates a url based on a given Ext.data.Request object. Adds the params and callback function name to the url
            @param {Ext.data.Request} request The request object
            @return {String} The url
            </summary>
        </member>
        <member name="M:Ext.data.proxy.JsonP.#ctor">
            <summary>
            @cfg {Boolean} autoAppendParams
            True to automatically append the request's params to the generated url. Defaults to true
            </summary>
        </member>
        <member name="M:Ext.data.proxy.JsonP.createRequestCallback(Ext.data.Request,Ext.data.Operation,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            @private
            Creates and returns the function that is called when the request has completed. The returned function
            should accept a Response object, which contains the response to be read by the configured Reader.
            The third argument is the callback that should be called after the request has been completed and the Reader has decoded
            the response. This callback will typically be the callback passed by a store, e.g. in proxy.read(operation, theCallback, scope)
            theCallback refers to the callback argument received by this function.
            See {@link #doRequest} for details.
            @param {Ext.data.Request} request The Request object
            @param {Ext.data.Operation} operation The Operation being executed
            @param {Function} callback The callback function to be called when the request completes. This is usually the callback
            passed to doRequest
            @param {Object} scope The scope in which to execute the callback function
            @return {Function} The callback function
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.data.proxy.JsonP.doRequest(Ext.data.Operation,SharpKit.JavaScript.JsAction,System.Object)" -->
        <member name="M:Ext.data.proxy.JsonP.encodeRecords(System.Object)">
            <summary>
            Encodes an array of records into a string suitable to be appended to the script src url. This is broken out into
            its own function so that it can be easily overridden.
            @param {Ext.data.Model[]} records The records array
            @return {String} The encoded records string
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.proxy.JsonP.alternateClassName" -->
        <member name="P:Ext.data.proxy.JsonP.autoAppendParams">
            <summary>
            @cfg {Boolean} autoAppendParams
            True to automatically append the request's params to the generated url. Defaults to true
            </summary>
        </member>
        <member name="P:Ext.data.proxy.JsonP.callbackKey">
            <summary>
            @cfg {String} callbackKey
            See {@link Ext.data.JsonP#callbackKey}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.proxy.JsonP.extend" -->
        <member name="P:Ext.data.proxy.JsonP.recordParam">
            <summary>
            @cfg {String} recordParam
            The param name to use when passing records to the server (e.g. 'records=someEncodedRecordString'). Defaults to
            'records'
            </summary>
        </member>
        <member name="P:Ext.data.proxy.JsonPConfig.autoAppendParams">
            <summary>
            True to automatically append the request's params to the generated url. Defaults to true
            </summary>
        </member>
        <member name="P:Ext.data.proxy.JsonPConfig.callbackKey">
            <summary>
            See {@link Ext.data.JsonP#callbackKey}.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.JsonPConfig.recordParam">
            <summary>
            The param name to use when passing records to the server (e.g. 'records=someEncodedRecordString'). Defaults to
            'records'
            </summary>
        </member>
        <member name="P:Ext.data.proxy.LocalStorage.alias">
            <summary>
            @author Ed Spencer
            *
            The LocalStorageProxy uses the new HTML5 localStorage API to save {@link Ext.data.Model Model} data locally on the
            client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
            LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
            *
            localStorage is extremely useful for saving user-specific information without needing to build server-side
            infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
            searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
            *
            Ext.define('Search', {
            fields: ['id', 'query'],
            extend: 'Ext.data.Model',
            proxy: {
            type: 'localstorage',
            id  : 'twitter-Searches'
            }
            });
            *
            Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
            pass to the LocalStorage proxy is an {@link #id}. This is important as it separates the Model data in this Proxy from
            all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
            LocalStorageProxy to manage the saved Search data.
            *
            Saving our data into localStorage is easy and would usually be done with a {@link Ext.data.Store Store}:
            *
            //our Store automatically picks up the LocalStorageProxy defined on the Search model
            var store = Ext.create('Ext.data.Store', {
            model: "Search"
            });
            *
            //loads any existing Search data from localStorage
            store.load();
            *
            //now add some Searches
            store.add({query: 'Sencha Touch'});
            store.add({query: 'Ext JS'});
            *
            //finally, save our Search data to localStorage
            store.sync();
            *
            The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
            and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
            *
            var search = Ext.create('Search', {query: 'Sencha Animator'});
            *
            //uses the configured LocalStorageProxy to save the new Search to localStorage
            search.save();
            *
            # Limitations
            *
            If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
            storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
            object.
            *
            It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
            attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.LocalStorage.extend">
            <summary>
            @author Ed Spencer
            *
            The LocalStorageProxy uses the new HTML5 localStorage API to save {@link Ext.data.Model Model} data locally on the
            client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
            LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
            *
            localStorage is extremely useful for saving user-specific information without needing to build server-side
            infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
            searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
            *
            Ext.define('Search', {
            fields: ['id', 'query'],
            extend: 'Ext.data.Model',
            proxy: {
            type: 'localstorage',
            id  : 'twitter-Searches'
            }
            });
            *
            Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
            pass to the LocalStorage proxy is an {@link #id}. This is important as it separates the Model data in this Proxy from
            all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
            LocalStorageProxy to manage the saved Search data.
            *
            Saving our data into localStorage is easy and would usually be done with a {@link Ext.data.Store Store}:
            *
            //our Store automatically picks up the LocalStorageProxy defined on the Search model
            var store = Ext.create('Ext.data.Store', {
            model: "Search"
            });
            *
            //loads any existing Search data from localStorage
            store.load();
            *
            //now add some Searches
            store.add({query: 'Sencha Touch'});
            store.add({query: 'Ext JS'});
            *
            //finally, save our Search data to localStorage
            store.sync();
            *
            The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
            and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
            *
            var search = Ext.create('Search', {query: 'Sencha Animator'});
            *
            //uses the configured LocalStorageProxy to save the new Search to localStorage
            search.save();
            *
            # Limitations
            *
            If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
            storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
            object.
            *
            It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
            attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Memory.#ctor(System.Object)">
            <summary>
            @cfg {Ext.data.Model[]} data
            Optional array of Records to load into the Proxy
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Memory.read(Ext.data.Operation,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Reads data from the configured {@link #data} object. Uses the Proxy's {@link #reader}, if present.
            @param {Ext.data.Operation} operation The read Operation
            @param {Function} callback The callback to call when reading has completed
            @param {Object} scope The scope to call the callback function in
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Memory.alias">
            <summary>
            @author Ed Spencer
            *
            In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
            every page refresh.
            *
            Usually this Proxy isn't used directly, serving instead as a helper to a {@link Ext.data.Store Store} where a reader
            is required to load data. For example, say we have a Store for a User model and have some inline data we want to
            load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
            Store:
            *
            //this is the model we will be using in the store
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'id',    type: 'int'},
            {name: 'name',  type: 'string'},
            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
            ]
            });
            *
            //this data does not line up to our model fields - the phone field is called phoneNumber
            var data = {
            users: [
            {
            id: 1,
            name: 'Ed Spencer',
            phoneNumber: '555 1234'
            },
            {
            id: 2,
            name: 'Abe Elias',
            phoneNumber: '666 1234'
            }
            ]
            };
            *
            //note how we set the 'root' in the reader to match the data structure above
            var store = Ext.create('Ext.data.Store', {
            autoLoad: true,
            model: 'User',
            data : data,
            proxy: {
            type: 'memory',
            reader: {
            type: 'json',
            root: 'users'
            }
            }
            });
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Memory.extend">
            <summary>
            @author Ed Spencer
            *
            In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
            every page refresh.
            *
            Usually this Proxy isn't used directly, serving instead as a helper to a {@link Ext.data.Store Store} where a reader
            is required to load data. For example, say we have a Store for a User model and have some inline data we want to
            load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
            Store:
            *
            //this is the model we will be using in the store
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: [
            {name: 'id',    type: 'int'},
            {name: 'name',  type: 'string'},
            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
            ]
            });
            *
            //this data does not line up to our model fields - the phone field is called phoneNumber
            var data = {
            users: [
            {
            id: 1,
            name: 'Ed Spencer',
            phoneNumber: '555 1234'
            },
            {
            id: 2,
            name: 'Abe Elias',
            phoneNumber: '666 1234'
            }
            ]
            };
            *
            //note how we set the 'root' in the reader to match the data structure above
            var store = Ext.create('Ext.data.Store', {
            autoLoad: true,
            model: 'User',
            data : data,
            proxy: {
            type: 'memory',
            reader: {
            type: 'json',
            root: 'users'
            }
            }
            });
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.batch(System.Object,System.Object)">
            <summary>
            Performs a batch of {@link Ext.data.Operation Operations}, in the order specified by {@link #batchOrder}. Used
            internally by {@link Ext.data.Store}'s {@link Ext.data.Store#sync sync} method. Example usage:
            *
            myProxy.batch({
            create : [myModel1, myModel2],
            update : [myModel3],
            destroy: [myModel4, myModel5]
            });
            *
            Where the myModel* above are {@link Ext.data.Model Model} instances - in this case 1 and 2 are new instances and
            have not been saved before, 3 has been saved previously but needs to be updated, and 4 and 5 have already been
            saved but should now be destroyed.
            *
            @param {Object} operations Object containing the Model instances to act upon, keyed by action name
            @param {Object} listeners (optional) listeners object passed straight through to the Batch -
            see {@link Ext.data.Batch}
            @return {Ext.data.Batch} The newly created Ext.data.Batch object
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.#ctor(System.Object)">
            <summary>
            Creates the Proxy
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.getModel">
            <summary>
            Returns the model attached to this Proxy
            @return {Ext.data.Model} The model
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.getReader">
            <summary>
            Returns the reader currently attached to this proxy instance
            @return {Ext.data.reader.Reader} The Reader instance
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.getWriter">
            <summary>
            Returns the writer currently attached to this proxy instance
            @return {Ext.data.writer.Writer} The Writer instance
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.setModel(System.Object,System.Boolean)">
            <summary>
            Sets the model associated with this proxy. This will only usually be called by a Store
            *
            @param {String/Ext.data.Model} model The new model. Can be either the model name string,
            or a reference to the model's constructor
            @param {Boolean} setOnStore Sets the new model on the associated Store, if one is present
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.setReader(System.Object)">
            <summary>
            Sets the Proxy's Reader by string, config object or Reader instance
            *
            @param {String/Object/Ext.data.reader.Reader} reader The new Reader, which can be either a type string,
            a configuration object or an Ext.data.reader.Reader instance
            @return {Ext.data.reader.Reader} The attached Reader object
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Proxy.setWriter(System.Object)">
            <summary>
            Sets the Proxy's Writer by string, config object or Writer instance
            *
            @param {String/Object/Ext.data.writer.Writer} writer The new Writer, which can be either a type string,
            a configuration object or an Ext.data.writer.Writer instance
            @return {Ext.data.writer.Writer} The attached Writer object
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.alias">
            <summary>
            @author Ed Spencer
            *
            Proxies are used by {@link Ext.data.Store Stores} to handle the loading and saving of {@link Ext.data.Model Model}
            data. Usually developers will not need to create or interact with proxies directly.
            *
            # Types of Proxy
            *
            There are two main types of Proxy - {@link Ext.data.proxy.Client Client} and {@link Ext.data.proxy.Server Server}.
            The Client proxies save their data locally and include the following subclasses:
            *
            - {@link Ext.data.proxy.LocalStorage LocalStorageProxy} - saves its data to localStorage if the browser supports it
            - {@link Ext.data.proxy.SessionStorage SessionStorageProxy} - saves its data to sessionStorage if the browsers supports it
            - {@link Ext.data.proxy.Memory MemoryProxy} - holds data in memory only, any data is lost when the page is refreshed
            *
            The Server proxies save their data by sending requests to some remote server. These proxies include:
            *
            - {@link Ext.data.proxy.Ajax Ajax} - sends requests to a server on the same domain
            - {@link Ext.data.proxy.JsonP JsonP} - uses JSON-P to send requests to a server on a different domain
            - {@link Ext.data.proxy.Direct Direct} - uses {@link Ext.direct.Manager} to send requests
            *
            Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
            operations are mapped to the methods {@link #create}, {@link #read}, {@link #update} and {@link #destroy}
            respectively. Each Proxy subclass implements these functions.
            *
            The CRUD methods each expect an {@link Ext.data.Operation Operation} object as the sole argument. The Operation
            encapsulates information about the action the Store wishes to perform, the {@link Ext.data.Model model} instances
            that are to be modified, etc. See the {@link Ext.data.Operation Operation} documentation for more details. Each CRUD
            method also accepts a callback function to be called asynchronously on completion.
            *
            Proxies also support batching of Operations via a {@link Ext.data.Batch batch} object, invoked by the {@link #batch}
            method.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.batchActions">
            <summary>
            @cfg {Boolean} batchActions
            True to batch actions of a particular type when synchronizing the store. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.batchOrder">
            <summary>
            @cfg {String} batchOrder
            Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
            order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.defaultReaderType">
            <summary>
            @cfg {String} defaultReaderType
            The default registered reader type. Defaults to 'json'.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.defaultWriterType">
            <summary>
            @cfg {String} defaultWriterType
            The default registered writer type. Defaults to 'json'.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.isProxy">
            <summary>
            @cfg {Object/String/Ext.data.writer.Writer} writer
            The Ext.data.writer.Writer to use to encode any request sent to the server or saved to client. This can either be
            a Writer instance, a config object or just a valid Writer type name (e.g. 'json', 'xml').
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.Model">
            <summary>
            Returns the model attached to this Proxy
            @return {Ext.data.Model} The model
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.Reader">
            <summary>
            Sets the Proxy's Reader by string, config object or Reader instance
            *
            @param {String/Object/Ext.data.reader.Reader} reader The new Reader, which can be either a type string,
            a configuration object or an Ext.data.reader.Reader instance
            @return {Ext.data.reader.Reader} The attached Reader object
            Returns the reader currently attached to this proxy instance
            @return {Ext.data.reader.Reader} The Reader instance
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Proxy.Writer">
            <summary>
            Sets the Proxy's Writer by string, config object or Writer instance
            *
            @param {String/Object/Ext.data.writer.Writer} writer The new Writer, which can be either a type string,
            a configuration object or an Ext.data.writer.Writer instance
            @return {Ext.data.writer.Writer} The attached Writer object
            Returns the writer currently attached to this proxy instance
            @return {Ext.data.writer.Writer} The Writer instance
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.batchActions">
            <summary>
            True to batch actions of a particular type when synchronizing the store. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.batchOrder">
            <summary>
            Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
            order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.defaultReaderType">
            <summary>
            The default registered reader type. Defaults to 'json'.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.defaultWriterType">
            <summary>
            The default registered writer type. Defaults to 'json'.
            @private
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.model">
            <summary>
            The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
            Model constructor. Required.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.reader">
            <summary>
            The Ext.data.reader.Reader to use to decode the server's response or data read from client. This can either be a
            Reader instance, a config object or just a valid Reader type name (e.g. 'json', 'xml').
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ProxyConfig.writer">
            <summary>
            The Ext.data.writer.Writer to use to encode any request sent to the server or saved to client. This can either be
            a Writer instance, a config object or just a valid Writer type name (e.g. 'json', 'xml').
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Rest.buildUrl(System.Object)">
            <summary>
            Specialized version of buildUrl that incorporates the {@link #appendId} and {@link #format} options into the
            generated url. Override this to provide further customizations, but remember to call the superclass buildUrl so
            that additional parameters like the cache buster string are appended.
            @param {Object} request
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Rest.alternateClassName">
            <summary>
            @author Ed Spencer
            *
            RestProxy is a specialization of the {@link Ext.data.proxy.Ajax AjaxProxy} which simply maps the four actions
            (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a {@link Ext.data.Model Model}
            with an inline RestProxy
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'email'],
            *
            proxy: {
            type: 'rest',
            url : '/users'
            }
            });
            *
            Now we can create a new User instance and save it via the RestProxy. Doing this will cause the Proxy to send a POST
            request to '/users':
            *
            var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
            *
            user.save(); //POST /users
            *
            Let's expand this a little and provide a callback for the {@link Ext.data.Model#save} call to update the Model once
            it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
            *
            user.save({
            success: function(user) {
            user.set('name', 'Khan Noonien Singh');
            *
            user.save(); //PUT /users/123
            }
            });
            *
            Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
            relevant url for that user. Now let's delete this user, which will use the DELETE method:
            *
            user.destroy(); //DELETE /users/123
            *
            Finally, when we perform a load of a Model or Store, RestProxy will use the GET method:
            *
            //1. Load via Store
            *
            //the Store automatically picks up the Proxy from the User model
            var store = Ext.create('Ext.data.Store', {
            model: 'User'
            });
            *
            store.load(); //GET /users
            *
            //2. Load directly from the Model
            *
            //GET /users/123
            Ext.ModelManager.getModel('User').load(123, {
            success: function(user) {
            console.log(user.getId()); //outputs 123
            }
            });
            *
            # Url generation
            *
            RestProxy is able to automatically generate the urls above based on two configuration options - {@link #appendId} and
            {@link #format}. If appendId is true (it is by default) then RestProxy will automatically append the ID of the Model
            instance in question to the configured url, resulting in the '/users/123' that we saw above.
            *
            If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
            RestProxy will automatically insert a '/' before the ID if one is not already present.
            *
            new Ext.data.proxy.Rest({
            url: '/users',
            appendId: true //default
            });
            *
            // Collection url: /users
            // Instance url  : /users/123
            *
            RestProxy can also optionally append a format string to the end of any generated url:
            *
            new Ext.data.proxy.Rest({
            url: '/users',
            format: 'json'
            });
            *
            // Collection url: /users.json
            // Instance url  : /users/123.json
            *
            If further customization is needed, simply implement the {@link #buildUrl} method and add your custom generated url
            onto the {@link Ext.data.Request Request} object that is passed to buildUrl. See [RestProxy's implementation][1] for
            an example of how to achieve this.
            *
            Note that RestProxy inherits from {@link Ext.data.proxy.Ajax AjaxProxy}, which already injects all of the sorter,
            filter, group and paging options into the generated url. See the {@link Ext.data.proxy.Ajax AjaxProxy docs} for more
            details.
            *
            [1]: source/RestProxy.html#method-Ext.data.proxy.Rest-buildUrl
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Rest.appendId">
            <summary>
            @cfg {Boolean} appendId
            True to automatically append the ID of a Model instance when performing a request based on that single instance.
            See RestProxy intro docs for more details. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Rest.batchActions">
            <summary>
            @cfg {Boolean} batchActions
            True to batch actions of a particular type when synchronizing the store. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Rest.extend">
            <summary>
            @author Ed Spencer
            *
            RestProxy is a specialization of the {@link Ext.data.proxy.Ajax AjaxProxy} which simply maps the four actions
            (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a {@link Ext.data.Model Model}
            with an inline RestProxy
            *
            Ext.define('User', {
            extend: 'Ext.data.Model',
            fields: ['id', 'name', 'email'],
            *
            proxy: {
            type: 'rest',
            url : '/users'
            }
            });
            *
            Now we can create a new User instance and save it via the RestProxy. Doing this will cause the Proxy to send a POST
            request to '/users':
            *
            var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
            *
            user.save(); //POST /users
            *
            Let's expand this a little and provide a callback for the {@link Ext.data.Model#save} call to update the Model once
            it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
            *
            user.save({
            success: function(user) {
            user.set('name', 'Khan Noonien Singh');
            *
            user.save(); //PUT /users/123
            }
            });
            *
            Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
            relevant url for that user. Now let's delete this user, which will use the DELETE method:
            *
            user.destroy(); //DELETE /users/123
            *
            Finally, when we perform a load of a Model or Store, RestProxy will use the GET method:
            *
            //1. Load via Store
            *
            //the Store automatically picks up the Proxy from the User model
            var store = Ext.create('Ext.data.Store', {
            model: 'User'
            });
            *
            store.load(); //GET /users
            *
            //2. Load directly from the Model
            *
            //GET /users/123
            Ext.ModelManager.getModel('User').load(123, {
            success: function(user) {
            console.log(user.getId()); //outputs 123
            }
            });
            *
            # Url generation
            *
            RestProxy is able to automatically generate the urls above based on two configuration options - {@link #appendId} and
            {@link #format}. If appendId is true (it is by default) then RestProxy will automatically append the ID of the Model
            instance in question to the configured url, resulting in the '/users/123' that we saw above.
            *
            If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
            RestProxy will automatically insert a '/' before the ID if one is not already present.
            *
            new Ext.data.proxy.Rest({
            url: '/users',
            appendId: true //default
            });
            *
            // Collection url: /users
            // Instance url  : /users/123
            *
            RestProxy can also optionally append a format string to the end of any generated url:
            *
            new Ext.data.proxy.Rest({
            url: '/users',
            format: 'json'
            });
            *
            // Collection url: /users.json
            // Instance url  : /users/123.json
            *
            If further customization is needed, simply implement the {@link #buildUrl} method and add your custom generated url
            onto the {@link Ext.data.Request Request} object that is passed to buildUrl. See [RestProxy's implementation][1] for
            an example of how to achieve this.
            *
            Note that RestProxy inherits from {@link Ext.data.proxy.Ajax AjaxProxy}, which already injects all of the sorter,
            filter, group and paging options into the generated url. See the {@link Ext.data.proxy.Ajax AjaxProxy docs} for more
            details.
            *
            [1]: source/RestProxy.html#method-Ext.data.proxy.Rest-buildUrl
            </summary>
        </member>
        <member name="P:Ext.data.proxy.RestConfig.appendId">
            <summary>
            True to automatically append the ID of a Model instance when performing a request based on that single instance.
            See RestProxy intro docs for more details. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.RestConfig.batchActions">
            <summary>
            True to batch actions of a particular type when synchronizing the store. Defaults to false.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.RestConfig.format">
            <summary>
            Optional data format to send to the server when making any request (e.g. 'json'). See the RestProxy intro docs
            for full details. Defaults to undefined.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.applyEncoding(SharpKit.JavaScript.JsArray)">
            <summary>
            Encode any values being sent to the server. Can be overridden in subclasses.
            @private
            @param {Array} An array of sorters/filters.
            @return {Object} The encoded value
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.buildRequest(Ext.data.Operation)">
            <summary>
            Creates and returns an Ext.data.Request object based on the options passed by the {@link Ext.data.Store Store}
            that this Proxy is attached to.
            @param {Ext.data.Operation} operation The {@link Ext.data.Operation Operation} object to execute
            @return {Ext.data.Request} The request object
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.buildUrl(Ext.data.Request)">
            <summary>
            Generates a url based on a given Ext.data.Request object. By default, ServerProxy's buildUrl will add the
            cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
            @param {Ext.data.Request} request The request object
            @return {String} The url
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.#ctor(System.Object)">
            <summary>
            @cfg {Object} api
            Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
            *
            api: {
            create  : undefined,
            read    : undefined,
            update  : undefined,
            destroy : undefined
            }
            *
            The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
            {@link #api} property, or if undefined default to the configured
            {@link Ext.data.Store}.{@link Ext.data.proxy.Server#url url}.
            *
            For example:
            *
            api: {
            create  : '/controller/new',
            read    : '/controller/load',
            update  : '/controller/update',
            destroy : '/controller/destroy_action'
            }
            *
            If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
            configured {@link Ext.data.proxy.Server#url url}.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.doRequest(Ext.data.Operation,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            In ServerProxy subclasses, the {@link #create}, {@link #read}, {@link #update} and {@link #destroy} methods all
            pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see {@link
            Ext.data.proxy.JsonP} and {@link Ext.data.proxy.Ajax} for examples. This method carries the same signature as
            each of the methods that delegate to it.
            *
            @param {Ext.data.Operation} operation The Ext.data.Operation object
            @param {Function} callback The callback function to call when the Operation has completed
            @param {Object} scope The scope in which to execute the callback
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.encodeFilters(System.Object)">
            <summary>
            Encodes the array of {@link Ext.util.Filter} objects into a string to be sent in the request url. By default,
            this simply JSON-encodes the filter data
            @param {Ext.util.Filter[]} filters The array of {@link Ext.util.Filter Filter} objects
            @return {String} The encoded filters
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.encodeSorters(System.Object)">
            <summary>
            Encodes the array of {@link Ext.util.Sorter} objects into a string to be sent in the request url. By default,
            this simply JSON-encodes the sorter data
            @param {Ext.util.Sorter[]} sorters The array of {@link Ext.util.Sorter Sorter} objects
            @return {String} The encoded sorters
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.extractResponseData(System.Object)">
            <summary>
            Template method to allow subclasses to specify how to get the response for the reader.
            @private
            @param {Object} response The server response
            @return {Object} The response data to be used by the reader
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.getParams(System.Object)">
            <summary>
            @private
            Copy any sorters, filters etc into the params so they can be sent over the wire
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.getUrl(Ext.data.Request)">
            <summary>
            Get the url for the request taking into account the order of priority,
            - The request
            - The api
            - The url
            @private
            @param {Ext.data.Request} request The request
            @return {String} The url
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.onDestroy">
            <summary>
            Optional callback function which can be used to clean up after a request has been completed.
            @param {Ext.data.Request} request The Request object
            @param {Boolean} success True if the request was successful
            @method
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.setException(Ext.data.Operation,System.Object)">
            <summary>
            Sets up an exception on the operation
            @private
            @param {Ext.data.Operation} operation The operation
            @param {Object} response The response
            </summary>
        </member>
        <member name="M:Ext.data.proxy.Server.setExtraParam(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Sets a value in the underlying {@link #extraParams}.
            @param {String} name The key for the new value
            @param {Object} value The value
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.alias">
            <summary>
            @author Ed Spencer
            *
            ServerProxy is a superclass of {@link Ext.data.proxy.JsonP JsonPProxy} and {@link Ext.data.proxy.Ajax AjaxProxy}, and
            would not usually be used directly.
            *
            ServerProxy should ideally be named HttpProxy as it is a superclass for all HTTP proxies - for Ext JS 4.x it has been
            called ServerProxy to enable any 3.x applications that reference the HttpProxy to continue to work (HttpProxy is now
            an alias of AjaxProxy).
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.cacheString">
            <summary>
            @cfg {String} cacheString
            The name of the cache param added to the url when using noCache. Defaults to "_dc".
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.directionParam">
            <summary>
            @cfg {String} directionParam
            The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
            true.** Defaults to 'dir'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.extend">
            <summary>
            @author Ed Spencer
            *
            ServerProxy is a superclass of {@link Ext.data.proxy.JsonP JsonPProxy} and {@link Ext.data.proxy.Ajax AjaxProxy}, and
            would not usually be used directly.
            *
            ServerProxy should ideally be named HttpProxy as it is a superclass for all HTTP proxies - for Ext JS 4.x it has been
            called ServerProxy to enable any 3.x applications that reference the HttpProxy to continue to work (HttpProxy is now
            an alias of AjaxProxy).
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.filterParam">
            <summary>
            @cfg {String} filterParam
            The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't
            want to send a filter parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.groupParam">
            <summary>
            @cfg {String} groupParam
            The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't
            want to send a group parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.limitParam">
            <summary>
            @cfg {String} limitParam
            The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't
            want to send a limit parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.noCache">
            <summary>
            @cfg {Boolean} noCache
            Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.pageParam">
            <summary>
            @cfg {String} pageParam
            The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't
            want to send a page parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.simpleSortMode">
            <summary>
            @cfg {Boolean} simpleSortMode
            Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
            remote sort is requested. The directionParam and sortParam will be sent with the property name and either 'ASC'
            or 'DESC'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.sortParam">
            <summary>
            @cfg {String} sortParam
            The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't
            want to send a sort parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.startParam">
            <summary>
            @cfg {String} startParam
            The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't
            want to send a start parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.Server.timeout">
            <summary>
            @cfg {Number} timeout
            The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.cacheString">
            <summary>
            The name of the cache param added to the url when using noCache. Defaults to "_dc".
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.directionParam">
            <summary>
            The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
            true.** Defaults to 'dir'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.extraParams">
            <summary>
            Extra parameters that will be included on every request. Individual requests with params of the same name
            will override these params when they are in conflict.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.filterParam">
            <summary>
            The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't
            want to send a filter parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.groupParam">
            <summary>
            The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't
            want to send a group parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.limitParam">
            <summary>
            The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't
            want to send a limit parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.noCache">
            <summary>
            Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.pageParam">
            <summary>
            The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't
            want to send a page parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.simpleSortMode">
            <summary>
            Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
            remote sort is requested. The directionParam and sortParam will be sent with the property name and either 'ASC'
            or 'DESC'.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.sortParam">
            <summary>
            The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't
            want to send a sort parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.startParam">
            <summary>
            The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't
            want to send a start parameter.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.timeout">
            <summary>
            The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
            </summary>
        </member>
        <member name="P:Ext.data.proxy.ServerConfig.url">
            <summary>
            The URL from which to request the data object.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.SessionStorage.alias">
            <summary>
            @author Ed Spencer
            *
            Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
            where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
            unique ID which is used as a key in which all record data are stored in the session storage object.
            *
            It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
            attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
            *
            Proxies are almost always used with a {@link Ext.data.Store store}:
            *
            new Ext.data.Store({
            proxy: {
            type: 'sessionstorage',
            id  : 'myProxyKey'
            }
            });
            *
            Alternatively you can instantiate the Proxy directly:
            *
            new Ext.data.proxy.SessionStorage({
            id  : 'myOtherProxyKey'
            });
            *
            Note that session storage is different to local storage (see {@link Ext.data.proxy.LocalStorage}) - if a browser
            session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
            don't affect the {@link Ext.data.proxy.LocalStorage} - the data are preserved.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.SessionStorage.extend">
            <summary>
            @author Ed Spencer
            *
            Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
            where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
            unique ID which is used as a key in which all record data are stored in the session storage object.
            *
            It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
            attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
            *
            Proxies are almost always used with a {@link Ext.data.Store store}:
            *
            new Ext.data.Store({
            proxy: {
            type: 'sessionstorage',
            id  : 'myProxyKey'
            }
            });
            *
            Alternatively you can instantiate the Proxy directly:
            *
            new Ext.data.proxy.SessionStorage({
            id  : 'myOtherProxyKey'
            });
            *
            Note that session storage is different to local storage (see {@link Ext.data.proxy.LocalStorage}) - if a browser
            session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
            don't affect the {@link Ext.data.proxy.LocalStorage} - the data are preserved.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.clear">
            <summary>
            Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the
            storage object.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.#ctor(System.Object)">
            <summary>
            Creates the proxy, throws an error if local storage is not supported in the current browser.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getIds">
            <summary>
            @private
            Returns the array of record IDs stored in this Proxy
            @return {Number[]} The record IDs. Each is cast as a Number
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getNextId">
            <summary>
            @private
            Returns the next numerical ID that can be used when realizing a model instance (see getRecordCounterKey).
            Increments the counter.
            @return {Number} The id
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getRecord(SharpKit.JavaScript.JsString)">
            <summary>
            @private
            Fetches a model instance from the Proxy by ID. Runs each field's decode function (if present) to decode the data.
            @param {String} id The record's unique ID
            @return {Ext.data.Model} The model instance
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getRecordCounterKey">
            <summary>
            @private
            Returns the unique key used to store the current record counter for this proxy. This is used internally when
            realizing models (creating them when they used to be phantoms), in order to give each model instance a unique id.
            @return {String} The counter key
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getRecordKey(System.Object)">
            <summary>
            @private
            Given the id of a record, returns a unique string based on that id and the id of this proxy. This is used when
            storing data in the local storage object and should prevent naming collisions.
            @param {String/Number/Ext.data.Model} id The record id, or a Model instance
            @return {String} The unique key for this record
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.getStorageObject">
            <summary>
            @private
            Abstract function which should return the storage object that data will be saved to. This must be implemented
            in each subclass.
            @return {Object} The storage object
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.initialize">
            <summary>
            @private
            Sets up the Proxy by claiming the key in the storage object that corresponds to the unique id of this Proxy. Called
            automatically by the constructor, this should not need to be called again unless {@link #clear} has been called.
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.removeRecord(System.Object,System.Object)">
            <summary>
            @private
            Physically removes a given record from the local storage. Used internally by {@link #destroy}, which you should
            use instead because it updates the list of currently-stored record ids
            @param {String/Number/Ext.data.Model} id The id of the record to remove, or an Ext.data.Model instance
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.setIds(System.Object)">
            <summary>
            @private
            Saves the array of ids representing the set of all records in the Proxy
            @param {Number[]} ids The ids to set
            </summary>
        </member>
        <member name="M:Ext.data.proxy.WebStorage.setRecord(Ext.data.Model,SharpKit.JavaScript.JsString)">
            <summary>
            Saves the given record in the Proxy. Runs each field's encode function (if present) to encode the data.
            @param {Ext.data.Model} record The model instance
            @param {String} id The id to save the record under (defaults to the value of the record's getId() function)
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.alternateClassName">
            <summary>
            @author Ed Spencer
            *
            WebStorageProxy is simply a superclass for the {@link Ext.data.proxy.LocalStorage localStorage} and {@link
            Ext.data.proxy.SessionStorage sessionStorage} proxies. It uses the new HTML5 key/value client-side storage objects to
            save {@link Ext.data.Model model instances} for offline use.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.extend">
            <summary>
            @author Ed Spencer
            *
            WebStorageProxy is simply a superclass for the {@link Ext.data.proxy.LocalStorage localStorage} and {@link
            Ext.data.proxy.SessionStorage sessionStorage} proxies. It uses the new HTML5 key/value client-side storage objects to
            save {@link Ext.data.Model model instances} for offline use.
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.Ids">
            <summary>
            @private
            Saves the array of ids representing the set of all records in the Proxy
            @param {Number[]} ids The ids to set
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.NextId">
            <summary>
            @private
            Returns the next numerical ID that can be used when realizing a model instance (see getRecordCounterKey).
            Increments the counter.
            @return {Number} The id
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.RecordCounterKey">
            <summary>
            @private
            Returns the unique key used to store the current record counter for this proxy. This is used internally when
            realizing models (creating them when they used to be phantoms), in order to give each model instance a unique id.
            @return {String} The counter key
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorage.StorageObject">
            <summary>
            @private
            Abstract function which should return the storage object that data will be saved to. This must be implemented
            in each subclass.
            @return {Object} The storage object
            </summary>
        </member>
        <member name="P:Ext.data.proxy.WebStorageConfig.id">
            <summary>
            The unique ID used as the key in which all record data are stored in the local storage object.
            </summary>
        </member>
        <member name="M:Ext.data.reader.Array.buildExtractors">
            <summary>
            @private
            Most of the work is done for us by JsonReader, but we need to overwrite the field accessors to just
            reference the correct position in the array.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Array.alternateClassName">
            <summary>
            @author Ed Spencer
            @class Ext.data.reader.Array
            @extends Ext.data.reader.Json
            <p>Data reader class to create an Array of {@link Ext.data.Model} objects from an Array.
            Each element of that Array represents a row of data fields. The
            fields are pulled into a Record object using as a subscript, the <code>mapping</code> property
            of the field definition if it exists, or the field's ordinal position in the definition.</p>
            <p><u>Example code:</u></p>
            <pre><code>
            Employee = Ext.define('Employee', {
            extend: 'Ext.data.Model',
            fields: [
            'id',
            {name: 'name', mapping: 1},         // "mapping" only needed if an "id" field is present which
            {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
            ]
            });
            var myReader = new Ext.data.reader.Array({
            model: 'Employee'
            }, Employee);
            </code></pre>
            <p>This would consume an Array like this:</p>
            <pre><code>
            [ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]
            </code></pre>
            @constructor
            Create a new ArrayReader
            @param {Object} meta Metadata configuration options.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Array.extend">
            <summary>
            @author Ed Spencer
            @class Ext.data.reader.Array
            @extends Ext.data.reader.Json
            <p>Data reader class to create an Array of {@link Ext.data.Model} objects from an Array.
            Each element of that Array represents a row of data fields. The
            fields are pulled into a Record object using as a subscript, the <code>mapping</code> property
            of the field definition if it exists, or the field's ordinal position in the definition.</p>
            <p><u>Example code:</u></p>
            <pre><code>
            Employee = Ext.define('Employee', {
            extend: 'Ext.data.Model',
            fields: [
            'id',
            {name: 'name', mapping: 1},         // "mapping" only needed if an "id" field is present which
            {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
            ]
            });
            var myReader = new Ext.data.reader.Array({
            model: 'Employee'
            }, Employee);
            </code></pre>
            <p>This would consume an Array like this:</p>
            <pre><code>
            [ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]
            </code></pre>
            @constructor
            Create a new ArrayReader
            @param {Object} meta Metadata configuration options.
            </summary>
        </member>
        <member name="M:Ext.data.reader.Json.extractData(System.Object)">
            <summary>
            @private
            We're just preparing the data for the superclass by pulling out the record objects we want. If a {@link #record}
            was specified we have to pull those out of the larger JSON object, which is most of what this function is doing
            @param {Object} root The JSON root node
            @return {Ext.data.Model[]} The records
            </summary>
        </member>
        <member name="M:Ext.data.reader.Json.readRecords(System.Object)">
            <summary>
            Reads a JSON object and returns a ResultSet. Uses the internal getTotal and getSuccess extractors to
            retrieve meta data from the response, and extractData to turn the JSON data into model instances.
            @param {Object} data The raw JSON data
            @return {Ext.data.ResultSet} A ResultSet containing model instances and meta data about the results
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.reader.Json.alternateClassName" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.data.reader.Json.extend" -->
        <member name="P:Ext.data.reader.Json.useSimpleAccessors">
            <summary>
            @cfg {Boolean} useSimpleAccessors True to ensure that field names/mappings are treated as literals when
            reading values. Defalts to <tt>false</tt>.
            For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
            from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
            "foo.bar.baz" direct from the root object.
            </summary>
        </member>
        <member name="P:Ext.data.reader.JsonConfig.record">
            <summary>
            The optional location within the JSON response that the record data itself can be found at.
            See the JsonReader intro docs for more details. This is not often needed and defaults to undefined.
            </summary>
        </member>
        <member name="P:Ext.data.reader.JsonConfig.useSimpleAccessors">
            <summary>
            True to ensure that field names/mappings are treated as literals when
            reading values. Defalts to <tt>false</tt>.
            For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
            from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
            "foo.bar.baz" direct from the root object.
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.buildExtractors(System.Boolean)">
            <summary>
            @private
            This builds optimized functions for retrieving record data and meta data from an object.
            Subclasses may need to implement their own getRoot function.
            @param {Boolean} force True to automatically remove existing extractor functions first (defaults to false)
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.buildFieldExtractors">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.#ctor(System.Object)">
            <summary>
            Creates new Reader.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.extractData(System.Object)">
            <summary>
            Returns extracted, type-cast rows of data.  Iterates to call #extractValues for each row
            @param {Object[]/Object} root from server response
            @private
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.extractValues(System.Object)">
            <summary>
            @private
            Given an object representing a single model instance's data, iterates over the model's fields and
            builds an object with the value for each field.
            @param {Object} data The data object to convert
            @return {Object} Data object suitable for use with a model constructor
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.getAssociatedDataRoot(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            @private
            Used internally by {@link #readAssociated}. Given a data object (which could be json, xml etc) for a specific
            record, this should return the relevant part of that data for the given association name. This is only really
            needed to support the XML Reader, which has to do a query to get the associated data object
            @param {Object} data The raw data object
            @param {String} associationName The name of the association to get data for (uses associationKey if present)
            @return {Object} The root
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.getData(System.Object)">
            <summary>
            @private
            By default this function just returns what is passed to it. It can be overridden in a subclass
            to return something else. See XmlReader for an example.
            @param {Object} data The data object
            @return {Object} The normalized data object
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.getIdProperty">
            <summary>
            Get the idProperty to use for extracting data
            @private
            @return {String} The id property
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.getResponseData(System.Object)">
            <summary>
            Takes a raw response object (as passed to this.read) and returns the useful data segment of it. This must be
            implemented by each subclass
            @param {Object} response The responce object
            @return {Object} The useful data from the response
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.getRoot(System.Object)">
            <summary>
            @private
            This will usually need to be implemented in a subclass. Given a generic data object (the type depends on the type
            of data we are reading), this function should return the object as configured by the Reader's 'root' meta data config.
            See XmlReader's getRoot implementation for an example. By default the same data object will simply be returned.
            @param {Object} data The data object
            @return {Object} The same data object
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.onMetaChange(System.Object)">
            <summary>
            @private
            Reconfigures the meta data tied to this Reader
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.read(System.Object)">
            <summary>
            Reads the given response object. This method normalizes the different types of response object that may be passed
            to it, before handing off the reading of records to the {@link #readRecords} function.
            @param {Object} response The response object. This may be either an XMLHttpRequest object or a plain JS object
            @return {Ext.data.ResultSet} The parsed ResultSet object
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.readAssociated(Ext.data.Model,System.Object)">
            <summary>
            @private
            Loads a record's associations from the data object. This prepopulates hasMany and belongsTo associations
            on the record provided.
            @param {Ext.data.Model} record The record to load associations for
            @param {Object} data The data object
            @return {String} Return value description
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.readRecords(System.Object)">
            <summary>
            Abstracts common functionality used by all Reader subclasses. Each subclass is expected to call this function
            before running its own logic and returning the Ext.data.ResultSet instance. For most Readers additional
            processing should not be needed.
            @param {Object} data The raw data object
            @return {Ext.data.ResultSet} A ResultSet object
            </summary>
        </member>
        <member name="M:Ext.data.reader.Reader.setModel(System.Object,System.Boolean)">
            <summary>
            Sets a new model for the reader.
            @private
            @param {Object} model The model to set.
            @param {Boolean} setOnProxy True to also set on the Proxy, if one is configured
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.IdProperty">
            <summary>
            Get the idProperty to use for extracting data
            @private
            @return {String} The id property
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.implicitIncludes">
            <summary>
            @cfg {Boolean} implicitIncludes
            True to automatically parse models nested within other models in a response object. See the
            Ext.data.reader.Reader intro docs for full explanation. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.isReader">
            <summary>
            @cfg {Boolean} implicitIncludes
            True to automatically parse models nested within other models in a response object. See the
            Ext.data.reader.Reader intro docs for full explanation. Defaults to true.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.root">
            <summary>
            @cfg {String} root
            **(Required)** The name of the property which contains the Array of row objects. Defaults to undefined. An
            exception will be thrown if the root property is undefined. The data packet value for this property should be an
            empty array to clear the data or show no data.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.successProperty">
            <summary>
            @cfg {String} successProperty
            Name of the property from which to retrieve the success attribute. Defaults to success. See
            {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
            </summary>
        </member>
        <member name="P:Ext.data.reader.Reader.totalProperty">
            <summary>
            @cfg {String} totalProperty
            Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
            the whole dataset is not passed in one go, but is being paged from the remote server. Defaults to total.
            </summary>
        </member>
        <member name="P:Ext.data.reader.ReaderConfig.idProperty">
            <summary>
            Name of the property within a row object that contains a record identifier value. Defaults to The id of the
            model. If an idProperty is explicitly specified it will override that of the one specified on the model
            </summary>
        </member>
        <member name="P:Ext.data.reader.ReaderConfig.messageProperty">
            <summary>
            The name of the property which contains a response message. This property is optional.
            </summary>
        </member>
        <member name="P:Ext.data.reader.ReaderConfig.root">
            <summary>
            **(Required)** The name of the property which contains the Array of row objects. Defaults to undefined. An
            exception will be thrown if the root property is undefined. The data packet value for this property should be an
            empty array to clear the data or show no data.
            </summary>
        </member>
        <member name="P:Ext.data.reader.ReaderConfig.successProperty">
            <summary>
            Name of the property from which to retrieve the success attribute. Defaults to success. See
            {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
            </summary>
        </member>
        <member name="P:Ext.data.reader.ReaderConfig.totalProperty">
            <summary>
            Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
            the whole dataset is not passed in one go, but is being paged from the remote server. Defaults to total.
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.createAccessor(SharpKit.JavaScript.JsString)">
            <summary>
            @private
            Creates a function to return some particular key of data from a response. The totalProperty and
            successProperty are treated as special cases for type casting, everything else is just a simple selector.
            @param {String} key
            @return {Function}
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.extractData(System.Object)">
            <summary>
            @private
            We're just preparing the data for the superclass by pulling out the record nodes we want
            @param {XMLElement} root The XML root node
            @return {Ext.data.Model[]} The records
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.getAssociatedDataRoot(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            @private
            See Ext.data.reader.Reader's getAssociatedDataRoot docs
            @param {Object} data The raw data object
            @param {String} associationName The name of the association to get data for (uses associationKey if present)
            @return {XMLElement} The root
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.getData(System.Object)">
            <summary>
            Normalizes the data object
            @param {Object} data The raw data object
            @return {Object} Returns the documentElement property of the data object if present, or the same object if not
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.getRoot(System.Object)">
            <summary>
            @private
            Given an XML object, returns the Element that represents the root as configured by the Reader's meta data
            @param {Object} data The XML data object
            @return {XMLElement} The root node element
            </summary>
        </member>
        <member name="M:Ext.data.reader.Xml.readRecords(System.Object)">
            <summary>
            Parses an XML document and returns a ResultSet containing the model instances
            @param {Object} doc Parsed XML document
            @return {Ext.data.ResultSet} The parsed result set
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.data.reader.Xml.alternateClassName" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.data.reader.Xml.extend" -->
        <member name="P:Ext.data.reader.XmlConfig.record">
            <summary>
            The DomQuery path to the repeated element which contains record information.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Json.allowSingle">
            <summary>
            @cfg {Boolean} allowSingle False to ensure that records are always wrapped in an array, even if there is only
            one record being sent. When there is more than one record, they will always be encoded into an array.
            Defaults to <tt>true</tt>. Example:
            <pre><code>
            // with allowSingle: true
            "root": {
            "first": "Mark",
            "last": "Corrigan"
            }
            // with allowSingle: false
            "root": [{
            "first": "Mark",
            "last": "Corrigan"
            }]
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.data.writer.Json.alternateClassName">
            <summary>
            @class Ext.data.writer.Json
            @extends Ext.data.writer.Writer
            This class is used to write {@link Ext.data.Model} data to the server in a JSON format.
            The {@link #allowSingle} configuration can be set to false to force the records to always be
            encoded in an array, even if there is only a single record being sent.
            @markdown
            </summary>
        </member>
        <member name="P:Ext.data.writer.Json.encode">
            <summary>
            @cfg {Boolean} encode True to use Ext.encode() on the data before sending. Defaults to <tt>false</tt>.
            The encode option should only be set to true when a {@link #root} is defined, because the values will be
            sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
            sent to the server.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Json.extend">
            <summary>
            @class Ext.data.writer.Json
            @extends Ext.data.writer.Writer
            This class is used to write {@link Ext.data.Model} data to the server in a JSON format.
            The {@link #allowSingle} configuration can be set to false to force the records to always be
            encoded in an array, even if there is only a single record being sent.
            @markdown
            </summary>
        </member>
        <member name="P:Ext.data.writer.JsonConfig.allowSingle">
            <summary>
            False to ensure that records are always wrapped in an array, even if there is only
            one record being sent. When there is more than one record, they will always be encoded into an array.
            Defaults to <tt>true</tt>. Example:
            <pre><code>
            // with allowSingle: true
            "root": {
            "first": "Mark",
            "last": "Corrigan"
            }
            // with allowSingle: false
            "root": [{
            "first": "Mark",
            "last": "Corrigan"
            }]
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.data.writer.JsonConfig.encode">
            <summary>
            True to use Ext.encode() on the data before sending. Defaults to <tt>false</tt>.
            The encode option should only be set to true when a {@link #root} is defined, because the values will be
            sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
            sent to the server.
            </summary>
        </member>
        <member name="P:Ext.data.writer.JsonConfig.root">
            <summary>
            The key under which the records in this Writer will be placed. Defaults to <tt>undefined</tt>.
            Example generated request, using root: 'records':
            <pre><code>
            {'records': [{name: 'my record'}, {name: 'another record'}]}
            </code></pre>
            </summary>
        </member>
        <member name="M:Ext.data.writer.Writer.#ctor(System.Object)">
            <summary>
            Creates new Writer.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.data.writer.Writer.getRecordData(System.Object)">
            <summary>
            Formats the data for each record before sending it to the server. This
            method should be overridden to format the data in a way that differs from the default.
            @param {Object} record The record that we are writing to the server.
            @return {Object} An object literal of name/value keys to be written to the server.
            By default this method returns the data property on the record.
            </summary>
        </member>
        <member name="M:Ext.data.writer.Writer.write(Ext.data.Request)">
            <summary>
            Prepares a Proxy's Ext.data.Request object
            @param {Ext.data.Request} request The request object
            @return {Ext.data.Request} The modified request object
            </summary>
        </member>
        <member name="P:Ext.data.writer.Writer.alias">
            <summary>
            @author Ed Spencer
            @class Ext.data.writer.Writer
            @extends Object
            <p>Base Writer class used by most subclasses of {@link Ext.data.proxy.Server}. This class is
            responsible for taking a set of {@link Ext.data.Operation} objects and a {@link Ext.data.Request}
            object and modifying that request based on the Operations.</p>
            <p>For example a Ext.data.writer.Json would format the Operations and their {@link Ext.data.Model}
            instances based on the config options passed to the JsonWriter's constructor.</p>
            <p>Writers are not needed for any kind of local storage - whether via a
            {@link Ext.data.proxy.WebStorage Web Storage proxy} (see {@link Ext.data.proxy.LocalStorage localStorage}
            and {@link Ext.data.proxy.SessionStorage sessionStorage}) or just in memory via a
            {@link Ext.data.proxy.Memory MemoryProxy}.</p>
            </summary>
        </member>
        <member name="P:Ext.data.writer.Writer.nameProperty">
            <summary>
            @cfg {String} nameProperty This property is used to read the key for each value that will be sent to the server.
            For example:
            <pre><code>
            Ext.define('Person', {
            extend: 'Ext.data.Model',
            fields: [{
            name: 'first',
            mapping: 'firstName'
            }, {
            name: 'last',
            mapping: 'lastName'
            }, {
            name: 'age'
            }]
            });
            new Ext.data.writer.Writer({
            writeAllFields: true,
            nameProperty: 'mapping'
            });
            // This will be sent to the server
            {
            firstName: 'first name value',
            lastName: 'last name value',
            age: 1
            }
            </code></pre>
            Defaults to <tt>name</tt>. If the value is not present, the field name will always be used.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Writer.writeAllFields">
            <summary>
            @cfg {Boolean} writeAllFields True to write all fields from the record to the server. If set to false it
            will only send the fields that were modified. Defaults to <tt>true</tt>. Note that any fields that have
            {@link Ext.data.Field#persist} set to false will still be ignored.
            </summary>
        </member>
        <member name="P:Ext.data.writer.WriterConfig.nameProperty">
            <summary>
            This property is used to read the key for each value that will be sent to the server.
            For example:
            <pre><code>
            Ext.define('Person', {
            extend: 'Ext.data.Model',
            fields: [{
            name: 'first',
            mapping: 'firstName'
            }, {
            name: 'last',
            mapping: 'lastName'
            }, {
            name: 'age'
            }]
            });
            new Ext.data.writer.Writer({
            writeAllFields: true,
            nameProperty: 'mapping'
            });
            // This will be sent to the server
            {
            firstName: 'first name value',
            lastName: 'last name value',
            age: 1
            }
            </code></pre>
            Defaults to <tt>name</tt>. If the value is not present, the field name will always be used.
            </summary>
        </member>
        <member name="P:Ext.data.writer.WriterConfig.writeAllFields">
            <summary>
            True to write all fields from the record to the server. If set to false it
            will only send the fields that were modified. Defaults to <tt>true</tt>. Note that any fields that have
            {@link Ext.data.Field#persist} set to false will still be ignored.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.alternateClassName">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.defaultDocumentRoot">
            <summary>
            @cfg {String} defaultDocumentRoot The root to be used if {@link #documentRoot} is empty and a root is required
            to form a valid XML document.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.documentRoot">
            <summary>
            @cfg {String} documentRoot The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
            If there is more than 1 record and the root is not specified, the default document root will still be used
            to ensure a valid XML document is created.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.header">
            <summary>
            @cfg {String} header A header to use in the XML document (such as setting the encoding or version).
            Defaults to <tt>''</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.writer.Xml.record">
            <summary>
            @cfg {String} record The name of the node to use for each record. Defaults to <tt>'record'</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.writer.XmlConfig.defaultDocumentRoot">
            <summary>
            The root to be used if {@link #documentRoot} is empty and a root is required
            to form a valid XML document.
            </summary>
        </member>
        <member name="P:Ext.data.writer.XmlConfig.documentRoot">
            <summary>
            The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
            If there is more than 1 record and the root is not specified, the default document root will still be used
            to ensure a valid XML document is created.
            </summary>
        </member>
        <member name="P:Ext.data.writer.XmlConfig.header">
            <summary>
            A header to use in the XML document (such as setting the encoding or version).
            Defaults to <tt>''</tt>.
            </summary>
        </member>
        <member name="P:Ext.data.writer.XmlConfig.record">
            <summary>
            The name of the node to use for each record. Defaults to <tt>'record'</tt>.
            </summary>
        </member>
        <member name="M:Ext.dataview.ComponentList.setActiveGroup(System.Object)">
            <summary>
            Set the current active group
            @param {Object} group The group to set active
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentList.ActiveGroup">
            <summary>
            Set the current active group
            @param {Object} group The group to set active
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentList.alternateClassName">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentList.extend">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentListConfig.clearSelectionOnDeactivate">
            <summary>
            True to clear any selections on the list when the list is deactivated (defaults to true).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentListConfig.indexBar">
            <summary>
            True to render an alphabet IndexBar docked on the right.
            This can also be a config object that will be passed to {@link Ext.IndexBar}
            (defaults to false)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentListConfig.onItemDisclosure">
            <summary>
            True to display a disclosure icon on each list item.
            This won't bind a listener to the tap event. The list
            will still fire the disclose event though.
            By setting this config to a function, it will automatically
            add a tap event listeners to the disclosure buttons which
            will fire your function.
            Finally you can specify an object with a 'scope' and 'handler'
            property defined. This will also be bound to the tap event listener
            and is useful when you want to change the scope of the handler.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentListConfig.pinHeaders">
            <summary>
            Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
            Defaults to <tt>false</tt> on Android and Blackberry (for performance reasons)
            Defaults to <tt>true</tt> on other devices.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ComponentListConfig.preventSelectionOnDisclose">
            <summary>
            True to prevent the item selection when the user
            taps a disclose icon. Defaults to <tt>true</tt>
            @accessor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.dataview.ComponentView.extend" -->
        <member name="P:Ext.dataview.ComponentViewConfig.itemConfig">
            <summary>
            A configuration object that is passed to every item created by the DataView. Because each item that a
            DataView renders is a Component, we can pass configuration options to each component to easily customize how
            each child component behaves.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.dataview.DataItem.updateRecord(System.Object)">
            <summary>
            Updates this container's child items, passing through the dataMap.
            @param newRecord
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.DataItem.extend">
            <summary>
            A DataItem is a container for {@link Ext.dataview.ComponentView ComponentViews}. It ties together
            {@link Ext.data.Model records} to its contained Components via a {@link #dataMap dataMap} configuration.
            *
            For example, lets say you have a `text configuration which, when applied, gets turned into an instance of an
            Ext.Component. We want to update the {@link #html} of a sub-component when the 'text' field of the record gets
            changed.
            As you can see below, it is simply a matter of setting the key of the object to be the getter of the config
            (getText), and then give that property a value of an object, which then has 'setHtml' (the html setter) as the key,
            and 'text' (the field name) as the value. You can continue this for a as many sub-components as you wish.
            *
            dataMap: {
            // When the record is updated, get the text configuration, and
            // call {@link #setHtml} with the 'text' field of the record.
            getText: {
            setHtml: 'text'
            },
            *
            // When the record is updated, get the userName configuration, and
            // call {@link #setHtml} with the 'from_user' field of the record.
            getUserName: {
            setHtml: 'from_user'
            },
            *
            // When the record is updated, get the avatar configuration, and
            // call `setSrc` with the 'profile_image_url' field of the record.
            getAvatar: {
            setSrc: 'profile_image_url'
            }
            },
            </summary>
        </member>
        <member name="P:Ext.dataview.DataItem.xtype">
            <summary>
            A DataItem is a container for {@link Ext.dataview.ComponentView ComponentViews}. It ties together
            {@link Ext.data.Model records} to its contained Components via a {@link #dataMap dataMap} configuration.
            *
            For example, lets say you have a `text configuration which, when applied, gets turned into an instance of an
            Ext.Component. We want to update the {@link #html} of a sub-component when the 'text' field of the record gets
            changed.
            As you can see below, it is simply a matter of setting the key of the object to be the getter of the config
            (getText), and then give that property a value of an object, which then has 'setHtml' (the html setter) as the key,
            and 'text' (the field name) as the value. You can continue this for a as many sub-components as you wish.
            *
            dataMap: {
            // When the record is updated, get the text configuration, and
            // call {@link #setHtml} with the 'text' field of the record.
            getText: {
            setHtml: 'text'
            },
            *
            // When the record is updated, get the userName configuration, and
            // call {@link #setHtml} with the 'from_user' field of the record.
            getUserName: {
            setHtml: 'from_user'
            },
            *
            // When the record is updated, get the avatar configuration, and
            // call `setSrc` with the 'profile_image_url' field of the record.
            getAvatar: {
            setSrc: 'profile_image_url'
            }
            },
            </summary>
        </member>
        <member name="P:Ext.dataview.DataItemConfig.record">
            <summary>
            The model instance of this DataItem. It is controlled by the Component DataView
            @accessor
            </summary>
        </member>
        <member name="M:Ext.dataview.DataView.refresh">
            <summary>
            Refreshes the view by reloading the data from the store and re-rendering the template.
            </summary>
        </member>
        <member name="P:Ext.dataview.DataView.extend">
            <summary>
            DataView makes it easy to create lots of components dynamically, usually based off a {@link Ext.data.Store Store}.
            It's great for rendering lots of data from your server backend or any other data source and is what powers
            components like {@link Ext.List}.
            *
            Use DataView whenever you want to show sets of the same component many times, for examples in apps like these:
            *
            - List of messages in an email app
            - Showing latest news/tweets
            - Tiled set of albums in an HTML5 music player
            *
            # Creating a Simple DataView
            *
            At its simplest, a DataView is just a Store full of data and a simple template that we use to render each item:
            *
            @example miniphone preview
            var touchTeam = Ext.create('Ext.DataView', {
            fullscreen: true,
            store: {
            fields: ['name', 'age'],
            data: [
            {name: 'Jamie',  age: 100},
            {name: 'Rob',   age: 21},
            {name: 'Tommy', age: 24},
            {name: 'Jacky', age: 24},
            {name: 'Ed',   age: 26}
            ]
            },
            *
            itemTpl: '<div>{name} is {age} years old</div>'
            });
            *
            Here we just defined everything inline so it's all local with nothing being loaded from a server. For each of the 5
            data items defined in our Store, DataView will render a {@link Ext.Component Component} and pass in the name and age
            data. The component will use the tpl we provided above, rendering the data in the curly bracket placeholders we
            provided.
            *
            Because DataView is integrated with Store, any changes to the Store are immediately reflected on the screen. For
            example, if we add a new record to the Store it will be rendered into our DataView:
            *
            touchTeam.getStore().add({
            name: 'Abe Elias',
            age: 33
            });
            *
            We didn't have to manually update the DataView, it's just automatically updated. The same happens if we modify one
            of the existing records in the Store:
            *
            touchTeam.getStore().getAt(0).set('age', 42);
            *
            This will get the first record in the Store (Jamie), change the age to 42 and automatically update what's on the
            screen.
            @example miniphone
            var touchTeam = Ext.create('Ext.DataView', {
            fullscreen: true,
            store: {
            fields: ['name', 'age'],
            data: [
            {name: 'Jamie',  age: 100},
            {name: 'Rob',   age: 21},
            {name: 'Tommy', age: 24},
            {name: 'Jacky', age: 24},
            {name: 'Ed',   age: 26}
            ]
            },
            *
            itemTpl: '<div>{name} is {age} years old</div>'
            });
            touchTeam.getStore().add({
            name: 'Abe Elias',
            age: 33
            });
            touchTeam.getStore.getAt(0).set('age', 42);
            *
            # Loading data from a server
            *
            We often want to load data from our server or some other web service so that we don't have to hard code it all
            locally. Let's say we want to load all of the latest tweets about Sencha Touch into a DataView, and for each one
            render the user's profile picture, user name and tweet message. To do this all we have to do is modify the
            {@link #store} and {@link #itemTpl} a little:
            *
            @example portrait
            Ext.create('Ext.DataView', {
            fullscreen: true,
            cls: 'twitterView',
            store: {
            autoLoad: true,
            fields: ['from_user', 'text', 'profile_image_url'],
            *
            proxy: {
            type: 'jsonp',
            url: 'http://search.twitter.com/search.json?q=Sencha Touch',
            *
            reader: {
            type: 'json',
            root: 'results'
            }
            }
            },
            *
            itemTpl: '<img src="{profile_image_url}" /><h2>{from_user}</h2><p>{text}</p><div style="clear: both"></div>'
            });
            *
            The Store no longer has hard coded data, instead we've provided a {@link Ext.data.proxy.Proxy Proxy}, which fetches
            the data for us. In this case we used a JSON-P proxy so that we can load from Twitter's JSON-P search API. We also
            specified the fields present for each tweet, and used Store's {@link Ext.data.Store#autoLoad autoLoad} configuration
            to load automatically. Finally, we configured a Reader to decode the response from Twitter, telling it to expect
            JSON and that the tweets can be found in the 'results' part of the JSON response.
            *
            The last thing we did is update our template to render the image, twitter username and message. All we need to do
            now is add a little CSS to style the list the way we want it and we end up with a very basic twitter viewer. Click
            the preview button on the example above to see it in action.
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.deselectOnContainerClick">
            <summary>
            When set to true, tapping on the DataView's background (i.e. not on
            an item in the DataView) will deselect any currently selected items.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.itemTpl">
            <summary>
            The tpl to use for each of the items displayed in this DataView.
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.loadingText">
            <summary>
            A string to display during data load operations (defaults to 'Loading...').  If specified, this text will be
            displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
            contents will continue to display normally until the new data is loaded and the contents are replaced.
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.pressedCls">
            <summary>
            The CSS class to apply to an item on the view while it is being pressed.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.pressedDelay">
            <summary>
            The amount of delay between the tapstart and the moment we add the pressedCls.
            Settings this to true defaults to 100ms.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.selectedCls">
            <summary>
            The CSS class to apply to an item on the view while it is selected.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.store">
            <summary>
            Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
            to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
            more information about the relationship between Store and DataView.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.triggerCtEvent">
            <summary>
            Determines what type of touch event is recognized as a touch on the container.
            Valid options are 'tap' and 'singletap'.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.DataViewConfig.triggerEvent">
            <summary>
            Determines what type of touch event causes an item to be selected.
            Valid options are 'tap' and 'singletap'.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.IndexBar.alternateClassName">
            <summary>
            IndexBar is a component used to display a list of data (primarily an alphabet) which can then be used to quickly
            navigate through a list (see {@link Ext.List}) of data. When a user taps on an item in the {@link Ext.IndexBar},
            it will fire the {@link #index} event.
            *
            # Example:
            *
            Here is an example of the usage in a {@link Ext.List}:
            *
            @example phone portrait preview
            Ext.regModel('Contact', {
            fields: ['firstName', 'lastName']
            });
            *
            var store = new Ext.data.JsonStore({
            model: 'Contact',
            sorters: 'lastName',
            *
            getGroupString: function(record) {
            return record.get('lastName')[0];
            },
            *
            data: [
            {firstName: 'Tommy',   lastName: 'Maintz'},
            {firstName: 'Rob',     lastName: 'Dougan'},
            {firstName: 'Ed',      lastName: 'Spencer'},
            {firstName: 'Jamie',   lastName: 'Avins'},
            {firstName: 'Aaron',   lastName: 'Conran'},
            {firstName: 'Dave',    lastName: 'Kaneda'},
            {firstName: 'Jacky',   lastName: 'Nguyen'},
            {firstName: 'Abraham', lastName: 'Elias'},
            {firstName: 'Jay',     lastName: 'Robinson'},
            {firstName: 'Nigel',   lastName: 'White'},
            {firstName: 'Don',     lastName: 'Griffin'},
            {firstName: 'Nico',    lastName: 'Ferrero'},
            {firstName: 'Nicolas', lastName: 'Belmonte'},
            {firstName: 'Jason',   lastName: 'Johnston'}
            ]
            });
            *
            var list = new Ext.List({
            fullscreen: true,
            itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
            *
            grouped     : true,
            indexBar    : true,
            store: store,
            hideOnMaskTap: false
            });
            *
            Alternatively you can initate the {@link Ext.IndexBar} component manually in a custom component by using something
            similar to the following example:
            *
            var indexBar = new Ext.dataview.IndexBar({
            dock: 'right',
            overlay: true,
            alphabet: true
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.IndexBar.extend">
            <summary>
            IndexBar is a component used to display a list of data (primarily an alphabet) which can then be used to quickly
            navigate through a list (see {@link Ext.List}) of data. When a user taps on an item in the {@link Ext.IndexBar},
            it will fire the {@link #index} event.
            *
            # Example:
            *
            Here is an example of the usage in a {@link Ext.List}:
            *
            @example phone portrait preview
            Ext.regModel('Contact', {
            fields: ['firstName', 'lastName']
            });
            *
            var store = new Ext.data.JsonStore({
            model: 'Contact',
            sorters: 'lastName',
            *
            getGroupString: function(record) {
            return record.get('lastName')[0];
            },
            *
            data: [
            {firstName: 'Tommy',   lastName: 'Maintz'},
            {firstName: 'Rob',     lastName: 'Dougan'},
            {firstName: 'Ed',      lastName: 'Spencer'},
            {firstName: 'Jamie',   lastName: 'Avins'},
            {firstName: 'Aaron',   lastName: 'Conran'},
            {firstName: 'Dave',    lastName: 'Kaneda'},
            {firstName: 'Jacky',   lastName: 'Nguyen'},
            {firstName: 'Abraham', lastName: 'Elias'},
            {firstName: 'Jay',     lastName: 'Robinson'},
            {firstName: 'Nigel',   lastName: 'White'},
            {firstName: 'Don',     lastName: 'Griffin'},
            {firstName: 'Nico',    lastName: 'Ferrero'},
            {firstName: 'Nicolas', lastName: 'Belmonte'},
            {firstName: 'Jason',   lastName: 'Johnston'}
            ]
            });
            *
            var list = new Ext.List({
            fullscreen: true,
            itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
            *
            grouped     : true,
            indexBar    : true,
            store: store,
            hideOnMaskTap: false
            });
            *
            Alternatively you can initate the {@link Ext.IndexBar} component manually in a custom component by using something
            similar to the following example:
            *
            var indexBar = new Ext.dataview.IndexBar({
            dock: 'right',
            overlay: true,
            alphabet: true
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.IndexBarConfig.direction">
            <summary>
            Layout direction, can be either 'vertical' or 'horizontal'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.IndexBarConfig.letters">
            <summary>
            The letters to show on the index bar.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.IndexBarConfig.listPrefix">
            <summary>
            The prefix string to be appended at the beginning of the list.
            E.g: useful to add a "#" prefix before numbers.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.dataview.List.setActiveGroup(System.Object)">
            <summary>
            Set the current active group
            @param {Object} group The group to set active
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.List.ActiveGroup">
            <summary>
            Set the current active group
            @param {Object} group The group to set active
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.List.alternateClassName">
            <summary>
            List is a custom styled DataView which allows Grouping, Indexing, Icons, and a Disclosure.
            *
            # Example:
            *
            Here is an example of the usage in a {@link Ext.List}:
            *
            @example miniphone preview
            Ext.regModel('Contact', {
            fields: ['firstName', 'lastName']
            });
            *
            var store = new Ext.data.JsonStore({
            model: 'Contact',
            sorters: 'lastName',
            *
            getGroupString: function(record) {
            return record.get('lastName')[0];
            },
            *
            data: [
            {firstName: 'Tommy',   lastName: 'Maintz'},
            {firstName: 'Rob',     lastName: 'Dougan'},
            {firstName: 'Ed',      lastName: 'Spencer'},
            {firstName: 'Jamie',   lastName: 'Avins'},
            {firstName: 'Aaron',   lastName: 'Conran'},
            {firstName: 'Dave',    lastName: 'Kaneda'},
            {firstName: 'Jacky',   lastName: 'Nguyen'},
            {firstName: 'Abraham', lastName: 'Elias'},
            {firstName: 'Jay',     lastName: 'Robinson'},
            {firstName: 'Nigel',   lastName: 'White'},
            {firstName: 'Don',     lastName: 'Griffin'},
            {firstName: 'Nico',    lastName: 'Ferrero'},
            {firstName: 'Nicolas', lastName: 'Belmonte'},
            {firstName: 'Jason',   lastName: 'Johnston'}
            ]
            });
            *
            var list = new Ext.List({
            fullscreen: true,
            itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
            store: store
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.List.extend">
            <summary>
            List is a custom styled DataView which allows Grouping, Indexing, Icons, and a Disclosure.
            *
            # Example:
            *
            Here is an example of the usage in a {@link Ext.List}:
            *
            @example miniphone preview
            Ext.regModel('Contact', {
            fields: ['firstName', 'lastName']
            });
            *
            var store = new Ext.data.JsonStore({
            model: 'Contact',
            sorters: 'lastName',
            *
            getGroupString: function(record) {
            return record.get('lastName')[0];
            },
            *
            data: [
            {firstName: 'Tommy',   lastName: 'Maintz'},
            {firstName: 'Rob',     lastName: 'Dougan'},
            {firstName: 'Ed',      lastName: 'Spencer'},
            {firstName: 'Jamie',   lastName: 'Avins'},
            {firstName: 'Aaron',   lastName: 'Conran'},
            {firstName: 'Dave',    lastName: 'Kaneda'},
            {firstName: 'Jacky',   lastName: 'Nguyen'},
            {firstName: 'Abraham', lastName: 'Elias'},
            {firstName: 'Jay',     lastName: 'Robinson'},
            {firstName: 'Nigel',   lastName: 'White'},
            {firstName: 'Don',     lastName: 'Griffin'},
            {firstName: 'Nico',    lastName: 'Ferrero'},
            {firstName: 'Nicolas', lastName: 'Belmonte'},
            {firstName: 'Jason',   lastName: 'Johnston'}
            ]
            });
            *
            var list = new Ext.List({
            fullscreen: true,
            itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
            store: store
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.ListConfig.clearSelectionOnDeactivate">
            <summary>
            True to clear any selections on the list when the list is deactivated (defaults to true).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ListConfig.indexBar">
            <summary>
            True to render an alphabet IndexBar docked on the right.
            This can also be a config object that will be passed to {@link Ext.IndexBar}
            (defaults to false)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ListConfig.onItemDisclosure">
            <summary>
            True to display a disclosure icon on each list item.
            This won't bind a listener to the tap event. The list
            will still fire the disclose event though.
            By setting this config to a function, it will automatically
            add a tap event listeners to the disclosure buttons which
            will fire your function.
            Finally you can specify an object with a 'scope' and 'handler'
            property defined. This will also be bound to the tap event listener
            and is useful when you want to change the scope of the handler.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ListConfig.pinHeaders">
            <summary>
            Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
            Defaults to <tt>false</tt> on Android and Blackberry (for performance reasons)
            Defaults to <tt>true</tt> on other devices.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ListConfig.preventSelectionOnDisclose">
            <summary>
            True to prevent the item selection when the user
            taps a disclose icon. Defaults to <tt>true</tt>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.ListDisclosure.extend">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ListDisclosure.xtype">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ListIcon.extend">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ListIcon.xtype">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ListItem.extend">
            <summary>
            @private - To be merged when DataView behaviors are used.
            </summary>
        </member>
        <member name="P:Ext.dataview.ListItemHeader.extend">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="P:Ext.dataview.ListItemHeader.xtype">
            <summary>
            @private - To be made a sample
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.getItemTextTpl(System.Object)">
            <summary>
            Override this method to provide custom template rendering of individual
            nodes. The template will receive all data within the Record and will also
            receive whether or not it is a leaf node.
            @param {Ext.data.Record} node
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.getListConfig(SharpKit.Html4.HtmlElement)">
            <summary>
            @private
            Returns the list config for a specified node.
            @param {HTMLElement} node The node for the list config
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.getTitleTextTpl(System.Object)">
            <summary>
            Override this method to provide custom template rendering of titles/back
            buttons when useTitleAsBackText is enabled.
            @param {Ext.data.Record} node
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.goToLeaf(Ext.data.NodeInterface)">
            <summary>
            The leaf you want to navigate to. You should pass a node instance.
            @param {Ext.data.NodeInterface} node The specified node to navigate to
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.goToNode(Ext.data.NodeInterface)">
            <summary>
            Method to handle going to a specific node within this nested list. Node must be part of the
            internal {@link #store}.
            @param {Ext.data.NodeInterface} node The specified node to navigate to
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.goToNodeReverseAnimation(Ext.data.NodeInterface)">
            <summary>
            @private
            Returns true if the passed node should have a reverse animation from the previous current {@link #node}
            @param {Ext.data.NodeInterface} node
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.initialize">
            <summary>
            @event load
            @alias Ext.data.Store#load
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.onBackTap">
            <summary>
            Called when the backButton has been tapped
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.onItemDoubleTap(System.Object,SharpKit.JavaScript.JsNumber,System.Object,Ext.event.Event)">
            <summary>
            Called when an list item has been tapped
            @param {Ext.List} list The subList the item is on
            @param {Number} index The id of the item tapped
            @param {Ext.Element} item The list item tapped
            @param {Ext.event.Event} e The event
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.onItemTap(System.Object,SharpKit.JavaScript.JsNumber,System.Object,Ext.event.Event)">
            <summary>
            Called when an list item has been tapped
            @param {Ext.List} list The subList the item is on
            @param {Number} index The id of the item tapped
            @param {Ext.Element} item The list item tapped
            @param {Ext.event.Event} e The event
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.renderTitleText(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.dataview.NestedList.syncToolbar(System.Object)">
            <summary>
            @private
            Method which updates the {@link #backButton} and {@link #toolbar} with the latest information from
            the current {@link #node}.
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedList.alternateClassName">
            <summary>
            NestedList provides a miller column interface to navigate between nested sets
            and provide a clean interface with limited screen real-estate.
            *
            @example miniphone preview
            var data = {
            text: 'Groceries',
            items: [{
            text: 'Drinks',
            items: [{
            text: 'Water',
            items: [{
            text: 'Sparkling',
            leaf: true
            }, {
            text: 'Still',
            leaf: true
            }]
            }, {
            text: 'Coffee',
            leaf: true
            }, {
            text: 'Espresso',
            leaf: true
            }, {
            text: 'Redbull',
            leaf: true
            }, {
            text: 'Coke',
            leaf: true
            }, {
            text: 'Diet Coke',
            leaf: true
            }]
            }, {
            text: 'Fruit',
            items: [{
            text: 'Bananas',
            leaf: true
            }, {
            text: 'Lemon',
            leaf: true
            }]
            }, {
            text: 'Snacks',
            items: [{
            text: 'Nuts',
            leaf: true
            }, {
            text: 'Pretzels',
            leaf: true
            }, {
            text: 'Wasabi Peas',
            leaf: true
            }]
            }]
            };
            *
            Ext.regModel('ListItem', {
            fields: [{
            name: 'text',
            type: 'string'
            }]
            });
            *
            var store = new Ext.data.TreeStore({
            model: 'ListItem',
            defaultRootProperty: 'items',
            root: data
            });
            *
            var nestedList = new Ext.NestedList({
            fullscreen: true,
            title: 'Groceries',
            displayField: 'text',
            store: store
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedList.extend">
            <summary>
            NestedList provides a miller column interface to navigate between nested sets
            and provide a clean interface with limited screen real-estate.
            *
            @example miniphone preview
            var data = {
            text: 'Groceries',
            items: [{
            text: 'Drinks',
            items: [{
            text: 'Water',
            items: [{
            text: 'Sparkling',
            leaf: true
            }, {
            text: 'Still',
            leaf: true
            }]
            }, {
            text: 'Coffee',
            leaf: true
            }, {
            text: 'Espresso',
            leaf: true
            }, {
            text: 'Redbull',
            leaf: true
            }, {
            text: 'Coke',
            leaf: true
            }, {
            text: 'Diet Coke',
            leaf: true
            }]
            }, {
            text: 'Fruit',
            items: [{
            text: 'Bananas',
            leaf: true
            }, {
            text: 'Lemon',
            leaf: true
            }]
            }, {
            text: 'Snacks',
            items: [{
            text: 'Nuts',
            leaf: true
            }, {
            text: 'Pretzels',
            leaf: true
            }, {
            text: 'Wasabi Peas',
            leaf: true
            }]
            }]
            };
            *
            Ext.regModel('ListItem', {
            fields: [{
            name: 'text',
            type: 'string'
            }]
            });
            *
            var store = new Ext.data.TreeStore({
            model: 'ListItem',
            defaultRootProperty: 'items',
            root: data
            });
            *
            var nestedList = new Ext.NestedList({
            fullscreen: true,
            title: 'Groceries',
            displayField: 'text',
            store: store
            });
            *
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.allowDeselect">
            <summary>
            Set to true to alow the user to deselect leaf items via interaction.
            Defaults to false.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.backButton">
            <summary>
            The configuration for the back button used in the nested list
            @private
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.backText">
            <summary>
            The label to display for the back button. Defaults to "Back".
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.cardSwitchAnimation">
            <summary>
            Animation to be used during transitions of cards.
            Any valid value from Ext.anims can be used ('fade', 'slide', 'flip', 'cube', 'pop', 'wipe').
            This animation will be automatically reversed when navigating to a previous card in the
            nested list.
            Defaults to 'slide'.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.data">
            <summary>
            The initial set of data to be used to display content in this nested list.
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.detailCard">
            <summary>
            to provide a final card for leaf nodes.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.detailContainer">
            <summary>
            The container of the detailCard.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.displayField">
            <summary>
            Display field to use when setting item text and title.
            This configuration is ignored when overriding getItemTextTpl or
            getTitleTextTpl for the item text or title. (Defaults to 'text')
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.emptyText">
            <summary>
            Empty text to display when a subtree is empty.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.layout">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.loadingText">
            <summary>
            Loading text to display when a subtree is loading.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.onItemDisclosure">
            <summary>
            Maps to the Ext.List onItemDisclosure configuration for individual lists. (Defaults to false)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.store">
            <summary>
            The tree store to be used for this nested list.
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.title">
            <summary>
            The title of the toolbar
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.updateTitleText">
            <summary>
            Update the title with the currently selected category. Defaults to true.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.useTitleAsBackText">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.dataview.NestedListConfig.useToolbar">
            <summary>
            True to show the header toolbar.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.direct.Event.#ctor(System.Object)">
            <summary>
            Creates new Event.
            @param {Object} config (optional) Config object.
            </summary>
        </member>
        <member name="M:Ext.direct.Event.getData">
            <summary>
            Return the raw data for this event.
            @return {Object} The data from the event
            </summary>
        </member>
        <member name="P:Ext.direct.Event.alias">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.Event.Data">
            <summary>
            Return the raw data for this event.
            @return {Object} The data from the event
            </summary>
        </member>
        <member name="P:Ext.direct.Event.status">
            <summary>
            End Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.ExceptionEvent.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.ExceptionEvent.status">
            <summary>
            End Definitions
            </summary>
        </member>
        <member name="M:Ext.direct.JsonProvider.createEvent(System.Object)">
            <summary>
            Create an event from a response object
            @param {Object} response The XHR response object
            @return {Ext.direct.Event} The event
            </summary>
        </member>
        <member name="M:Ext.direct.JsonProvider.createEvents(System.Object)">
            <summary>
            Creates a set of events based on the XHR response
            @private
            @param {Object} response The XHR response
            @return {Ext.direct.Event[]} An array of Ext.direct.Event
            </summary>
        </member>
        <member name="M:Ext.direct.JsonProvider.parseResponse(System.Object)">
            <summary>
            Parse the JSON response
            @private
            @param {Object} response The XHR response object
            @return {Object} The data in the response.
            </summary>
        </member>
        <member name="P:Ext.direct.JsonProvider.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.addProvider(System.Object)">
            <summary>
            Adds an Ext.Direct Provider and creates the proxy or stub methods to execute server-side methods. If the provider
            is not already connected, it will auto-connect.
            *
            var pollProv = new Ext.direct.PollingProvider({
            url: 'php/poll2.php'
            });
            *
            Ext.direct.Manager.addProvider({
            "type":"remoting",       // create a {@link Ext.direct.RemotingProvider}
            "url":"php\/router.php", // url to connect to the Ext.Direct server-side router.
            "actions":{              // each property within the actions object represents a Class
            "TestAction":[       // array of methods within each server side Class
            {
            "name":"doEcho", // name of method
            "len":1
            },{
            "name":"multiply",
            "len":1
            },{
            "name":"doForm",
            "formHandler":true, // handle form on server with Ext.Direct.Transaction
            "len":1
            }]
            },
            "namespace":"myApplication",// namespace to create the Remoting Provider in
            },{
            type: 'polling', // create a {@link Ext.direct.PollingProvider}
            url:  'php/poll.php'
            }, pollProv); // reference to previously created instance
            *
            @param {Ext.direct.Provider/Object...} provider
            Accepts any number of Provider descriptions (an instance or config object for
            a Provider). Each Provider description instructs Ext.Directhow to create
            client-side stub methods.
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.addTransaction(Ext.direct.Transaction)">
            <summary>
            Adds a transaction to the manager.
            @private
            @param {Ext.direct.Transaction} transaction The transaction to add
            @return {Ext.direct.Transaction} transaction
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.#ctor">
            <summary>
            End Definitions
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.getProvider(System.Object)">
            <summary>
            Retrieves a {@link Ext.direct.Provider provider} by the **{@link Ext.direct.Provider#id id}** specified when the
            provider is {@link #addProvider added}.
            @param {String/Ext.direct.Provider} id The id of the provider, or the provider instance.
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.getTransaction(System.Object)">
            <summary>
            Gets a transaction
            @private
            @param {String/Ext.direct.Transaction} transaction The transaction/id of transaction to get
            @return {Ext.direct.Transaction}
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.removeProvider(System.Object)">
            <summary>
            Removes the provider.
            @param {String/Ext.direct.Provider} provider The provider instance or the id of the provider.
            @return {Ext.direct.Provider} The provider, null if not found.
            </summary>
        </member>
        <member name="M:Ext.direct.Manager.removeTransaction(System.Object)">
            <summary>
            Removes a transaction from the manager.
            @private
            @param {String/Ext.direct.Transaction} transaction The transaction/id of transaction to remove
            @return {Ext.direct.Transaction} transaction
            </summary>
        </member>
        <member name="P:Ext.direct.Manager.singleton">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.direct.PollingProvider.connect">
            <summary>
            Connect to the server-side and begin the polling process. To handle each
            response subscribe to the data event.
            </summary>
        </member>
        <member name="M:Ext.direct.PollingProvider.#ctor(System.Object)">
            <summary>
            @cfg {String/Function} url
            The url which the PollingProvider should contact with each request. This can also be
            an imported Ext.Direct method which will accept the baseParams as its only argument.
            </summary>
        </member>
        <member name="M:Ext.direct.PollingProvider.disconnect">
            <summary>
            Disconnect from the server-side and stop the polling process. The disconnect
            event will be fired on a successful disconnect.
            </summary>
        </member>
        <member name="P:Ext.direct.PollingProvider.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.PollingProvider.interval">
            <summary>
            @cfg {Number} interval
            How often to poll the server-side in milliseconds (defaults to <tt>3000</tt> - every
            3 seconds).
            </summary>
        </member>
        <member name="P:Ext.direct.PollingProviderConfig.baseParams">
            <summary>
            An object containing properties which are to be sent as parameters
            on every polling request
            </summary>
        </member>
        <member name="P:Ext.direct.PollingProviderConfig.interval">
            <summary>
            How often to poll the server-side in milliseconds (defaults to <tt>3000</tt> - every
            3 seconds).
            </summary>
        </member>
        <member name="M:Ext.direct.Provider.#ctor(System.Object)">
            <summary>
            @cfg {String} id
            The unique id of the provider (defaults to an {@link Ext#id auto-assigned id}).
            You should assign an id if you need to be able to access the provider later and you do
            not have an object reference available, for example:
            <pre><code>
            Ext.direct.Manager.addProvider({
            type: 'polling',
            url:  'php/poll.php',
            id:   'poll-provider'
            });
            var p = {@link Ext.direct.Manager}.{@link Ext.direct.Manager#getProvider getProvider}('poll-provider');
            p.disconnect();
            </code></pre>
            </summary>
        </member>
        <member name="M:Ext.direct.Provider.isConnected">
            <summary>
            Returns whether or not the server-side is currently connected.
            Abstract method for subclasses to implement.
            </summary>
        </member>
        <member name="P:Ext.direct.Provider.alias">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingEvent.getTransaction">
            <summary>
            Get the transaction associated with this event.
            @return {Ext.direct.Transaction} The transaction
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingEvent.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingEvent.Transaction">
            <summary>
            Get the transaction associated with this event.
            @return {Ext.direct.Transaction} The transaction
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingMethod.#ctor(System.Object)">
            <summary>
            Small utility class used internally to represent a Direct method.
            Thi class is used internally.
            @class Ext.direct.RemotingMethod
            @ignore
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.direct.RemotingMethod.getCallData(SharpKit.JavaScript.JsArray)" -->
        <member name="M:Ext.direct.RemotingProvider.combineAndSend">
            <summary>
            Combine any buffered requests and send them off
            @private
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.configureFormRequest(SharpKit.JavaScript.JsString,System.Object,SharpKit.Html4.HtmlElement,SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Configure a form submission request
            @private
            @param {String} action The action being executed
            @param {Object} method The method being executed
            @param {HTMLElement} form The form being submitted
            @param {Function} callback (optional) A callback to run after the form submits
            @param {Object} scope (optional) A scope to execute the callback in
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.configureRequest(SharpKit.JavaScript.JsString,System.Object,System.Object)">
            <summary>
            Configure a direct request
            @private
            @param {String} action The action being executed
            @param {Object} method The being executed
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.#ctor(System.Object)">
            <summary>
            @cfg {Number} timeout
            The timeout to use for each request. Defaults to <tt>undefined</tt>.
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.createHandler(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Create a handler function for a direct call.
            @private
            @param {String} action The action the call is for
            @param {Object} method The details of the method
            @return {Function} A JS function that will kick off the call
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.getCallData(Ext.direct.Transaction)">
            <summary>
            Gets the Ajax call info for a transaction
            @private
            @param {Ext.direct.Transaction} transaction The transaction
            @return {Object} The call params
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.getTransaction(System.Object)">
            <summary>
            Get transaction from XHR options
            @private
            @param {Object} options The options sent to the Ajax request
            @return {Ext.direct.Transaction} The transaction, null if not found
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.initAPI">
            <summary>
            Initialize the API
            @private
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.onData(System.Object,System.Object,System.Object)">
            <summary>
            React to the ajax request being completed
            @private
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.queueTransaction(Ext.direct.Transaction)">
            <summary>
            Add a new transaction to the queue
            @private
            @param {Ext.direct.Transaction} transaction The transaction
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.runCallback(Ext.direct.Transaction,Ext.direct.Event)">
            <summary>
            Run any callbacks related to the transaction.
            @private
            @param {Ext.direct.Transaction} transaction The transaction
            @param {Ext.direct.Event} event The event
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.sendFormRequest(Ext.direct.Transaction)">
            <summary>
            Sends a form request
            @private
            @param {Ext.direct.Transaction} transaction The transaction to send
            </summary>
        </member>
        <member name="M:Ext.direct.RemotingProvider.sendRequest(System.Object)">
            <summary>
            Sends a request to the server
            @private
            @param {Object/Array} data The data to send
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingProvider.alias">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.direct.RemotingProvider.enableBuffer" -->
        <member name="P:Ext.direct.RemotingProvider.maxRetries">
            <summary>
            @cfg {Number} maxRetries
            Number of times to re-attempt delivery on failure of a call. Defaults to <tt>1</tt>.
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingProviderConfig.actions">
            <summary>
            Object literal defining the server side actions and methods. For example, if
            the Provider is configured with:
            <pre><code>
            "actions":{ // each property within the 'actions' object represents a server side Class
            "TestAction":[ // array of methods within each server side Class to be
            {              // stubbed out on client
            "name":"doEcho",
            "len":1
            },{
            "name":"multiply",// name of method
            "len":2           // The number of parameters that will be used to create an
            // array of data to send to the server side function.
            // Ensure the server sends back a Number, not a String.
            },{
            "name":"doForm",
            "formHandler":true, // direct the client to use specialized form handling method
            "len":1
            }]
            }
            </code></pre>
            <p>Note that a Store is not required, a server method can be called at any time.
            In the following example a <b>client side</b> handler is used to call the
            server side method "multiply" in the server-side "TestAction" Class:</p>
            <pre><code>
            TestAction.multiply(
            2, 4, // pass two arguments to server, so specify len=2
            // callback function after the server is called
            // result: the result returned by the server
            //      e: Ext.direct.RemotingEvent object
            function(result, e){
            var t = e.getTransaction();
            var action = t.action; // server side Class called
            var method = t.method; // server side method called
            if(e.status){
            var answer = Ext.encode(result); // 8
            }else{
            var msg = e.message; // failure message
            }
            }
            );
            </code></pre>
            In the example above, the server side "multiply" function will be passed two
            arguments (2 and 4).  The "multiply" method should return the value 8 which will be
            available as the <tt>result</tt> in the example above.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.direct.RemotingProviderConfig.enableBuffer" -->
        <member name="P:Ext.direct.RemotingProviderConfig.enableUrlEncode">
            <summary>
            Specify which param will hold the arguments for the method.
            Defaults to <tt>'data'</tt>.
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingProviderConfig.maxRetries">
            <summary>
            Number of times to re-attempt delivery on failure of a call. Defaults to <tt>1</tt>.
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingProviderConfig.namespace">
            <summary>
            Namespace for the Remoting Provider (defaults to the browser global scope of <i>window</i>).
            Explicitly specify the namespace Object, or specify a String to have a
            {@link Ext#namespace namespace created} implicitly.
            </summary>
        </member>
        <member name="P:Ext.direct.RemotingProviderConfig.url">
            <summary>
            <b>Required</b>. The url to connect to the {@link Ext.direct.Manager} server-side router.
            </summary>
        </member>
        <member name="M:Ext.direct.Transaction.#ctor(System.Object)">
            <summary>
            Creates new Transaction.
            @param {Object} config  (optional) Config object.
            </summary>
        </member>
        <member name="P:Ext.direct.Transaction.alias">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="P:Ext.direct.Transaction.alternateClassName">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.contains(System.Object)">
            <summary>
            Returns true if this element is an ancestor of the passed element
            @param {HTMLElement/String} el The element to check
            @return {Boolean} True if this element is an ancestor of el, else false
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.getAttribute(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Returns the value of an attribute from the element's underlying DOM node.
            @param {String} name The attribute name
            @param {String} [namespace] The namespace in which to look for the attribute
            @return {String} The attribute value
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.getHTML">
            <summary>
            Returns the innerHTML of an Element or an empty string if the element's
            dom no longer exists.
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.getValue(System.Boolean)">
            <summary>
            Returns the value of the "value" attribute
            @param {Boolean} asNumber true to parse the value as a number
            @return {String/Number}
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.hide">
            <summary>
            Hide this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
            @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
            @return {Ext.Element} this
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.is(SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if this element matches the passed simple selector (e.g. div.some-class or span:first-child)
            @param {String} selector The simple selector to test
            @return {Boolean} True if this element matches the selector, else false
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.remove">
            <summary>
            Removes this element's dom reference. Note that event and cache removal is handled at {@link Ext#removeNode
            Ext.removeNode}
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.set(System.Object,System.Boolean)">
            <summary>
            Sets the passed attributes as attributes of this element (a style attribute can be a string, object or function)
            @param {Object} o The object with the attributes
            @param {Boolean} [useSet=true] false to override the default setAttribute to use expandos.
            @return {Ext.dom.Element} this
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.setHTML(SharpKit.JavaScript.JsString)">
            <summary>
            Set the innerHTML of this element
            @param {String} html The new HTML
            @return {Ext.Element} this
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.setVisibilityMode(System.Object)">
            <summary>
            Use this to change the visisbiliy mode between {@link #VISIBILITY}, {@link #DISPLAY} or {@link #OFFSETS}.
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.setVisible(System.Boolean,System.Object)">
            <summary>
            Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
            the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.
            @param {Boolean} visible Whether the element is visible
            @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
            @return {Ext.Element} this
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.show">
            <summary>
            Show this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
            @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
            @return {Ext.Element} this
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractElement.update(SharpKit.JavaScript.JsString)">
            <summary>
            Update the innerHTML of this element
            @param {String} html The new HTML
            @return {Ext.dom.Element} this
            </summary>
        </member>
        <member name="P:Ext.dom.AbstractElement.defaultUnit">
            <summary>
            @property {String} defaultUnit
            The default unit to append to CSS values where a unit isn't provided.
            </summary>
        </member>
        <member name="P:Ext.dom.AbstractElement.HTML">
            <summary>
            Set the innerHTML of this element
            @param {String} html The new HTML
            @return {Ext.Element} this
            </summary>
        </member>
        <member name="P:Ext.dom.AbstractElement.VisibilityMode">
            <summary>
            Use this to change the visisbiliy mode between {@link #VISIBILITY}, {@link #DISPLAY} or {@link #OFFSETS}.
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.append(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates new DOM element(s) and appends them to el.
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/String} o The DOM object spec (and children) or raw HTML blob
            @param {Boolean} [returnElement] true to return a Ext.Element
            @return {HTMLElement/Ext.Element} The new node
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.applyStyles(System.Object,System.Object)">
            <summary>
            Applies a style specification to an element.
            @param {String/HTMLElement} el The element to apply styles to
            @param {String/Object/Function} styles A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or
            a function which returns such a specification.
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.insertAfter(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates new DOM element(s) and inserts them after el.
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object} o The DOM object spec (and children)
            @param {Boolean} [returnElement] true to return a Ext.Element
            @return {HTMLElement/Ext.Element} The new node
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.insertBefore(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates new DOM element(s) and inserts them before el.
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/String} o The DOM object spec (and children) or raw HTML blob
            @param {Boolean} [returnElement] true to return a Ext.Element
            @return {HTMLElement/Ext.Element} The new node
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.insertFirst(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates new DOM element(s) and inserts them as the first child of el.
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/String} o The DOM object spec (and children) or raw HTML blob
            @param {Boolean} [returnElement] true to return a Ext.Element
            @return {HTMLElement/Ext.Element} The new node
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.dom.AbstractHelper.insertHtml(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsString)" -->
        <member name="M:Ext.dom.AbstractHelper.markup(System.Object)">
            <summary>
            Returns the markup for the passed Element(s) config.
            @param {Object} spec The DOM object spec (and children)
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractHelper.overwrite(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates new DOM element(s) and overwrites the contents of el with them.
            @param {String/HTMLElement/Ext.Element} el The context element
            @param {Object/String} o The DOM object spec (and children) or raw HTML blob
            @param {Boolean} [returnElement] true to return a Ext.Element
            @return {HTMLElement/Ext.Element} The new node
            </summary>
        </member>
        <member name="P:Ext.dom.AbstractHelper.confRe">
            <summary>
            @class Ext.dom.AbstractHelper
            Abstract base class for {@link Ext.dom.Helper}.
            @private
            </summary>
        </member>
        <member name="P:Ext.dom.AbstractHelper.emptyTags">
            <summary>
            @class Ext.dom.AbstractHelper
            Abstract base class for {@link Ext.dom.Helper}.
            @private
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractQuery.is(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the passed element(s) match the passed simple selector (e.g. div.some-class or span:first-child)
            @param {String/HTMLElement/Array} el An element id, element or array of elements
            @param {String} selector The simple selector to test
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractQuery.select(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Selects a group of elements.
            @param {String} selector The selector/xpath query (can be a comma separated list of selectors)
            @param {HTMLElement/String} [root] The start of the query (defaults to document).
            @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are
            no matches, and empty Array is returned.
            </summary>
        </member>
        <member name="M:Ext.dom.AbstractQuery.selectNode(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Selects a single element.
            @param {String} selector The selector/xpath query
            @param {HTMLElement/String} [root] The start of the query (defaults to document).
            @return {HTMLElement} The DOM element which matched the selector.
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.add(System.Object,System.Object)">
            <summary>
            Adds elements to this Composite object.
            @param {HTMLElement[]/Ext.dom.CompositeElementLite} els Either an Array of DOM elements to add, or another Composite
            object who's elements should be added.
            @return {Ext.dom.CompositeElementLite} This Composite object.
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.clear">
            <summary>
            Removes all elements.
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.contains(System.Object)">
            <summary>
            Returns true if this composite contains the passed element
            @param {String/HTMLElement/Ext.Element/Number} el The id of an element, or an Ext.Element, or an HtmlElement to
            find within the composite collection.
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.each(SharpKit.JavaScript.JsAction,Ext.dom.Element)">
            <summary>
            Calls the passed function for each element in this composite.
            @param {Function} fn The function to call.
            @param {Ext.dom.Element} fn.el The current Element in the iteration. **This is the flyweight
            (shared) Ext.dom.Element instance, so if you require_ a a reference to the dom node, use el.dom.**
            @param {Ext.dom.CompositeElementLite} fn.c This Composite object.
            @param {Number} fn.index The zero-based index in the iteration.
            @param {Object} [scope] The scope (this reference) in which the function is executed.
            Defaults to the Element.
            @return {Ext.dom.CompositeElementLite} this
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.fill(System.Object)">
            <summary>
            Clears this Composite and adds the elements passed.
            @param {HTMLElement[]/Ext.dom.CompositeElementLite} els Either an array of DOM elements, or another Composite from which
            to fill this Composite.
            @return {Ext.dom.CompositeElementLite} this
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.filter(System.Object)">
            <summary>
            Filters this composite to only elements that match the passed selector.
            @param {String/Function} selector A string CSS selector or a comparison function. The comparison function will be
            called with the following arguments:
            @param {Ext.dom.Element} selector.el The current DOM element.
            @param {Number} selector.index The current index within the collection.
            @return {Ext.dom.CompositeElementLite} this
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.first">
            <summary>
            Returns the first Element
            @return {Ext.dom.Element}
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.getCount">
            <summary>
            Returns the number of elements in this Composite.
            @return {Number}
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.indexOf(System.Object)">
            <summary>
            Find the index of the passed element within the composite collection.
            @param {String/HTMLElement/Ext.Element/Number} el The id of an element, or an Ext.dom.Element, or an HtmlElement
            to find within the composite collection.
            @return {Number} The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.item(SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns a flyweight Element of the dom element object at the specified index
            @param {Number} index
            @return {Ext.dom.Element}
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.last">
            <summary>
            Returns the last Element
            @return {Ext.dom.Element}
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.removeElement(System.Object,System.Boolean)">
            <summary>
            Removes the specified element(s).
            @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
            element in this composite or an array of any of those.
            @param {Boolean} [removeDom] True to also remove the element from the document
            @return {Ext.dom.CompositeElementLite} this
            </summary>
        </member>
        <member name="M:Ext.dom.CompositeElementLite.replaceElement(System.Object,System.Object,System.Boolean)">
            <summary>
            Replaces the specified element with the passed element.
            @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
            element in this composite to replace.
            @param {String/Ext.Element} replacement The id of an element or the Element itself.
            @param {Boolean} [domReplace] True to remove and replace the element in the document too.
            @return {Ext.dom.CompositeElementLite} this
            </summary>
        </member>
        <member name="M:Ext.dom.Element.addCls(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Adds the given CSS class(es) to this Element
            @param {String} names The CSS class(es) to add to this element
            @param {String} prefix Optional prefix to prepend to each class
            @param {String} suffix Optional suffix to append to each class
            </summary>
        </member>
        <member name="M:Ext.dom.Element.removeCls(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Removes the given CSS class(es) from this Element
            @param {String} names The CSS class(es) to remove from this element
            @param {String} prefix Optional prefix to prepend to each class to be removed
            @param {String} suffix Optional suffix to append to each class to be removed
            </summary>
        </member>
        <member name="M:Ext.dom.Element.synchronize">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.dom.Element.alternateClassName">
            <summary>
            Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
            All instances of this class inherit the methods of Ext.Fx making visual effects easily available to all DOM elements.
            Note that the events documented in this class are not Ext events, they encapsulate browser events. To access the
            underlying browser event, see Ext.EventObject.browserEvent. Some older browsers may not support the full range of
            events. Which events are supported is beyond the control of Ext JS.
            ## Usage
            // by id
            var el = Ext.get("my-div");
            // by DOM element reference
            var el = Ext.get(myDivElement);
            ## Composite (Collections of) Elements
            For working with collections of Elements, see Ext.CompositeElement
            </summary>
        </member>
        <member name="P:Ext.dom.Element.extend">
            <summary>
            Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
            All instances of this class inherit the methods of Ext.Fx making visual effects easily available to all DOM elements.
            Note that the events documented in this class are not Ext events, they encapsulate browser events. To access the
            underlying browser event, see Ext.EventObject.browserEvent. Some older browsers may not support the full range of
            events. Which events are supported is beyond the control of Ext JS.
            ## Usage
            // by id
            var el = Ext.get("my-div");
            // by DOM element reference
            var el = Ext.get(myDivElement);
            ## Composite (Collections of) Elements
            For working with collections of Elements, see Ext.CompositeElement
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.dom.Helper.alternateClassName" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.dom.Helper.extend" -->
        <member name="P:Ext.dom.Query.alternateClassName">
            <summary>
            Provides functionality to select elements on the page based on a CSS selector. All selectors, attribute filters and
            pseudos below can be combined infinitely in any order. For example "div.foo:nth-child(odd)[@foo=bar].bar:first"
            would be a perfectly valid selector.
            ## Element Selectors:
            * \* any element
            * E an element with the tag E
            * E F All descendent elements of E that have the tag F
            * E > F or E/F all direct children elements of E that have the tag F
            * E + F all elements with the tag F that are immediately preceded by an element with the tag E
            * E ~ F all elements with the tag F that are preceded by a sibling element with the tag E
            ## Attribute Selectors:
            The use of @ and quotes are optional. For example, div[@foo='bar'] is also a valid attribute selector.
            * E[foo] has an attribute "foo"
            * E[foo=bar] has an attribute "foo" that equals "bar"
            * E[foo^=bar] has an attribute "foo" that starts with "bar"
            * E[foo$=bar] has an attribute "foo" that ends with "bar"
            * E[foo*=bar] has an attribute "foo" that contains the substring "bar"
            * E[foo%=2] has an attribute "foo" that is evenly divisible by 2
            * E[foo!=bar] has an attribute "foo" that does not equal "bar"
            ## Pseudo Classes:
            * E:first-child E is the first child of its parent
            * E:last-child E is the last child of its parent
            * E:nth-child(n) E is the nth child of its parent (1 based as per the spec)
            * E:nth-child(odd) E is an odd child of its parent
            * E:nth-child(even) E is an even child of its parent
            * E:only-child E is the only child of its parent
            * E:checked E is an element that is has a checked attribute that is true (e.g. a radio or checkbox)
            * E:first the first E in the resultset
            * E:last the last E in the resultset
            * E:nth(n) the nth E in the resultset (1 based)
            * E:odd shortcut for :nth-child(odd)
            * E:even shortcut for :nth-child(even)
            * E:contains(foo) E's innerHTML contains the substring "foo"
            * E:nodeValue(foo) E contains a textNode with a nodeValue that equals "foo"
            * E:not(S) an E element that does not match simple selector S
            * E:has(S) an E element that has a descendent that matches simple selector S
            * E:next(S) an E element whose next sibling matches simple selector S
            * E:prev(S) an E element whose previous sibling matches simple selector S
            * E:any(S1|S2|S2) an E element which matches any of the simple selectors S1, S2 or S3//\\
            ## CSS Value Selectors:
            * E{display=none} css value "display" that equals "none"
            * E{display^=none} css value "display" that starts with "none"
            * E{display$=none} css value "display" that ends with "none"
            * E{display*=none} css value "display" that contains the substring "none"
            * E{display%=2} css value "display" that is evenly divisible by 2
            * E{display!=none} css value "display" that does not equal "none"
            </summary>
        </member>
        <member name="P:Ext.dom.Query.extend">
            <summary>
            Provides functionality to select elements on the page based on a CSS selector. All selectors, attribute filters and
            pseudos below can be combined infinitely in any order. For example "div.foo:nth-child(odd)[@foo=bar].bar:first"
            would be a perfectly valid selector.
            ## Element Selectors:
            * \* any element
            * E an element with the tag E
            * E F All descendent elements of E that have the tag F
            * E > F or E/F all direct children elements of E that have the tag F
            * E + F all elements with the tag F that are immediately preceded by an element with the tag E
            * E ~ F all elements with the tag F that are preceded by a sibling element with the tag E
            ## Attribute Selectors:
            The use of @ and quotes are optional. For example, div[@foo='bar'] is also a valid attribute selector.
            * E[foo] has an attribute "foo"
            * E[foo=bar] has an attribute "foo" that equals "bar"
            * E[foo^=bar] has an attribute "foo" that starts with "bar"
            * E[foo$=bar] has an attribute "foo" that ends with "bar"
            * E[foo*=bar] has an attribute "foo" that contains the substring "bar"
            * E[foo%=2] has an attribute "foo" that is evenly divisible by 2
            * E[foo!=bar] has an attribute "foo" that does not equal "bar"
            ## Pseudo Classes:
            * E:first-child E is the first child of its parent
            * E:last-child E is the last child of its parent
            * E:nth-child(n) E is the nth child of its parent (1 based as per the spec)
            * E:nth-child(odd) E is an odd child of its parent
            * E:nth-child(even) E is an even child of its parent
            * E:only-child E is the only child of its parent
            * E:checked E is an element that is has a checked attribute that is true (e.g. a radio or checkbox)
            * E:first the first E in the resultset
            * E:last the last E in the resultset
            * E:nth(n) the nth E in the resultset (1 based)
            * E:odd shortcut for :nth-child(odd)
            * E:even shortcut for :nth-child(even)
            * E:contains(foo) E's innerHTML contains the substring "foo"
            * E:nodeValue(foo) E contains a textNode with a nodeValue that equals "foo"
            * E:not(S) an E element that does not match simple selector S
            * E:has(S) an E element that has a descendent that matches simple selector S
            * E:next(S) an E element whose next sibling matches simple selector S
            * E:prev(S) an E element whose previous sibling matches simple selector S
            * E:any(S1|S2|S2) an E element which matches any of the simple selectors S1, S2 or S3//\\
            ## CSS Value Selectors:
            * E{display=none} css value "display" that equals "none"
            * E{display^=none} css value "display" that starts with "none"
            * E{display$=none} css value "display" that ends with "none"
            * E{display*=none} css value "display" that contains the substring "none"
            * E{display%=2} css value "display" that is evenly divisible by 2
            * E{display!=none} css value "display" that does not equal "none"
            </summary>
        </member>
        <member name="M:Ext.env.Browser.setFlag(System.Object,System.Object)">
            <summary>
            Read-only, refer to {@link Ext.Version}
            @type Ext.Version
            </summary>
        </member>
        <member name="P:Ext.env.Browser.engineName">
            <summary>
            Read-only - the full name of the current browser's engine
            Possible values are: WebKit, Gecko, Presto, Trident and Other
            @type String
            </summary>
        </member>
        <member name="P:Ext.env.Browser.engineVersion">
            <summary>
            Read-only, refer to {@link Ext.Version}
            @type Ext.Version
            </summary>
        </member>
        <member name="P:Ext.env.Browser.name">
            <summary>
            Read-only - the full name of the current browser
            Possible values are: IE, Firefox, Safari, Chrome, Opera and Other
            @type String
            </summary>
        </member>
        <member name="P:Ext.env.Browser.version">
            <summary>
            Read-only, refer to {@link Ext.Version}
            @type Ext.Version
            </summary>
        </member>
        <member name="M:Ext.env.OS.setFlag(System.Object,System.Object)">
            <summary>
            Read-only, refer to {@link Ext.Version}
            @type Ext.Version
            </summary>
        </member>
        <member name="P:Ext.env.OS.name">
            <summary>
            Read-only - the full name of the current operating system
            Possible values are: iOS, Android, WebOS, BlackBerry, MacOSX, Windows, Linux and Other
            @type String
            </summary>
        </member>
        <member name="P:Ext.env.OS.version">
            <summary>
            Read-only, refer to {@link Ext.Version}
            @type Ext.Version
            </summary>
        </member>
        <member name="M:Ext.event.Dom.getTarget(SharpKit.JavaScript.JsString,System.Object,System.Boolean)">
            <summary>
            Gets the target for the event.
            @param {String} selector (optional) A simple selector to filter the target or look for an ancestor of the target
            @param {Number/Mixed} maxDepth (optional) The max depth to
            search as a number or element (defaults to 10 || document.body)
            @param {Boolean} returnEl (optional) True to return a Ext.Element object instead of DOM node
            @return {HTMLElement}
            </summary>
        </member>
        <member name="M:Ext.event.Dom.getXY">
            <summary>
            @deprecated
            </summary>
        </member>
        <member name="P:Ext.event.Dom.extend">
            <summary>
            </summary>
        </member>
        <member name="P:Ext.event.Event.alternateClassName">
            <summary>
            Represents an event.
            @class Ext.event.Event
            @alternateClassName Ext.EventObject
            </summary>
        </member>
        <member name="P:Ext.event.Event.isStopped">
            <summary>
            Represents an event.
            @class Ext.event.Event
            @alternateClassName Ext.EventObject
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.check">
            <summary>
            Set the checked state of the checkbox to true
            @return {Ext.field.Checkbox} This checkbox
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.getChecked">
            <summary>
            Returns the field checked value
            @return {Mixed} The field value
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.getGroupValues">
            <summary>
            Returns an array of values from the checkboxes in the group that are checked,
            @return {Array}
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.isChecked">
            <summary>
            Returns the checked state of the checkbox.
            @return {Boolean} True if checked, else otherwise
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.resetGroupValues">
            <summary>
            Resets the status of all matched checkboxes in the same group to checked
            @param {Array} values An array of values
            @return {Ext.field.Checkbox} This checkbox
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.setGroupValues(SharpKit.JavaScript.JsArray)">
            <summary>
            Set the status of all matched checkboxes in the same group to checked
            @param {Array} values An array of values
            @return {Ext.field.Checkbox} This checkbox
            </summary>
        </member>
        <member name="M:Ext.field.Checkbox.uncheck">
            <summary>
            Set the checked state of the checkbox to false
            @return {Ext.field.Checkbox} This checkbox
            </summary>
        </member>
        <member name="P:Ext.field.Checkbox.alternateClassName">
            <summary>
            The checkbox field is an enhanced version of the native browser checkbox and is great for enabling your user to
            choose one or more items from a set (for example choosing toppings for a pizza order). It works like any other
            {@link Ext.field.Field field} and is usually found in the context of a form:
            ## Example
            @example preview
            var form = Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'checkboxfield',
            name : 'tomato',
            label: 'Tomato',
            value: 'tomato',
            checked: true
            },
            {
            xtype: 'checkboxfield',
            name : 'salami',
            label: 'Salami'
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            { xtype: 'spacer' },
            {
            text: 'getValues',
            handler: function() {
            var form = Ext.ComponentQuery.query('formpanel')[0],
            values = form.getValues();
            Ext.Msg.alert(null,
            "Tomato: " + ((values.tomato) ? "yes" : "no")
            + "<br />Salami: " + ((values.salami) ? "yes" : "no")
            );
            }
            },
            { xtype: 'spacer' }
            ]
            }
            ]
            });
            The form above contains two check boxes - one for Tomato, one for Salami. We configured the Tomato checkbox to be
            checked immediately on load, and the Salami checkbox to be unchecked. We also specified an optional text
            {@link #value} that will be sent when we submit the form. We can get this value using the Form's
            {@link Ext.form.Panel#getValues getValues} function, or have it sent as part of the data that is sent when the
            form is submitted:
            form.getValues(); //contains a key called 'tomato' if the Tomato field is still checked
            form.submit(); //will send 'tomato' in the form submission data
            </summary>
        </member>
        <member name="P:Ext.field.Checkbox.extend">
            <summary>
            The checkbox field is an enhanced version of the native browser checkbox and is great for enabling your user to
            choose one or more items from a set (for example choosing toppings for a pizza order). It works like any other
            {@link Ext.field.Field field} and is usually found in the context of a form:
            ## Example
            @example preview
            var form = Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'checkboxfield',
            name : 'tomato',
            label: 'Tomato',
            value: 'tomato',
            checked: true
            },
            {
            xtype: 'checkboxfield',
            name : 'salami',
            label: 'Salami'
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            { xtype: 'spacer' },
            {
            text: 'getValues',
            handler: function() {
            var form = Ext.ComponentQuery.query('formpanel')[0],
            values = form.getValues();
            Ext.Msg.alert(null,
            "Tomato: " + ((values.tomato) ? "yes" : "no")
            + "<br />Salami: " + ((values.salami) ? "yes" : "no")
            );
            }
            },
            { xtype: 'spacer' }
            ]
            }
            ]
            });
            The form above contains two check boxes - one for Tomato, one for Salami. We configured the Tomato checkbox to be
            checked immediately on load, and the Salami checkbox to be unchecked. We also specified an optional text
            {@link #value} that will be sent when we submit the form. We can get this value using the Form's
            {@link Ext.form.Panel#getValues getValues} function, or have it sent as part of the data that is sent when the
            form is submitted:
            form.getValues(); //contains a key called 'tomato' if the Tomato field is still checked
            form.submit(); //will send 'tomato' in the form submission data
            </summary>
        </member>
        <member name="P:Ext.field.Checkbox.GroupValues">
            <summary>
            Set the status of all matched checkboxes in the same group to checked
            @param {Array} values An array of values
            @return {Ext.field.Checkbox} This checkbox
            </summary>
        </member>
        <member name="P:Ext.field.CheckboxConfig.checked">
            <summary>
            <tt>true</tt> if the checkbox should render initially checked
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.CheckboxConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.CheckboxConfig.value">
            <summary>
            The string value to submit if the item is in a checked state.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.DatePicker.getFormattedValue(System.Boolean)">
            <summary>
            Returns the value of the field, which will be a {@link Date} unless the <tt>format</tt> parameter is true.
            @param {Boolean} format True to format the value with <tt>Ext.util.Format.defaultDateFormat</tt>
            </summary>
        </member>
        <member name="M:Ext.field.DatePicker.onMaskTap">
            <summary>
            @private
            Listener to the tap event of the mask element. Shows the internal {@link #datePicker} component when the button has been tapped.
            </summary>
        </member>
        <member name="M:Ext.field.DatePicker.onPickerChange(Ext.picker.Date,System.Object)">
            <summary>
            Called when the picker changes its value
            @param {Ext.picker.Date} picker The date picker
            @param {Object} value The new value from the date picker
            @private
            </summary>
        </member>
        <member name="M:Ext.field.DatePicker.onPickerHide">
            <summary>
            Destroys the picker when it is hidden, if
            {@link Ext.field.DatePicker#destroyPickerOnHide destroyPickerOnHide} is set to true
            @private
            </summary>
        </member>
        <member name="P:Ext.field.DatePicker.alternateClassName">
            <summary>
            This is a specialized field which shows a {@link Ext.picker.Date} when tapped. If it has a predefined value,
            or a value is selected in the {@link Ext.picker.Date}, it will be displayed like a normal {@link Ext.field.Text}
            (but not selectable/changable).
            Ext.create('Ext.field.DatePicker', {
            label: 'Birthday',
            value: new Date()
            });
            {@link Ext.field.DatePicker} fields are very simple to implement, and have no required configurations.
            ## Examples
            It can be very useful to set a default {@link #value} configuration on {@link Ext.field.DatePicker} fields. In
            this example, we set the {@link #value} to be the current date. You can also use the {@link #setValue} method to
            update the value at any time.
            @example preview
            Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'fieldset',
            items: [
            {
            xtype: 'datepickerfield',
            label: 'Birthday',
            name: 'birthday',
            value: new Date()
            }
            ]
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            { xtype: 'spacer' },
            {
            text: 'setValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            var randomNumber = function(from, to) {
            (to - from + 1) + from);
            };
            datePickerField.setValue({
            month: randomNumber(0, 11),
            day  : randomNumber(0, 28),
            year : randomNumber(1980, 2011)
            });
            }
            },
            { xtype: 'spacer' }
            ]
            }
            ]
            });
            When you need to retrieve the date from the {@link Ext.field.DatePicker}, you can either use the {@link #getValue} or
            {@link #getFormattedValue} methods:
            @example preview
            Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'fieldset',
            items: [
            {
            xtype: 'datepickerfield',
            label: 'Birthday',
            name: 'birthday',
            value: new Date()
            }
            ]
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            {
            text: 'getValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            Ext.Msg.alert(null, datePickerField.getValue());
            }
            },
            { xtype: 'spacer' },
            {
            text: 'getFormattedValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            Ext.Msg.alert(null, datePickerField.getFormattedValue());
            }
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.field.DatePicker.extend">
            <summary>
            This is a specialized field which shows a {@link Ext.picker.Date} when tapped. If it has a predefined value,
            or a value is selected in the {@link Ext.picker.Date}, it will be displayed like a normal {@link Ext.field.Text}
            (but not selectable/changable).
            Ext.create('Ext.field.DatePicker', {
            label: 'Birthday',
            value: new Date()
            });
            {@link Ext.field.DatePicker} fields are very simple to implement, and have no required configurations.
            ## Examples
            It can be very useful to set a default {@link #value} configuration on {@link Ext.field.DatePicker} fields. In
            this example, we set the {@link #value} to be the current date. You can also use the {@link #setValue} method to
            update the value at any time.
            @example preview
            Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'fieldset',
            items: [
            {
            xtype: 'datepickerfield',
            label: 'Birthday',
            name: 'birthday',
            value: new Date()
            }
            ]
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            { xtype: 'spacer' },
            {
            text: 'setValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            var randomNumber = function(from, to) {
            (to - from + 1) + from);
            };
            datePickerField.setValue({
            month: randomNumber(0, 11),
            day  : randomNumber(0, 28),
            year : randomNumber(1980, 2011)
            });
            }
            },
            { xtype: 'spacer' }
            ]
            }
            ]
            });
            When you need to retrieve the date from the {@link Ext.field.DatePicker}, you can either use the {@link #getValue} or
            {@link #getFormattedValue} methods:
            @example preview
            Ext.create('Ext.form.Panel', {
            fullscreen: true,
            items: [
            {
            xtype: 'fieldset',
            items: [
            {
            xtype: 'datepickerfield',
            label: 'Birthday',
            name: 'birthday',
            value: new Date()
            }
            ]
            },
            {
            xtype: 'toolbar',
            docked: 'bottom',
            items: [
            {
            text: 'getValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            Ext.Msg.alert(null, datePickerField.getValue());
            }
            },
            { xtype: 'spacer' },
            {
            text: 'getFormattedValue',
            handler: function() {
            var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
            Ext.Msg.alert(null, datePickerField.getFormattedValue());
            }
            }
            ]
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.field.DatePickerConfig.destroyPickerOnHide">
            <summary>
            Whether or not to destroy the picker widget on hide. This save memory if it's not used frequently,
            but increase delay time on the next show due to re-instantiation. Defaults to false
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.DatePickerConfig.picker">
            <summary>
            An object that is used when creating the internal {@link Ext.picker.Date} component or a direct instance of {@link Ext.picker.Date}
            Defaults to true
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.DatePickerConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.DatePickerConfig.value">
            <summary>
            Default value for the field and the internal {@link Ext.picker.Date} component. Accepts an object of 'year',
            'month' and 'day' values, all of which should be numbers, or a {@link Date}.
            *
            Example: {year: 1989, day: 1, month: 5} = 1st May 1989 or new Date()
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.Email.alternateClassName">
            <summary>
            The Email field creates an HTML5 email input and is usually created inside a form. Because it creates an HTML email
            input field, most browsers will show a specialized virtual keyboard for email address input. Aside from that, the
            email field is just a normal text field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'emailfield',
            label: 'Email',
            name: 'email'
            },
            {
            xtype: 'passwordfield',
            label: 'Password',
            name: 'password'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Email', {
            label: 'Email address',
            value: 'prefilled@email.com'
            });
            Because email field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
            provide, including getting and setting the value at runtime, validations and various events that are fired as the
            user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="P:Ext.field.Email.extend">
            <summary>
            The Email field creates an HTML5 email input and is usually created inside a form. Because it creates an HTML email
            input field, most browsers will show a specialized virtual keyboard for email address input. Aside from that, the
            email field is just a normal text field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'emailfield',
            label: 'Email',
            name: 'email'
            },
            {
            xtype: 'passwordfield',
            label: 'Password',
            name: 'password'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Email', {
            label: 'Email address',
            value: 'prefilled@email.com'
            });
            Because email field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
            provide, including getting and setting the value at runtime, validations and various events that are fired as the
            user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="M:Ext.field.Field.applyClearIcon(System.Object)">
            <summary>
            Creates a new {@link Ext.form.ClearIcon} instance using {@link Ext.Factory}
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.applyInput(System.Object)">
            <summary>
            Creates a new {@link Ext.field.Input} instance using {@link Ext.Factory}
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.applyLabel(System.Object)">
            <summary>
            Creates a new {@link Ext.form.Label} instance using {@link Ext.Factory}
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.doInitValue">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.getValue">
            <summary>
            Returns the field data value
            @return {String} The field value
            </summary>
        </member>
        <member name="M:Ext.field.Field.isDirty">
            <summary>
            <p>Returns true if the value of this Field has been changed from its {@link #originalValue}.
            Will return false if the field is disabled or has not been rendered yet.</p>
            @return {Boolean} True if this field has been changed from its original value (and
            is not disabled), false otherwise.
            </summary>
        </member>
        <member name="M:Ext.field.Field.onLabelAlignChange(System.Object,System.Object,System.Object)">
            <summary>
            Updates the class on this field when the label alignment changes
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.reset">
            <summary>
            Resets the current field value to the originally loaded value and clears any validation messages.
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateClearIcon(System.Object)">
            <summary>
            Adds the new {@link Ext.form.ClearIcon} instance into this field
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateInput(System.Object)">
            <summary>
            Adds the new {@link Ext.field.Input} instance into this field
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateInputType(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateLabel(System.Object,System.Object)">
            <summary>
            Adds the new {@link Ext.form.Label} instance into this field
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateLabelAlign(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateLabelCls(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateLabelWidth(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateName(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateRequired(System.Object)">
            <summary>
            Updates the {@link #required} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateRequiredCls(System.Object,System.Object)">
            <summary>
            Updates the {@link #required} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateTabIndex(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Field.updateValue(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.Field.alternateClassName">
            <summary>
            Field is the base class for all form fields used in Sencha Touch. It provides a lot of shared functionality to all
            field subclasses (for example labels, simple validation, {@link #clearIcon clearing} and tab index management), but
            is rarely used directly. Instead, it is much more common to use one of the field subclasses:
            *
            <pre>
            xtype            Class
            ---------------------------------------
            textfield        {@link Ext.field.Text}
            numberfield      {@link Ext.field.Number}
            textareafield    {@link Ext.field.TextArea}
            hiddenfield      {@link Ext.field.Hidden}
            radiofield       {@link Ext.field.Radio}
            checkboxfield    {@link Ext.field.Checkbox}
            selectfield      {@link Ext.field.Select}
            togglefield      {@link Ext.field.Toggle}
            fieldset         {@link Ext.form.FieldSet}
            </pre>
            *
            Fields are normally used within the context of a form and/or fieldset. See the {@link Ext.form.Panel FormPanel}
            and {@link Ext.form.FieldSet FieldSet} docs for examples on how to put those together, or the list of links above
            for usage of individual field types. If you wish to create your own Field subclasses you can extend this class,
            though it is sometimes more useful to extend {@link Ext.field.Text} as this provides additional text entry
            functionality.
            </summary>
        </member>
        <member name="P:Ext.field.Field.extend">
            <summary>
            Field is the base class for all form fields used in Sencha Touch. It provides a lot of shared functionality to all
            field subclasses (for example labels, simple validation, {@link #clearIcon clearing} and tab index management), but
            is rarely used directly. Instead, it is much more common to use one of the field subclasses:
            *
            <pre>
            xtype            Class
            ---------------------------------------
            textfield        {@link Ext.field.Text}
            numberfield      {@link Ext.field.Number}
            textareafield    {@link Ext.field.TextArea}
            hiddenfield      {@link Ext.field.Hidden}
            radiofield       {@link Ext.field.Radio}
            checkboxfield    {@link Ext.field.Checkbox}
            selectfield      {@link Ext.field.Select}
            togglefield      {@link Ext.field.Toggle}
            fieldset         {@link Ext.form.FieldSet}
            </pre>
            *
            Fields are normally used within the context of a form and/or fieldset. See the {@link Ext.form.Panel FormPanel}
            and {@link Ext.form.FieldSet FieldSet} docs for examples on how to put those together, or the list of links above
            for usage of individual field types. If you wish to create your own Field subclasses you can extend this class,
            though it is sometimes more useful to extend {@link Ext.field.Text} as this provides additional text entry
            functionality.
            </summary>
        </member>
        <member name="P:Ext.field.Field.isField">
            <summary>
            Set to true on all Ext.field.Field subclasses. This is used by {@link Ext.form.Panel#getValues} to determine which
            components inside a form are fields.
            @property isField
            @type Boolean
            </summary>
        </member>
        <member name="P:Ext.field.Field.Value">
            <summary>
            Returns the field data value
            @return {String} The field value
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.clearIcon">
            <summary>
            True to use a clear icon in this field
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.input">
            <summary>
            An instance of the inner input for this field, if one
            has been defined.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.inputType">
            <summary>
            The type attribute for input fields -- e.g. radio, text, password, file (defaults
            to 'text'). The types 'file' and 'password' must be used to render those field types currently -- there are
            no separate Ext components for those.
            This is now deprecated. Please use 'input.type' instead.
            @deprecated 2.0
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.label">
            <summary>
            The label to associate with this field.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.labelAlign">
            <summary>
            The position to render the label relative to the field input. Defaults to 'left'.
            See {@link Ext.form.Label} for more information
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.labelCls">
            <summary>
            Optional CSS class to add to the Label element
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.labelWidth">
            <summary>
            The width to make this field's label (defaults to 30%).
            See {@link Ext.form.Label} for more information
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.name">
            <summary>
            The field's HTML name attribute.
            <b>Note</b>: this property must be set if this field is to be automatically included with
            {@link Ext.form.Panel#submit form submit()}.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.required">
            <summary>
            True to make this field required. Note: this only causes a visual indication.
            Doesn't prevent user from submitting the form.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.requiredCls">
            <summary>
            The className to be applied to this Field when the {@link #required} configuration is set to true
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.tabIndex">
            <summary>
            The tabIndex for this field. Note this only applies to fields that are rendered,
            not those which are built via applyTo.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.useClearIcon">
            <summary>
            True to use a clear icon in this field
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.FieldConfig.value">
            <summary>
            A value to initialize this field with.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.Hidden.alternateClassName">
            <summary>
            Hidden fields allow you to easily inject additional data into a {@link Ext.form.Panel form} without displaying
            additional fields on the screen. This is often useful for sending dynamic or previously collected data back to the
            server in the same request as the normal form submission. For example, here is how we might set up a form to send
            back a hidden userId field:
            var form = Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Set your preferences'
            },
            items: [
            {
            xtype: 'hiddenfield',
            name: 'userId',
            value: 123
            },
            {
            xtype: 'checkboxfield',
            label: 'Enable notifications',
            name: 'notifications'
            }
            ]
            });
            In the form above we created two fields - a hidden field and a {@link Ext.field.Checkbox check box field}. Only the
            check box will be visible, but both fields will be submitted. Hidden fields cannot be tabbed to - they are removed
            from the tab index so when your user taps the next/previous field buttons the hidden field is skipped over.
            It's easy to read and update the value of a hidden field within a form. Using the example above, we can get a
            reference to the hidden field and then set it to a new value in 2 lines of code:
            var userId = form.down('hiddenfield')[0];
            userId.setValue(1234);
            </summary>
        </member>
        <member name="P:Ext.field.Hidden.extend">
            <summary>
            Hidden fields allow you to easily inject additional data into a {@link Ext.form.Panel form} without displaying
            additional fields on the screen. This is often useful for sending dynamic or previously collected data back to the
            server in the same request as the normal form submission. For example, here is how we might set up a form to send
            back a hidden userId field:
            var form = Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Set your preferences'
            },
            items: [
            {
            xtype: 'hiddenfield',
            name: 'userId',
            value: 123
            },
            {
            xtype: 'checkboxfield',
            label: 'Enable notifications',
            name: 'notifications'
            }
            ]
            });
            In the form above we created two fields - a hidden field and a {@link Ext.field.Checkbox check box field}. Only the
            check box will be visible, but both fields will be submitted. Hidden fields cannot be tabbed to - they are removed
            from the tab index so when your user taps the next/previous field buttons the hidden field is skipped over.
            It's easy to read and update the value of a hidden field within a form. Using the example above, we can get a
            reference to the hidden field and then set it to a new value in 2 lines of code:
            var userId = form.down('hiddenfield')[0];
            userId.setValue(1234);
            </summary>
        </member>
        <member name="P:Ext.field.HiddenConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.Input.blur">
            <summary>
            Attempts to forcefully blur input focus for the field.
            @return {Ext.field.Input} this
            </summary>
        </member>
        <member name="M:Ext.field.Input.focus">
            <summary>
            Attempts to set the field as the active input focus.
            @return {Ext.field.Input} this
            </summary>
        </member>
        <member name="M:Ext.field.Input.getChecked">
            <summary>
            Returns the checked value of this field
            @return {Mixed} value The field value
            </summary>
        </member>
        <member name="M:Ext.field.Input.getValue">
            <summary>
            Returns the field data value
            @return {Mixed} value The field value
            </summary>
        </member>
        <member name="M:Ext.field.Input.isDirty">
            <summary>
            <p>Returns true if the value of this Field has been changed from its original value.
            Will return false if the field is disabled or has not been rendered yet.</p>
            </summary>
        </member>
        <member name="M:Ext.field.Input.reset">
            <summary>
            Resets the current field value to the originally loaded value and clears any validation messages.
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateAutoCapitalize(System.Object)">
            <summary>
            Updates the autocapitalize attribute with the {@link #autoCapitalize} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateAutoComplete(System.Object)">
            <summary>
            Updates the autocomplete attribute with the {@link #autoComplete} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateAutoCorrect(System.Object)">
            <summary>
            Updates the autocorrect attribute with the {@link #autoCorrect} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateChecked(System.Object)">
            <summary>
            Updates the autocorrect attribute with the {@link #autoCorrect} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateFieldAttribute(System.Object,System.Object)">
            <summary>
            Helper method to update a specified attribute on the fieldEl, or remove the attribute all together
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateInputCls(System.Object,System.Object)">
            <summary>
            Updates the {@link #inputCls} configuration
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateMaxLength(System.Object)">
            <summary>
            Updates the maxlength attribute with the {@link #maxLength} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateMaxValue(System.Object)">
            <summary>
            Updates the max attribute with the {@link #maxValue} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateMinValue(System.Object)">
            <summary>
            Updates the min attribute with the {@link #minValue} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateName(System.Object)">
            <summary>
            Updates the name attribute with the {@link #name} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updatePlaceHolder(System.Object)">
            <summary>
            Updates the placeholder attribute with the {@link #placeHolder} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateStepValue(System.Object)">
            <summary>
            Updates the step attribute with the {@link #stepValue} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateTabIndex(System.Object)">
            <summary>
            Updates the tabIndex attribute with the {@link #tabIndex} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateType(System.Object,System.Object)">
            <summary>
            Updates the type attribute with the {@link #type} configuration
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateUseMask(System.Object)">
            <summary>
            Updates the useMask configuration
            </summary>
        </member>
        <member name="M:Ext.field.Input.updateValue(System.Object)">
            <summary>
            Updates the {@link #value} configuration
            @private
            </summary>
        </member>
        <member name="P:Ext.field.Input.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.Input.xtype">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.autoCapitalize">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.autoComplete">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.autoCorrect">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.checked">
            <summary>
            <tt>true</tt> if the checkbox should render initially checked (defaults to <tt>false</tt>)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.disabled">
            <summary>
            True to disable the field (defaults to false).
            <p>Be aware that conformant with the <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.12.1">HTML specification</a>,
            disabled Fields will not be {@link Ext.form.Panel#submit submitted}.</p>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.focusCls">
            <summary>
            The CSS class to use when the field receives focus
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.inputCls">
            <summary>
            The className to be applied to this input
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.maxLength">
            <summary>
            The maximum number of permitted input characters (defaults to 0).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.maxValue">
            <summary>
            The maximum value that this Number field can accept (defaults to undefined, e.g. no maximum)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.minValue">
            <summary>
            The minimum value that this Number field can accept (defaults to undefined, e.g. no minimium)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.name">
            <summary>
            The field's HTML name attribute
            <b>Note</b>: this property must be set if this field is to be automatically included with
            {@link Ext.form.Panel#submit form submit()}.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.originalValue">
            <summary>
            The original value when the input is rendered
            @private
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.placeHolder">
            <summary>
            A string value displayed in the input (if supported) when the control is empty.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.startValue">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.stepValue">
            <summary>
            The amount by which the field is incremented or decremented each time the spinner is tapped.
            Defaults to undefined, which means that the field goes up or down by 1 each time the spinner is tapped
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.tabIndex">
            <summary>
            The tabIndex for this field. Note this only applies to fields that are rendered,
            not those which are built via applyTo (defaults to undefined).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.tag">
            <summary>
            The el tag
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.type">
            <summary>
            The type attribute for input fields -- e.g. radio, text, password, file (defaults
            to 'text'). The types 'file' and 'password' must be used to render those field types currently -- there are
            no separate Ext components for those.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.useMask">
            <summary>
            @private
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.InputConfig.value">
            <summary>
            A value to initialize this field with (defaults to undefined).
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.Number.alias">
            <summary>
            The Number field creates an HTML5 number input and is usually created inside a form. Because it creates an HTML
            number input field, most browsers will show a specialized virtual keyboard for entering numbers. The Number field
            only accepts numerical input and also provides additional spinner UI that increases or decreases the current value
            by a configured {@link #stepValue step value}. Here's how we might use one in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'numberfield',
            label: 'Age',
            minValue: 18,
            maxValue: 150,
            name: 'age'
            }
            ]
            }).show();
            Or on its own, outside of a form:
            Ext.create('Ext.field.Number', {
            label: 'Age',
            value: '26'
            }).show();
            ## minValue, maxValue and stepValue
            The {@link #minValue} and {@link #maxValue} configurations are self-explanatory and simply constrain the value
            entered to the range specified by the configured min and max values. The other option exposed by this component
            is {@link #stepValue}, which enables you to set how much the value changes every time the up and down spinners
            are tapped on. For example, to create a salary field that ticks up and down by $1,000 each tap we can do this:
            Ext.create('Ext.field.Number', {
            label: 'Salary',
            value: 30000,
            minValue: 25000,
            maxValue: 50000,
            stepValue: 1000
            });
            This creates a field that starts with a value of $30,000, steps up and down in $1,000 increments and will not go
            beneath $25,000 or above $50,000.
            Because number field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired as
            the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="P:Ext.field.Number.extend">
            <summary>
            The Number field creates an HTML5 number input and is usually created inside a form. Because it creates an HTML
            number input field, most browsers will show a specialized virtual keyboard for entering numbers. The Number field
            only accepts numerical input and also provides additional spinner UI that increases or decreases the current value
            by a configured {@link #stepValue step value}. Here's how we might use one in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'numberfield',
            label: 'Age',
            minValue: 18,
            maxValue: 150,
            name: 'age'
            }
            ]
            }).show();
            Or on its own, outside of a form:
            Ext.create('Ext.field.Number', {
            label: 'Age',
            value: '26'
            }).show();
            ## minValue, maxValue and stepValue
            The {@link #minValue} and {@link #maxValue} configurations are self-explanatory and simply constrain the value
            entered to the range specified by the configured min and max values. The other option exposed by this component
            is {@link #stepValue}, which enables you to set how much the value changes every time the up and down spinners
            are tapped on. For example, to create a salary field that ticks up and down by $1,000 each tap we can do this:
            Ext.create('Ext.field.Number', {
            label: 'Salary',
            value: 30000,
            minValue: 25000,
            maxValue: 50000,
            stepValue: 1000
            });
            This creates a field that starts with a value of $30,000, steps up and down in $1,000 increments and will not go
            beneath $25,000 or above $50,000.
            Because number field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired as
            the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="P:Ext.field.NumberConfig.maxValue">
            <summary>
            The maximum value that this Number field can accept
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.NumberConfig.minValue">
            <summary>
            The minimum value that this Number field can accept
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.NumberConfig.stepValue">
            <summary>
            The amount by which the field is incremented or decremented each time the spinner is tapped.
            Defaults to undefined, which means that the field goes up or down by 1 each time the spinner is tapped
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.Password.alias">
            <summary>
            The Password field creates a password input and is usually created inside a form. Because it creates a password
            field, when the user enters text it will show up as stars. Aside from that, the password field is just a normal text
            field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'emailfield',
            label: 'Email',
            name: 'email'
            },
            {
            xtype: 'passwordfield',
            label: 'Password',
            name: 'password'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Password', {
            label: 'Password',
            value: 'existingPassword'
            });
            Because the password field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired as
            the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="P:Ext.field.Password.extend">
            <summary>
            The Password field creates a password input and is usually created inside a form. Because it creates a password
            field, when the user enters text it will show up as stars. Aside from that, the password field is just a normal text
            field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Register'
            },
            items: [
            {
            xtype: 'emailfield',
            label: 'Email',
            name: 'email'
            },
            {
            xtype: 'passwordfield',
            label: 'Password',
            name: 'password'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Password', {
            label: 'Password',
            value: 'existingPassword'
            });
            Because the password field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired as
            the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="M:Ext.field.Radio.getGroupValue">
            <summary>
            Returns the selected value if this radio is part of a group (other radio fields with the same name, in the same FormPanel),
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.field.Radio.setGroupValue(SharpKit.JavaScript.JsString)">
            <summary>
            Set the matched radio field's status (that has the same value as the given string) to checked
            @param {String} value The value of the radio field to check
            @return {String}
            </summary>
        </member>
        <member name="P:Ext.field.Radio.alias">
            <summary>
            The radio field is an enhanced version of the native browser radio controls and is a good way of allowing your user
            to choose one option out of a selection of several (for example, choosing a favorite color):
            var form = Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'red',
            label: 'Red',
            checked: true
            },
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'green',
            label: 'Green'
            },
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'blue',
            label: 'Blue'
            }
            ]
            });
            Above we created a simple form which allows the user to pick a color from the options red, green and blue. Because
            we gave each of the fields above the same {@link #name}, the radio field ensures that only one of them can be
            checked at a time. When we come to get the values out of the form again or submit it to the server, only 1 value
            will be sent for each group of radio fields with the same name:
            form.getValues(); //looks like {color: 'red'}
            form.submit(); //sends a single field back to the server (in this case color: red)
            </summary>
        </member>
        <member name="P:Ext.field.Radio.extend">
            <summary>
            The radio field is an enhanced version of the native browser radio controls and is a good way of allowing your user
            to choose one option out of a selection of several (for example, choosing a favorite color):
            var form = Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'red',
            label: 'Red',
            checked: true
            },
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'green',
            label: 'Green'
            },
            {
            xtype: 'radiofield',
            name : 'color',
            value: 'blue',
            label: 'Blue'
            }
            ]
            });
            Above we created a simple form which allows the user to pick a color from the options red, green and blue. Because
            we gave each of the fields above the same {@link #name}, the radio field ensures that only one of them can be
            checked at a time. When we come to get the values out of the form again or submit it to the server, only 1 value
            will be sent for each group of radio fields with the same name:
            form.getValues(); //looks like {color: 'red'}
            form.submit(); //sends a single field back to the server (in this case color: red)
            </summary>
        </member>
        <member name="P:Ext.field.Radio.GroupValue">
            <summary>
            Set the matched radio field's status (that has the same value as the given string) to checked
            @param {String} value The value of the radio field to check
            @return {String}
            </summary>
        </member>
        <member name="P:Ext.field.Search.alias">
            <summary>
            The Search field creates an HTML5 search input and is usually created inside a form. Because it creates an HTML
            search input type, the visual styling of this input is slightly different to normal text input contrls (the corners
            are rounded), though the virtual keyboard displayed by the operating system is the standard keyboard control.
            As with all other form fields in Sencha Touch, the search field gains a "clear" button that appears whenever there
            is text entered into the form, and which removes that text when tapped.
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Search'
            },
            items: [
            {
            xtype: 'searchfield',
            label: 'Query',
            name: 'query'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Search', {
            label: 'Search:',
            value: 'query'
            });
            Because search field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired
            as the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional
            functionality available.
            </summary>
        </member>
        <member name="P:Ext.field.Search.extend">
            <summary>
            The Search field creates an HTML5 search input and is usually created inside a form. Because it creates an HTML
            search input type, the visual styling of this input is slightly different to normal text input contrls (the corners
            are rounded), though the virtual keyboard displayed by the operating system is the standard keyboard control.
            As with all other form fields in Sencha Touch, the search field gains a "clear" button that appears whenever there
            is text entered into the form, and which removes that text when tapped.
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Search'
            },
            items: [
            {
            xtype: 'searchfield',
            label: 'Query',
            name: 'query'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Search', {
            label: 'Search:',
            value: 'query'
            });
            Because search field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
            fields provide, including getting and setting the value at runtime, validations and various events that are fired
            as the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional
            functionality available.
            </summary>
        </member>
        <member name="M:Ext.field.Select.reset">
            <summary>
            Resets the Select field to the value of the first record in the store.
            @return {Ext.field.Select} this
            </summary>
        </member>
        <member name="M:Ext.field.Select.updateOptions(SharpKit.JavaScript.JsArray)">
            <summary>
            Updates the underlying &lt;options&gt; list with new values.
            @param {Array} options An array of options configurations to insert or append.
            <pre><code>
            selectBox.setOptions(
            [   {text: 'First Option',  value: 'first'},
            {text: 'Second Option', value: 'second'},
            {text: 'Third Option',  value: 'third'}
            ]).setValue('third');
            </code></pre>
            Note: option object member names should correspond with defined {@link #valueField valueField} and
            {@link #displayField displayField} values.
            @return {Ext.field.Select} this
            </summary>
        </member>
        <member name="P:Ext.field.Select.alias">
            <summary>
            Simple Select field wrapper. Example usage:
            <pre><code>
            new Ext.field.Select({
            options: [
            {text: 'First Option',  value: 'first'},
            {text: 'Second Option', value: 'second'},
            {text: 'Third Option',  value: 'third'}
            ]
            });
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.field.Select.extend">
            <summary>
            Simple Select field wrapper. Example usage:
            <pre><code>
            new Ext.field.Select({
            options: [
            {text: 'First Option',  value: 'first'},
            {text: 'Second Option', value: 'second'},
            {text: 'Third Option',  value: 'third'}
            ]
            });
            </code></pre>
            </summary>
        </member>
        <member name="P:Ext.field.Select.record">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.clearIcon">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.displayField">
            <summary>
            The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
            Select control. This resolved value is the visibly rendered value of the available selection options.
            (defaults to 'text')
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.hiddenName">
            <summary>
            Specify a hiddenName if you're using the {@link Ext.form.Panel#standardSubmit standardSubmit} option.
            This name will be used to post the underlying value of the select to the server.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.input">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.options">
            <summary>
            (Optional) An array of select options.
            <pre><code>
            [
            {text: 'First Option',  value: 'first'},
            {text: 'Second Option', value: 'second'},
            {text: 'Third Option',  value: 'third'}
            ]
            </code></pre>
            Note: option object member names should correspond with defined {@link #valueField valueField} and {@link #displayField displayField} values.
            This config will be ignore if a {@link #store store} instance is provided
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.store">
            <summary>
            (Optional) store instance used to provide selection options data.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.useClearIcon">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SelectConfig.valueField">
            <summary>
            The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
            Select control. (defaults to 'value')
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.Slider.constrain(SharpKit.JavaScript.JsNumber)">
            <summary>
            @private
            Takes a desired value of a thumb and returns the nearest snap value. e.g if minValue = 0, maxValue = 100, increment = 10 and we
            pass a value of 67 here, the returned value will be 70. The returned number is constrained within {@link minValue} and {@link maxValue},
            so in the above example 68 would be returned if {@link maxValue} was set to 68.
            @param {Number} value The value to snap
            @return {Number} The snapped value
            </summary>
        </member>
        <member name="M:Ext.field.Slider.disable">
            <summary>
            Disables the slider
            </summary>
        </member>
        <member name="M:Ext.field.Slider.enable">
            <summary>
            Enables the slider
            </summary>
        </member>
        <member name="M:Ext.field.Slider.getClosestThumb(System.Object)">
            <summary>
            Finds the closest thumb for a specified value
            @return {Ext.field.slider.Thumb} The thumb
            </summary>
        </member>
        <member name="M:Ext.field.Slider.getOffsetForValue(System.Object)">
            <summary>
            Returns the correct offset for a specified value, based on the {@link #minWidth}, {@link #maxWidth} and
            {@link #increment} configurations
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Slider.getThumb(SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns an instance of a thumb for a specifed index
            @param {Number} index The index of the thumb (defaults to 0)
            @return {Ext.field.slider.Thumb} The thumb instance
            </summary>
        </member>
        <member name="M:Ext.field.Slider.getValueForOffset(System.Object,System.Object)">
            <summary>
            Returns the correct value for a specified offset, based on the {@link #minWidth}, {@link #maxWidth} and
            {@link #increment} configurations. Rerverse of {@link #getOffsetForValue}
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Slider.getValues">
            <summary>
            Convience method. Calls {@link #getValue}
            </summary>
        </member>
        <member name="M:Ext.field.Slider.indexOf(Ext.field.slider.Thumb)">
            <summary>
            Returns the index of a specified thumb
            @param {Ext.field.slider.Thumb} thumb
            @return {Number} Index of the thumb
            </summary>
        </member>
        <member name="M:Ext.field.Slider.onChange(System.Object,System.Object)">
            <summary>
            Called when the value of any child {@link #thumbs} changes.
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Slider.setThumbsDisabled(System.Boolean)">
            <summary>
            @private
            Loops through each of the sliders {@link #thumbs} and calls disable/enable on each of them depending
            on the param specified.
            @param {Boolean} disable True to disable, false to enable
            </summary>
        </member>
        <member name="M:Ext.field.Slider.setValues">
            <summary>
            Convience method. Calls {@link #setValue}
            </summary>
        </member>
        <member name="M:Ext.field.Slider.updateValue(System.Object)">
            <summary>
            Updates the slides {@link #thumbs} with their new value(s)
            </summary>
        </member>
        <member name="P:Ext.field.Slider.alias">
            <summary>
            The slider is a way to allow the user to select a value from a given numerical range. You might use it for choosing
            a percentage, combine two of them to get min and max values, or use three of them to specify the hex values for a
            color. Each slider contains a single 'thumb' that can be dragged along the slider's length to change the value.
            Sliders are equally useful inside {@link Ext.form.Panel forms} and standalone. Here's how to quickly create a
            slider in form, in this case enabling a user to choose a percentage:
            *
            Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'sliderfield',
            label: 'Percentage',
            value: 50,
            {@link #minValue}: 0,
            {@link #maxValue}: 100
            }
            ]
            });
            *
            In this case we set a starting value of 50%, and defined the min and max values to be 0 and 100 respectively, giving
            us a percentage slider. Because this is such a common use case, the defaults for {@link #minValue} and
            {@link #maxValue} are already set to 0 and 100 so in the example above they could be removed.
            *
            It's often useful to render sliders outside the context of a form panel too. In this example we create a slider that
            allows a user to choose the waist measurement of a pair of jeans. Let's say the online store we're making this for
            sells jeans with waist sizes from 24 inches to 60 inches in 2 inch increments - here's how we might achieve that:
            *
            var slider = Ext.create('Ext.field.Slider', {
            label: 'Waist Measurement',
            minValue: 24,
            maxValue: 60,
            increment: 2,
            value: 32
            });
            *
            Now that we've got our slider, we can ask it what value it currently has and listen to events that it fires. For
            example, if we wanted our app to show different images for different sizes, we can listen to the {@link #change}
            event to be informed whenever the slider is moved:
            *
            slider.on('change', function(newValue, oldValue) {
            if (newValue > 40) {
            imgComponent.setSrc('large.png')
            } else {
            imgComponent.setSrc('small.png');
            }
            }, this);
            *
            Here we listened to the {@link #change} event on the slider and updated the background image of an
            {@link Ext.Img image component} based on what size the user selected. Of course, you can use any logic inside your
            event listener.
            </summary>
        </member>
        <member name="P:Ext.field.Slider.extend">
            <summary>
            The slider is a way to allow the user to select a value from a given numerical range. You might use it for choosing
            a percentage, combine two of them to get min and max values, or use three of them to specify the hex values for a
            color. Each slider contains a single 'thumb' that can be dragged along the slider's length to change the value.
            Sliders are equally useful inside {@link Ext.form.Panel forms} and standalone. Here's how to quickly create a
            slider in form, in this case enabling a user to choose a percentage:
            *
            Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'sliderfield',
            label: 'Percentage',
            value: 50,
            {@link #minValue}: 0,
            {@link #maxValue}: 100
            }
            ]
            });
            *
            In this case we set a starting value of 50%, and defined the min and max values to be 0 and 100 respectively, giving
            us a percentage slider. Because this is such a common use case, the defaults for {@link #minValue} and
            {@link #maxValue} are already set to 0 and 100 so in the example above they could be removed.
            *
            It's often useful to render sliders outside the context of a form panel too. In this example we create a slider that
            allows a user to choose the waist measurement of a pair of jeans. Let's say the online store we're making this for
            sells jeans with waist sizes from 24 inches to 60 inches in 2 inch increments - here's how we might achieve that:
            *
            var slider = Ext.create('Ext.field.Slider', {
            label: 'Waist Measurement',
            minValue: 24,
            maxValue: 60,
            increment: 2,
            value: 32
            });
            *
            Now that we've got our slider, we can ask it what value it currently has and listen to events that it fires. For
            example, if we wanted our app to show different images for different sizes, we can listen to the {@link #change}
            event to be informed whenever the slider is moved:
            *
            slider.on('change', function(newValue, oldValue) {
            if (newValue > 40) {
            imgComponent.setSrc('large.png')
            } else {
            imgComponent.setSrc('small.png');
            }
            }, this);
            *
            Here we listened to the {@link #change} event on the slider and updated the background image of an
            {@link Ext.Img image component} based on what size the user selected. Of course, you can use any logic inside your
            event listener.
            </summary>
        </member>
        <member name="P:Ext.field.Slider.ThumbsDisabled">
            <summary>
            @private
            Loops through each of the sliders {@link #thumbs} and calls disable/enable on each of them depending
            on the param specified.
            @param {Boolean} disable True to disable, false to enable
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.increment">
            <summary>
            The increment by which to snap each thumb when its value changes. Defaults to 1. Any thumb movement
            will be snapped to the nearest value that is a multiple of the increment (e.g. if increment is 10 and the user tries to move
            the thumb to 67, it will be snapped to 70 instead)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.maxValue">
            <summary>
            The highest value any thumb on this slider can be set to.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.minValue">
            <summary>
            The lowest value any thumb on this slider can be set to.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.thumbs">
            <summary>
            An array of {@link Ext.field.slider.Thumb}'s to be used in this slider.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SliderConfig.value">
            <summary>
            The value(s) of the sliders {@link #thumbs}. If you pass
            a number or a string, it will assume you have just 1 thumb.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.Spinner.updateInput(System.Object)">
            <summary>
            Updates the {@link #input} configuration
            </summary>
        </member>
        <member name="P:Ext.field.Spinner.alias">
            <summary>
            Wraps an HTML5 number field. Example usage:
            *
            new Ext.field.Spinner({
            minValue: 0,
            maxValue: 100,
            incrementValue: 2,
            cycle: true
            });
            *
            </summary>
        </member>
        <member name="P:Ext.field.Spinner.extend">
            <summary>
            Wraps an HTML5 number field. Example usage:
            *
            new Ext.field.Spinner({
            minValue: 0,
            maxValue: 100,
            incrementValue: 2,
            cycle: true
            });
            *
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.maxValue">
            <summary>
            The maximum allowed value.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.minValue">
            <summary>
            The minimum allowed value.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.accelerateOnTapHold">
            <summary>
            True if autorepeating should start slowly and accelerate.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.clearIcon">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.cycle">
            <summary>
            When set to true, it will loop the values of a minimum or maximum is reached.
            If the maximum value is reached, the value will be set to the minimum.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.incrementValue">
            <summary>
            Value that is added or subtracted from the current value when a spinner is used.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.SpinnerConfig.tabIndex">
            <summary>
            @hide
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.Text.blur">
            <summary>
            Attempts to forcefully blur input focus for the field.
            @return {Ext.field.Text} This field
            </summary>
        </member>
        <member name="M:Ext.field.Text.doKeyUp(System.Object)">
            <summary>
            Called when a key has been pressed in the {@link #input}
            @private
            </summary>
        </member>
        <member name="M:Ext.field.Text.focus">
            <summary>
            Attempts to set the field as the active input focus.
            @return {Ext.field.Text} This field
            </summary>
        </member>
        <member name="P:Ext.field.Text.alias">
            <summary>
            The text field is the basis for most of the input fields in Sencha Touch. It provides a baseline of shared
            functionality such as input validation, standard events, state management and look and feel. Typically we create
            text fields inside a form, like this:
            *
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Enter your name'
            },
            *
            items: [
            {
            xtype: 'textfield',
            label: 'First Name',
            name: 'firstName'
            },
            {
            xtype: 'textfield',
            label: 'Last Name',
            name: 'lastName'
            }
            ]
            });
            *
            This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
            *
            Ext.create('Ext.field.Text', {
            label: 'Your Name',
            value: 'Ed Spencer'
            });
            *
            ## Configuring
            *
            Text field offers several configuration options, including {@link #placeHolder}, {@link #maxLength},
            {@link #autoComplete}, {@link #autoCapitalize} and {@link #autoCorrect}. For example, here is how we would configure
            a text field to have a maximum length of 10 characters, with placeholder text that disappears when the field is
            focused:
            *
            Ext.create('Ext.field.Text', {
            label: 'Username',
            maxLength: 10,
            placeHolder: 'Enter your username'
            });
            *
            The autoComplete, autoCapitalize and autoCorrect configs simply set those attributes on the text field and allow the
            native browser to provide those capabilities. For example, to enable auto complete and auto correct, simply
            configure your text field like this:
            *
            Ext.create('Ext.field.Text', {
            label: 'Username',
            autoComplete: true,
            autoCorrect: true
            });
            *
            These configurations will be picked up by the native browser, which will enable the options at the OS level.
            *
            Text field inherits from {@link Ext.field.Field}, which is the base class for all fields in Sencha Touch and provides
            a lot of shared functionality for all fields, including setting values, clearing and basic validation. See the
            {@link Ext.field.Field} documentation to see how to leverage its capabilities.
            </summary>
        </member>
        <member name="P:Ext.field.Text.extend">
            <summary>
            The text field is the basis for most of the input fields in Sencha Touch. It provides a baseline of shared
            functionality such as input validation, standard events, state management and look and feel. Typically we create
            text fields inside a form, like this:
            *
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Enter your name'
            },
            *
            items: [
            {
            xtype: 'textfield',
            label: 'First Name',
            name: 'firstName'
            },
            {
            xtype: 'textfield',
            label: 'Last Name',
            name: 'lastName'
            }
            ]
            });
            *
            This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
            *
            Ext.create('Ext.field.Text', {
            label: 'Your Name',
            value: 'Ed Spencer'
            });
            *
            ## Configuring
            *
            Text field offers several configuration options, including {@link #placeHolder}, {@link #maxLength},
            {@link #autoComplete}, {@link #autoCapitalize} and {@link #autoCorrect}. For example, here is how we would configure
            a text field to have a maximum length of 10 characters, with placeholder text that disappears when the field is
            focused:
            *
            Ext.create('Ext.field.Text', {
            label: 'Username',
            maxLength: 10,
            placeHolder: 'Enter your username'
            });
            *
            The autoComplete, autoCapitalize and autoCorrect configs simply set those attributes on the text field and allow the
            native browser to provide those capabilities. For example, to enable auto complete and auto correct, simply
            configure your text field like this:
            *
            Ext.create('Ext.field.Text', {
            label: 'Username',
            autoComplete: true,
            autoCorrect: true
            });
            *
            These configurations will be picked up by the native browser, which will enable the options at the OS level.
            *
            Text field inherits from {@link Ext.field.Field}, which is the base class for all fields in Sencha Touch and provides
            a lot of shared functionality for all fields, including setting values, clearing and basic validation. See the
            {@link Ext.field.Field} documentation to see how to leverage its capabilities.
            </summary>
        </member>
        <member name="P:Ext.field.TextArea.alias">
            <summary>
            Creates an HTML textarea field on the page. This is useful whenever you need the user to enter large amounts of text
            (i.e. more than a few words). Typically, text entry on mobile devices is not a pleasant experience for the user so
            it's good to limit your use of text areas to only those occasions when freeform text is required or alternative
            input methods like select boxes or radio buttons are not possible. Text Areas are usually created inside forms, like
            this:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'About you'
            },
            items: [
            {
            xtype: 'textfield',
            label: 'Name',
            name: 'name'
            },
            {
            xtype: 'textareafield',
            label: 'Bio',
            {@link #maxRows}: 4,
            name: 'bio'
            }
            ]
            });
            *
            In the example above we're creating a form with a {@link Ext.field.Text text field} for the user's name and a text
            area for their bio. We used the {@link #maxRows} configuration on the text area to tell it to grow to a maximum of 4
            rows of text before it starts using a scroll bar inside the text area to scroll the text.
            We can also create a text area outside the context of a form, like this:
            This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
            Ext.create('Ext.field.TextArea', {
            label: 'About You',
            {@link #placeHolder}: 'Tell us about yourself...'
            });
            </summary>
        </member>
        <member name="P:Ext.field.TextArea.extend">
            <summary>
            Creates an HTML textarea field on the page. This is useful whenever you need the user to enter large amounts of text
            (i.e. more than a few words). Typically, text entry on mobile devices is not a pleasant experience for the user so
            it's good to limit your use of text areas to only those occasions when freeform text is required or alternative
            input methods like select boxes or radio buttons are not possible. Text Areas are usually created inside forms, like
            this:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'About you'
            },
            items: [
            {
            xtype: 'textfield',
            label: 'Name',
            name: 'name'
            },
            {
            xtype: 'textareafield',
            label: 'Bio',
            {@link #maxRows}: 4,
            name: 'bio'
            }
            ]
            });
            *
            In the example above we're creating a form with a {@link Ext.field.Text text field} for the user's name and a text
            area for their bio. We used the {@link #maxRows} configuration on the text area to tell it to grow to a maximum of 4
            rows of text before it starts using a scroll bar inside the text area to scroll the text.
            We can also create a text area outside the context of a form, like this:
            This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
            Ext.create('Ext.field.TextArea', {
            label: 'About You',
            {@link #placeHolder}: 'Tell us about yourself...'
            });
            </summary>
        </member>
        <member name="P:Ext.field.TextAreaConfig.maxRows">
            <summary>
            The maximum number of lines made visible by the input.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextAreaInput.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.TextAreaInput.xtype">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.TextAreaInputConfig.tag">
            <summary>
            The el tag
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextConfig.autoCapitalize">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextConfig.autoComplete">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextConfig.autoCorrect">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextConfig.maxLength">
            <summary>
            The maximum number of permitted input characters.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.TextConfig.placeHolder">
            <summary>
            A string value displayed in the input (if supported) when the control is empty.
            @deprecated 2.0
            @accessor
            </summary>
        </member>
        <member name="M:Ext.field.Toggle.onChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.field.Toggle.alias">
            <summary>
            Specialized Slider with a single thumb and only two values. By default the toggle component can
            be switched between the values of 0 and 1.
            </summary>
        </member>
        <member name="P:Ext.field.Toggle.extend">
            <summary>
            Specialized Slider with a single thumb and only two values. By default the toggle component can
            be switched between the values of 0 and 1.
            </summary>
        </member>
        <member name="P:Ext.field.ToggleConfig.maxValueCls">
            <summary>
            CSS class added to the field when toggled to its maxValue
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.ToggleConfig.minValueCls">
            <summary>
            CSS class added to the field when toggled to its minValue
            @accessor
            </summary>
        </member>
        <member name="P:Ext.field.Url.alias">
            <summary>
            The Url field creates an HTML5 url input and is usually created inside a form. Because it creates an HTML url input
            field, most browsers will show a specialized virtual keyboard for web address input. Aside from that, the url field
            is just a normal text field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Add Bookmark'
            },
            items: [
            {
            xtype: 'urlfield',
            label: 'Url',
            name: 'url'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Url', {
            label: 'Web address',
            value: 'http://sencha.com'
            });
            Because url field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
            provide, including getting and setting the value at runtime, validations and various events that are fired as the
            user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="P:Ext.field.Url.extend">
            <summary>
            The Url field creates an HTML5 url input and is usually created inside a form. Because it creates an HTML url input
            field, most browsers will show a specialized virtual keyboard for web address input. Aside from that, the url field
            is just a normal text field. Here's an example of how to use it in a form:
            Ext.create('Ext.form.Panel', {
            tbar: {
            text: 'Add Bookmark'
            },
            items: [
            {
            xtype: 'urlfield',
            label: 'Url',
            name: 'url'
            }
            ]
            });
            Or on its own, outside of a form:
            Ext.create('Ext.field.Url', {
            label: 'Web address',
            value: 'http://sencha.com'
            });
            Because url field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
            provide, including getting and setting the value at runtime, validations and various events that are fired as the
            user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
            available.
            </summary>
        </member>
        <member name="M:Ext.field.slider.Thumb.updateValue(System.Object)">
            <summary>
            Updates the offset of this thumb
            </summary>
        </member>
        <member name="P:Ext.field.slider.Thumb.extend">
            <summary>
            @ignore
            Utility class used by Ext.field.Slider - should never need to be used directly.
            </summary>
        </member>
        <member name="P:Ext.field.slider.Thumb.xtype">
            <summary>
            @ignore
            Utility class used by Ext.field.Slider - should never need to be used directly.
            </summary>
        </member>
        <member name="P:Ext.field.slider.ThumbConfig.value">
            <summary>
            The value to initialize this thumb with (defaults to 0)
            @accessor
            </summary>
        </member>
        <member name="M:Ext.form.ClearIcon.onTap(System.Object)">
            <summary>
            Called when this clear icon has been tapped on
            </summary>
        </member>
        <member name="P:Ext.form.ClearIcon.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.form.ClearIcon.xtype">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.form.FieldSet.alias">
            <summary>
            A FieldSet is a great way to visually separate elements of a form. It's normally used when you have a form with
            fields that can be divided into groups - for example a customer's billing details in one fieldset and their shipping
            address in another. A fieldset can be used inside a form or on its own elsewhere in your app. Fieldsets can
            optionally have a title at the top and instructions at the bottom. Here's how we might create a FieldSet inside a
            form:
            Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'fieldset',
            title: 'About You',
            instructions: 'Tell us all about yourself',
            items: [
            {
            xtype: 'textfield',
            name : 'firstName',
            label: 'First Name'
            },
            {
            xtype: 'textfield',
            name : 'lastName',
            label: 'Last Name'
            }
            ]
            }
            ]
            });
            Above we created a {@link Ext.form.Panel form} with a fieldset that contains two text fields. In this case, all
            of the form fields are in the same fieldset, but for longer forms we may choose to use multiple fieldsets. We also
            configured a {@link #title} and {@link #instructions} to give the user more information on filling out the form if
            required.
            </summary>
        </member>
        <member name="P:Ext.form.FieldSet.extend">
            <summary>
            A FieldSet is a great way to visually separate elements of a form. It's normally used when you have a form with
            fields that can be divided into groups - for example a customer's billing details in one fieldset and their shipping
            address in another. A fieldset can be used inside a form or on its own elsewhere in your app. Fieldsets can
            optionally have a title at the top and instructions at the bottom. Here's how we might create a FieldSet inside a
            form:
            Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'fieldset',
            title: 'About You',
            instructions: 'Tell us all about yourself',
            items: [
            {
            xtype: 'textfield',
            name : 'firstName',
            label: 'First Name'
            },
            {
            xtype: 'textfield',
            name : 'lastName',
            label: 'Last Name'
            }
            ]
            }
            ]
            });
            Above we created a {@link Ext.form.Panel form} with a fieldset that contains two text fields. In this case, all
            of the form fields are in the same fieldset, but for longer forms we may choose to use multiple fieldsets. We also
            configured a {@link #title} and {@link #instructions} to give the user more information on filling out the form if
            required.
            </summary>
        </member>
        <member name="P:Ext.form.FieldSetConfig.instructions">
            <summary>
            Optional fieldset instructions, rendered just below the grouped fields
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.FieldSetConfig.title">
            <summary>
            Optional fieldset title, rendered just above the grouped fields
            @accessor
            </summary>
        </member>
        <member name="M:Ext.form.Label.doSetAlign(System.Object)">
            <summary>
            Updates the {@link #align} configuration by changing the {@link #docked} configuration on the component
            @private
            </summary>
        </member>
        <member name="M:Ext.form.Label.updateText(System.Object)">
            <summary>
            Updates the {@link #text} configuration
            </summary>
        </member>
        <member name="P:Ext.form.Label.extend">
            <summary>
            The Label class is a simple component used to render the labels for each field in your Sencha Touch application. It
            is usually created for you when you create a field, like this:
            Ext.create('Ext.field.Text', {
            label: 'Your Name',
            value: 'Ed Spencer'
            });
            You can also specify a few more configurations for a label by passing a label object instead of a string:
            Ext.create('Ext.field.Text', {
            label: {
            {@link #text}: 'Your Name',
            {@link #align}: 'right',
            {@link #width}: '50%'
            },
            value: 'Ed Spencer'
            });
            It's rare to want to create a label without a form field but you can do it like this:
            Ext.create('Ext.form.Label', {
            text: 'My Label',
            width: 100
            });
            </summary>
        </member>
        <member name="P:Ext.form.Label.xtype">
            <summary>
            The Label class is a simple component used to render the labels for each field in your Sencha Touch application. It
            is usually created for you when you create a field, like this:
            Ext.create('Ext.field.Text', {
            label: 'Your Name',
            value: 'Ed Spencer'
            });
            You can also specify a few more configurations for a label by passing a label object instead of a string:
            Ext.create('Ext.field.Text', {
            label: {
            {@link #text}: 'Your Name',
            {@link #align}: 'right',
            {@link #width}: '50%'
            },
            value: 'Ed Spencer'
            });
            It's rare to want to create a label without a form field but you can do it like this:
            Ext.create('Ext.form.Label', {
            text: 'My Label',
            width: 100
            });
            </summary>
        </member>
        <member name="P:Ext.form.LabelConfig.align">
            <summary>
            The location to render the label of the field. Acceptable values are 'top', 'left' and 'right'.
            @accessor
            @evented
            </summary>
        </member>
        <member name="P:Ext.form.LabelConfig.text">
            <summary>
            The text to display in the label
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.LabelConfig.width">
            <summary>
            The width of the label, can be any valid CSS size. E.g '20%', '6em', '100px'.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.form.Panel.applyWaitTpl(System.Object)">
            <summary>
            Initializes the renderTpl.
            @return {Ext.XTemplate} The renderTpl XTemplate instance.
            @private
            </summary>
        </member>
        <member name="M:Ext.form.Panel.disable">
            <summary>
            A convenient method to disable all fields in this forms
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.enable">
            <summary>
            A convenient method to enable all fields in this forms
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.getFields(System.Object)">
            <summary>
            @private
            Returns all {@link Ext.Field field} instances inside this form
            @param byName return only fields that match the given name, otherwise return all fields.
            @return {Object/Array} All field instances, mapped by field name; or an array if byName is passed
            </summary>
        </member>
        <member name="M:Ext.form.Panel.getValues(System.Boolean)">
            <summary>
            Returns an object containing the value of each field in the form, keyed to the field's name.
            For groups of checkbox fields with the same name, it will be arrays of values. For examples:
            <pre><code>
            {
            name: "Jacky Nguyen", // From a TextField
            favorites: [
            'pizza',
            'noodle',
            'cake'
            ]
            }
            </code></pre>
            @param {Boolean} enabled <tt>true</tt> to return only enabled fields
            @return {Object} Object mapping field name to its value
            </summary>
        </member>
        <member name="M:Ext.form.Panel.hideMask">
            <summary>
            Hides a previously shown wait mask (See {@link #showMask})
            @return {Ext.form.Panel} this
            </summary>
        </member>
        <member name="M:Ext.form.Panel.reset">
            <summary>
            Resets all fields in the form back to their original values
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.setRecord(Ext.data.Model)">
            <summary>
            Loads matching fields from a model instance into this form
            @param {Ext.data.Model} instance The model instance
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.setValues(System.Object)">
            <summary>
            Sets the values of form fields in bulk. Example usage:
            *
            myForm.setValues({
            name: 'Ed',
            crazy: true,
            username: 'edspencer'
            });
            *
            If there groups of checkbox fields with the same name, pass their values in an array. For example:
            *
            myForm.setValues({
            name: 'Jacky',
            crazy: false,
            hobbies: [
            'reading',
            'cooking',
            'gaming'
            ]
            });
            *
            @param {Object} values field name => value mapping object
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.showMask(System.Object,System.Object)">
            <summary>
            Shows a generic/custom mask over a designated Element.
            @param {String/Object} cfg Either a string message or a configuration object supporting
            the following options:
            *
            {
            message : 'Please Wait',
            transparent : false,
            target  : Ext.getBody(),  //optional target Element
            cls : 'form-mask',
            customImageUrl : 'trident.jpg'
            }
            *
            This object is passed to the {@link #waitTpl} for use with a custom masking implementation.
            @param {String/HTMLElement/Ext.Element} target The target Element instance or Element id to use
            as the masking agent for the operation (defaults the container Element of the component)
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="M:Ext.form.Panel.submit(System.Object)">
            <summary>
            Performs a Ajax-based submission of form values (if standardSubmit is false) or otherwise
            executes a standard HTML Form submit action.
            @param {Object} options Unless otherwise noted, options may include the following:
            <ul>
            <li><b>url</b> : String
            <div class="sub-desc">
            The url for the action (defaults to the form's {@link #url url}.)
            </div></li>
            *
            <li><b>method</b> : String
            <div class="sub-desc">
            The form method to use (defaults to the form's method, or POST if not defined)
            </div></li>
            *
            <li><b>params</b> : String/Object
            <div class="sub-desc">
            The params to pass
            (defaults to the FormPanel's baseParams, or none if not defined)
            Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.
            </div></li>
            *
            <li><b>headers</b> : Object
            <div class="sub-desc">
            Request headers to set for the action
            (defaults to the form's default headers)
            </div></li>
            *
            <li><b>autoAbort</b> : Boolean
            <div class="sub-desc">
            <tt>true</tt> to abort any pending Ajax request prior to submission (defaults to false)
            Note: Has no effect when standardSubmit is enabled.
            </div></li>
            *
            <li><b>submitDisabled</b> : Boolean
            <div class="sub-desc">
            <tt>true</tt> to submit all fields regardless of disabled state (defaults to false)
            Note: Has no effect when standardSubmit is enabled.
            </div></li>
            *
            <li><b>waitMsg</b> : String/Config
            <div class="sub-desc">
            If specified, the value is applied to the {@link #waitTpl} if defined, and rendered to the
            {@link #maskTarget} prior to a Form submit action.
            </div></li>
            *
            <li><b>success</b>: function
            <div class="sub-desc">
            The callback that will be invoked after a successful response. A response is successful if
            a response is received from the server and is a JSON object where the success property is set
            to true, {"success": true}
            *
            The function is passed the following parameters:
            <ul>
            <li>form : Ext.form.Panel The form that requested the action</li>
            <li>result : The result object returned by the server as a result of the submit request.</li>
            </ul>
            </div></li>
            *
            <li><b>failure</b>: function
            <div class="sub-desc">
            The callback that will be invoked after a
            failed transaction attempt. The function is passed the following parameters:
            <ul>
            <li>form : The Ext.form.Panel that requested the submit.</li>
            <li>result : The failed response or result object returned by the server which performed the operation.</li>
            </ul>
            </div></li>
            *
            <li><b>scope</b> : Object
            <div class="sub-desc">
            The scope in which to call the callback functions (The this reference for the callback functions).
            </div></li>
            </ul>
            *
            @return {Ext.data.Connection} The request object
            </summary>
        </member>
        <member name="M:Ext.form.Panel.updateRecord(Ext.data.Model,System.Boolean)">
            <summary>
            Updates a model instance with the current values of this form
            @param {Ext.data.Model} instance The model instance
            @param {Boolean} enabled <tt>true</tt> to update the Model with values from enabled fields only
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="P:Ext.form.Panel.alternateClassName">
            <summary>
            The Form panel presents a set of form fields and provides convenient ways to load and save data. Usually a form
            panel just contains the set of fields you want to display, ordered inside the items configuration like this:
            *
            var form = Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'textfield',
            name: 'name',
            label: 'Name'
            },
            {
            xtype: 'emailfield',
            name: 'email',
            label: 'Email'
            },
            {
            xtype: 'passwordfield',
            name: 'password',
            label: 'Password'
            }
            ]
            });
            *
            Here we just created a simple form panel which could be used as a registration form to sign up to your service. We
            added a plain {@link Ext.field.Text text field} for the user's Name, an {@link Ext.field.Email email field} and
            finally a {@link Ext.field.Password password field}. In each case we provided a {@link Ext.field.Field#name name}
            config on the field so that we can identify it later on when we load and save data on the form.
            *
            <h2>Loading data</h2>
            *
            Using the form we created above, we can load data into it in a few different ways, the easiest is to use
            {@link #setValues}:
            *
            form.setValues({
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            });
            *
            It's also easy to load {@link Ext.data.Model Model} instances into a form - let's say we have a User model and want
            to load a particular instance into our form:
            *
            Ext.define('MyApp.model.User', {
            fields: ['name', 'email', 'password']
            });
            *
            var ed = Ext.create('MyApp.model.User', {
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            });
            *
            form.setRecord(ed);
            *
            <h2>Retrieving form data</h2>
            *
            Getting data out of the form panel is simple and is usually achieve vai the {@link #getValues} method:
            *
            var values = form.getValues();
            *
            //values now looks like this:
            {
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            }
            *
            It's also possible to listen to the change events on individual fields to get more timely notification of changes
            that the user is making. Here we expand on the example above with the User model, updating the model as soon as
            any of the fields are changed:
            *
            var form = Ext.create('Ext.form.Panel', {
            listeners: {
            '> field': {
            change: function(field, newValue, oldValue) {
            ed.set(field.getName(), newValue);
            }
            }
            },
            items: //as before
            });
            *
            The above used a new capability of Touch 2.0, which enables you to specify listeners on child components of any
            container. In this case, we attached a listener to the {@link Ext.field.Text#change change} event of each form
            field that is a direct child of the form panel. Our listener gets the name of the field that fired the change event,
            and updates our {@link Ext.data.Model Model} instance with the new value. For example, changing the email field
            in the form will update the Model's email field.
            *
            <h2>Submitting forms</h2>
            *
            There are a few ways to submit form data. In our example above we have a Model instance that we have updated, giving
            us the option to use the Model's {@link Ext.data.Model#save save} method to persist the changes back to our server,
            without using a traditional form submission. Alternatively, we can send a normal browser form submit using the
            {@link #submit} method:
            *
            form.submit({
            url: 'url/to/submit/to',
            method: 'POST',
            success: function() {
            alert('form submitted successfully!');
            }
            });
            *
            In this case we provided the url to submit the form to inside the submit call - alternatively you can just set the
            {@link #url} configuration when you create the form. We can specify other parameters (see {@link #submit} for a
            full list), including callback functions for success and failure, which are called depending on whether or not the
            form submission was successful. These functions are usually used to take some action in your app after your data
            has been saved to the server side.
            </summary>
        </member>
        <member name="P:Ext.form.Panel.extend">
            <summary>
            The Form panel presents a set of form fields and provides convenient ways to load and save data. Usually a form
            panel just contains the set of fields you want to display, ordered inside the items configuration like this:
            *
            var form = Ext.create('Ext.form.Panel', {
            items: [
            {
            xtype: 'textfield',
            name: 'name',
            label: 'Name'
            },
            {
            xtype: 'emailfield',
            name: 'email',
            label: 'Email'
            },
            {
            xtype: 'passwordfield',
            name: 'password',
            label: 'Password'
            }
            ]
            });
            *
            Here we just created a simple form panel which could be used as a registration form to sign up to your service. We
            added a plain {@link Ext.field.Text text field} for the user's Name, an {@link Ext.field.Email email field} and
            finally a {@link Ext.field.Password password field}. In each case we provided a {@link Ext.field.Field#name name}
            config on the field so that we can identify it later on when we load and save data on the form.
            *
            <h2>Loading data</h2>
            *
            Using the form we created above, we can load data into it in a few different ways, the easiest is to use
            {@link #setValues}:
            *
            form.setValues({
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            });
            *
            It's also easy to load {@link Ext.data.Model Model} instances into a form - let's say we have a User model and want
            to load a particular instance into our form:
            *
            Ext.define('MyApp.model.User', {
            fields: ['name', 'email', 'password']
            });
            *
            var ed = Ext.create('MyApp.model.User', {
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            });
            *
            form.setRecord(ed);
            *
            <h2>Retrieving form data</h2>
            *
            Getting data out of the form panel is simple and is usually achieve vai the {@link #getValues} method:
            *
            var values = form.getValues();
            *
            //values now looks like this:
            {
            name: 'Ed',
            email: 'ed@sencha.com',
            password: 'secret'
            }
            *
            It's also possible to listen to the change events on individual fields to get more timely notification of changes
            that the user is making. Here we expand on the example above with the User model, updating the model as soon as
            any of the fields are changed:
            *
            var form = Ext.create('Ext.form.Panel', {
            listeners: {
            '> field': {
            change: function(field, newValue, oldValue) {
            ed.set(field.getName(), newValue);
            }
            }
            },
            items: //as before
            });
            *
            The above used a new capability of Touch 2.0, which enables you to specify listeners on child components of any
            container. In this case, we attached a listener to the {@link Ext.field.Text#change change} event of each form
            field that is a direct child of the form panel. Our listener gets the name of the field that fired the change event,
            and updates our {@link Ext.data.Model Model} instance with the new value. For example, changing the email field
            in the form will update the Model's email field.
            *
            <h2>Submitting forms</h2>
            *
            There are a few ways to submit form data. In our example above we have a Model instance that we have updated, giving
            us the option to use the Model's {@link Ext.data.Model#save save} method to persist the changes back to our server,
            without using a traditional form submission. Alternatively, we can send a normal browser form submit using the
            {@link #submit} method:
            *
            form.submit({
            url: 'url/to/submit/to',
            method: 'POST',
            success: function() {
            alert('form submitted successfully!');
            }
            });
            *
            In this case we provided the url to submit the form to inside the submit call - alternatively you can just set the
            {@link #url} configuration when you create the form. We can specify other parameters (see {@link #submit} for a
            full list), including callback functions for success and failure, which are called depending on whether or not the
            form submission was successful. These functions are usually used to take some action in your app after your data
            has been saved to the server side.
            </summary>
        </member>
        <member name="P:Ext.form.Panel.Record">
            <summary>
            Loads matching fields from a model instance into this form
            @param {Ext.data.Model} instance The model instance
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="P:Ext.form.Panel.Values">
            <summary>
            Sets the values of form fields in bulk. Example usage:
            *
            myForm.setValues({
            name: 'Ed',
            crazy: true,
            username: 'edspencer'
            });
            *
            If there groups of checkbox fields with the same name, pass their values in an array. For example:
            *
            myForm.setValues({
            name: 'Jacky',
            crazy: false,
            hobbies: [
            'reading',
            'cooking',
            'gaming'
            ]
            });
            *
            @param {Object} values field name => value mapping object
            @return {Ext.form.Panel} This form
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.baseParams">
            <summary>
            Optional hash of params to be sent (when standardSubmit configuration is false) on every submit.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.maskTarget">
            <summary>
            The target where the form mask will be shown.
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.record">
            <summary>
            The model instance of this form. Can by dynamically set at any time
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.standardSubmit">
            <summary>
            Wether or not we want to perform a standard form submit.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.submitOnAction">
            <summary>
            When this is set to true, the form will automatically submit itself whenever the 'action'
            event fires on a field in this form. The action event usually fires whenever you press
            go or enter inside a textfield.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.url">
            <summary>
            The default Url for submit actions
            @accessor
            </summary>
        </member>
        <member name="P:Ext.form.PanelConfig.waitTpl">
            <summary>
            The defined waitMsg template.  Used for precise control over the masking agent used
            to mask the FormPanel (or other Element) during form Ajax/submission actions. For more options, see
            {@link #showMask} method.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Cube.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.CubeConfig.direction">
            <summary>
            The direction of which the slide animates
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Fade.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.FadeConfig.out">
            <summary>
            True if you want to make this animation fade out, instead of fade in.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.FadeOut.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Flip.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.FlipConfig.direction">
            <summary>
            The direction of which the slide animates
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Pop.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.PopConfig.out">
            <summary>
            True if you want to make this animation pop out, instead of pop in.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.PopOut.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Slide.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.SlideConfig.direction">
            <summary>
            The direction of which the slide animates
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.SlideConfig.offset">
            <summary>
            The offset that the animation should go offscreen before entering (or when exiting)
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.SlideConfig.out">
            <summary>
            True if you want to make this animation slide out, instead of slide in.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.SlideOut.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Wipe.alternateClassName">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.Wipe.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.animation.WipeConfig.direction">
            <summary>
            The direction of which the slide animates
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.WipeConfig.out">
            <summary>
            True if you want to make this animation wipe out, instead of slide in.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.fx.animation.WipeOut.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Cube.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Fade.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Flip.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Pop.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Scroll.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Slide.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.layout.card.Style.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.fx.runner.Css.extend">
            <summary>
            @private
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.fx.runner.CssAnimation.extend" -->
        <!-- Badly formed XML comment ignored for member "P:Ext.fx.runner.CssTransition.extend" -->
        <member name="M:Ext.layout.AbstractBox.doItemAdd(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.AbstractBox.doItemCenteredChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.AbstractBox.doItemDockedChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.AbstractBox.doItemFloatingChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.AbstractBox.doItemRemove(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.layout.AbstractBox.extend">
            <summary>
            AbstractBox is a superclass for the two box layouts:
            * {@link Ext.layout.HBox hbox}
            * {@link Ext.layout.VBox vbox}
            AbstractBox itself is never used directly, but its subclasses provide flexible arrangement of child components
            inside a {@link Ext.Container Container}. For a full overview of layouts check out the
            [Layout Guide](#!/guide/layouts).
            ## Horizontal Box
            HBox allows you to easily lay out child components horizontally. It can size items based on a fixed width or a
            fraction of the total width available, enabling you to achieve flexible layouts that expand or contract to fill the
            space available.
            {@img ../guides/layouts/hbox.jpg}
            See the {@link Ext.layout.HBox HBox layout docs} for more information on using hboxes.
            ## Vertical Box
            VBox allows you to easily lay out child components verticaly. It can size items based on a fixed height or a
            fraction of the total height available, enabling you to achieve flexible layouts that expand or contract to fill the
            space available.
            {@img ../guides/layouts/vbox.jpg}
            See the {@link Ext.layout.VBox VBox layout docs} for more information on using vboxes.
            </summary>
        </member>
        <member name="P:Ext.layout.AbstractBoxConfig.align">
            <summary>
            Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
            *
            - **top** : **Default** child items are aligned vertically at the **top** of the container
            - **middle** : child items are aligned vertically in the **middle** of the container
            - **stretch** : child items are stretched vertically to fill the height of the container
            - **stretchmax** : child items are stretched vertically to the height of the largest item.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.layout.AbstractBoxConfig.pack">
            <summary>
            Controls how the child items of the container are packed together. Acceptable configuration values
            for this property are:
            *
            - ** start ** : child items are packed together at left side of container
            - ** center ** : child items are packed together at mid-width of container
            - ** end ** : child items are packed together at right side of container
            @accessor
            </summary>
        </member>
        <member name="M:Ext.layout.Card.applyAnimation(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Card.doActiveItemChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Card.doItemAdd(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Card.doItemRemove(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Card.onActiveItemChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Card.updateAnimation(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.layout.Card.alternateClassName">
            <summary>
            *
            Sometimes you want to show several screens worth of information but you've only got a small screen to work with.
            TabPanels and Carousels both enable you to see one screen of many at a time, and underneath they both use a Card
            Layout.
            *
            Card Layout takes the size of the Container it is applied to and sizes the currently active item to fill the
            Container completely. It then hides the rest of the items, allowing you to change which one is currently visible but
            only showing one at once:
            *
            {@img ../guides/layouts/card.jpg}
            *
            *
            Here the gray box is our Container, and the blue box inside it is the currently active card. The three other cards
            are hidden from view, but can be swapped in later. While it's not too common to create Card layouts directly, you
            can do so like this:
            *
            var panel = Ext.create('Ext.Panel', {
            layout: 'card',
            items: [
            {
            html: "First Item"
            },
            {
            html: "Second Item"
            },
            {
            html: "Third Item"
            },
            {
            html: "Fourth Item"
            }
            ]
            });
            *
            panel.getLayout().{@link Ext.Container#setActiveItem setActiveItem}(1);
            *
            Here we create a Panel with a Card Layout and later set the second item active (the active item index is zero-based,
            so 1 corresponds to the second item). Normally you're better off using a {@link Ext.tab.Panel tab panel} or a
            {@link Ext.carousel.Carousel carousel}.
            *
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.Card.extend">
            <summary>
            *
            Sometimes you want to show several screens worth of information but you've only got a small screen to work with.
            TabPanels and Carousels both enable you to see one screen of many at a time, and underneath they both use a Card
            Layout.
            *
            Card Layout takes the size of the Container it is applied to and sizes the currently active item to fill the
            Container completely. It then hides the rest of the items, allowing you to change which one is currently visible but
            only showing one at once:
            *
            {@img ../guides/layouts/card.jpg}
            *
            *
            Here the gray box is our Container, and the blue box inside it is the currently active card. The three other cards
            are hidden from view, but can be swapped in later. While it's not too common to create Card layouts directly, you
            can do so like this:
            *
            var panel = Ext.create('Ext.Panel', {
            layout: 'card',
            items: [
            {
            html: "First Item"
            },
            {
            html: "Second Item"
            },
            {
            html: "Third Item"
            },
            {
            html: "Fourth Item"
            }
            ]
            });
            *
            panel.getLayout().{@link Ext.Container#setActiveItem setActiveItem}(1);
            *
            Here we create a Panel with a Card Layout and later set the second item active (the active item index is zero-based,
            so 1 corresponds to the second item). Normally you're better off using a {@link Ext.tab.Panel tab panel} or a
            {@link Ext.carousel.Carousel carousel}.
            *
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.CardConfig.animation">
            <summary>
            Card animation configuration
            Controls how card transitions are animated
            @accessor
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemAdd(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemCenteredChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemDockedChange(System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemFloatingChange(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemMove(System.Object,System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.layout.Default.doItemRemove(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.layout.Default.extend">
            <summary>
            The Default Layout is the layout that all other layouts inherit from. The main capability it provides is docking,
            which means that every other layout can also provide docking support. It's unusual to use Default layout directly,
            instead it's much more common to use one of the sub classes:
            * {@link Ext.layout.HBox hbox layout}
            * {@link Ext.layout.VBox vbox layout}
            * {@link Ext.layout.Card card layout}
            * {@link Ext.layout.Fit fit layout}
            For a full overview of layouts check out the [Layout Guide](#!/guide/layouts).
            ## Docking
            Docking enables you to place additional Components at the top, right, bottom or left edges of the parent Container,
            resizing the other items as necessary. For example, let's say we're using an {@link Ext.layout.HBox hbox layout}
            with a couple of items and we want to add a banner to the top so that we end up with something like this:
            {@img ../guides/layouts/docktop.jpg}
            This is simple to achieve with the *dock: 'top'* configuration below. We can dock as many of the items as we like,
            to either the top, right, bottom or left edges of the Container:
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'hbox',
            items: [
            {
            dock: 'top',
            height: 20,
            html: 'This is docked to the top'
            },
            {
            html: 'message list',
            flex: 1
            },
            {
            html: 'message preview',
            flex: 2
            }
            ]
            });
            Similarly, to dock something to the left of a layout (a {@link Ext.layout.VBox vbox} in this case), such as the
            following:
            {@img ../guides/layouts/dockleft.jpg}
            We can simply dock to the left:
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'vbox',
            items: [
            {
            dock: 'left',
            width: 100,
            html: 'This is docked to the left'
            },
            {
            html: 'message list',
            flex: 1
            },
            {
            html: 'message preview',
            flex: 2
            }
            ]
            });
            We can also dock to the bottom and right and use other layouts than hbox and vbox ({@link Ext.layout.Card card} and
            {@link Ext.layout.Fit fit} layouts both accept docking too).
            </summary>
        </member>
        <member name="P:Ext.layout.Fit.alternateClassName">
            <summary>
            Fit Layout is probably the simplest layout available. All it does is make a child component fit to the full size of
            its parent Container.
            {@img ../guides/layouts/fit.jpg}
            For example, if you have a parent Container that is 200px by 200px and give it a single child component and a 'fit'
            layout, the child component will also be 200px by 200px:
            var panel = Ext.create('Ext.Panel', {
            width: 200,
            height: 200,
            layout: 'fit',
            items: {
            xtype: 'panel',
            html: 'Also 200px by 200px'
            }
            });
            Ext.Viewport.add(panel);
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.Fit.extend">
            <summary>
            Fit Layout is probably the simplest layout available. All it does is make a child component fit to the full size of
            its parent Container.
            {@img ../guides/layouts/fit.jpg}
            For example, if you have a parent Container that is 200px by 200px and give it a single child component and a 'fit'
            layout, the child component will also be 200px by 200px:
            var panel = Ext.create('Ext.Panel', {
            width: 200,
            height: 200,
            layout: 'fit',
            items: {
            xtype: 'panel',
            html: 'Also 200px by 200px'
            }
            });
            Ext.Viewport.add(panel);
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.HBox.alternateClassName">
            <summary>
            The HBox (short for horizontal box) layout makes it easy to position items horizontally in a
            {@link Ext.Container Container}. It can size items based on a fixed width or a fraction of the total width
            available.
            For example, an email client might have a list of messages pinned to the left, taking say one third of the available
            width, and a message viewing panel in the rest of the screen. We can achieve this with hbox layout's *flex* config:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'hbox',
            items: [
            {
            html: 'message list',
            style: 'background-color: #5E99CC;',
            flex: 1
            },
            {
            html: 'message preview',
            style: 'background-color: #759E60;',
            flex: 2
            }
            ]
            });
            This will give us two boxes - one that's one third of the available width, the other being two thirds of the
            available width:
            {@img ../guides/layouts/hbox.jpg}
            We can also specify fixed widths for child items, or mix fixed widths and flexes. For example, here we have 3 items
            - one on each side with flex: 1, and one in the center with a fixed width of 100px:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'hbox',
            items: [
            {
            html: 'Left item',
            style: 'background-color: #759E60;',
            flex: 1
            },
            {
            html: 'Center item',
            width: 100
            },
            {
            html: 'Right item',
            style: 'background-color: #5E99CC;',
            flex: 1
            }
            ]
            });
            Which gives us an effect like this:
            {@img ../guides/layouts/hboxfixed.jpg}
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.HBox.extend">
            <summary>
            The HBox (short for horizontal box) layout makes it easy to position items horizontally in a
            {@link Ext.Container Container}. It can size items based on a fixed width or a fraction of the total width
            available.
            For example, an email client might have a list of messages pinned to the left, taking say one third of the available
            width, and a message viewing panel in the rest of the screen. We can achieve this with hbox layout's *flex* config:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'hbox',
            items: [
            {
            html: 'message list',
            style: 'background-color: #5E99CC;',
            flex: 1
            },
            {
            html: 'message preview',
            style: 'background-color: #759E60;',
            flex: 2
            }
            ]
            });
            This will give us two boxes - one that's one third of the available width, the other being two thirds of the
            available width:
            {@img ../guides/layouts/hbox.jpg}
            We can also specify fixed widths for child items, or mix fixed widths and flexes. For example, here we have 3 items
            - one on each side with flex: 1, and one in the center with a fixed width of 100px:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'hbox',
            items: [
            {
            html: 'Left item',
            style: 'background-color: #759E60;',
            flex: 1
            },
            {
            html: 'Center item',
            width: 100
            },
            {
            html: 'Right item',
            style: 'background-color: #5E99CC;',
            flex: 1
            }
            ]
            });
            Which gives us an effect like this:
            {@img ../guides/layouts/hboxfixed.jpg}
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="M:Ext.layout.Layout.#ctor(Ext.Container,System.Object)">
            <summary>
            Creates a new Layout for the specified container using the config object's layout to determine
            layout to instantiate.
            @param {Ext.Container} container A configuration object for the Component you wish to create.
            @param {Object} [config] The alias to provide the Layout type; if none is
            specified, Ext.layout.Default will be used.
            @return {Ext.layout.Default} The newly instantiated Layout.
            </summary>
        </member>
        <member name="P:Ext.layout.Navigation.extend">
            <summary>
            Navigation Layout...
            </summary>
        </member>
        <member name="P:Ext.layout.VBox.alternateClassName">
            <summary>
            The VBox (short for vertical box) layout makes it easy to position items horizontally in a
            {@link Ext.Container Container}. It can size items based on a fixed height or a fraction of the total height
            available.
            For example, let's say we want a banner to take one third of the available height, and an information panel in the
            rest of the screen. We can achieve this with vbox layout's *flex* config:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'vbox',
            items: [
            {
            html: 'Awesome banner',
            style: 'background-color: #759E60;',
            flex: 1
            },
            {
            html: 'Some wonderful information',
            style: 'background-color: #5E99CC;',
            flex: 2
            }
            ]
            });
            This will give us two boxes - one that's one third of the available height, the other being two thirds of the
            available height:
            {@img ../guides/layouts/vbox.jpg}
            We can also specify fixed heights for child items, or mix fixed heights and flexes. For example, here we have 3
            items - one at the top and bottom with flex: 1, and one in the center with a fixed width of 100px:
            @example preview portrait
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'vbox',
            items: [
            {
            html: 'Top item',
            style: 'background-color: #5E99CC;',
            flex: 1
            },
            {
            html: 'Center item',
            height: 100
            },
            {
            html: 'Bottom item',
            style: 'background-color: #759E60;',
            flex: 1
            }
            ]
            });
            Which gives us an effect like this:
            {@img ../guides/layouts/vboxfixed.jpg}
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="P:Ext.layout.VBox.extend">
            <summary>
            The VBox (short for vertical box) layout makes it easy to position items horizontally in a
            {@link Ext.Container Container}. It can size items based on a fixed height or a fraction of the total height
            available.
            For example, let's say we want a banner to take one third of the available height, and an information panel in the
            rest of the screen. We can achieve this with vbox layout's *flex* config:
            @example
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'vbox',
            items: [
            {
            html: 'Awesome banner',
            style: 'background-color: #759E60;',
            flex: 1
            },
            {
            html: 'Some wonderful information',
            style: 'background-color: #5E99CC;',
            flex: 2
            }
            ]
            });
            This will give us two boxes - one that's one third of the available height, the other being two thirds of the
            available height:
            {@img ../guides/layouts/vbox.jpg}
            We can also specify fixed heights for child items, or mix fixed heights and flexes. For example, here we have 3
            items - one at the top and bottom with flex: 1, and one in the center with a fixed width of 100px:
            @example preview portrait
            Ext.create('Ext.Container', {
            fullscreen: true,
            layout: 'vbox',
            items: [
            {
            html: 'Top item',
            style: 'background-color: #5E99CC;',
            flex: 1
            },
            {
            html: 'Center item',
            height: 100
            },
            {
            html: 'Bottom item',
            style: 'background-color: #759E60;',
            flex: 1
            }
            ]
            });
            Which gives us an effect like this:
            {@img ../guides/layouts/vboxfixed.jpg}
            For a more detailed overview of what layouts are and the types of layouts shipped with Sencha Touch 2, check out the
            [Layout Guide](#!/guide/layouts).
            </summary>
        </member>
        <member name="M:Ext.mixin.Identifiable.getId">
            <summary>
            Retrieves the id of this component. Will autogenerate an id if one has not already been set.
            @return {String} id
            </summary>
        </member>
        <member name="P:Ext.mixin.Identifiable.Id">
            <summary>
            Retrieves the id of this component. Will autogenerate an id if one has not already been set.
            @return {String} id
            </summary>
        </member>
        <member name="M:Ext.mixin.Mixin.onClassExtended(System.Object,System.Object)">
            <summary>
            Base class for all mixins.
            @private
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.deselect(System.Object,System.Boolean)">
            <summary>
            Deselects the given record(s). If many records are currently selected, it will only deselect those you pass in.
            @param {Number/Array/Ext.data.Model} records The record(s) to deselect. Can also be a number to reference by index
            @param {Boolean} suppressEvent If true the deselect event will not be fired
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.getSelection">
            <summary>
            Returns an array of the currently selected records.
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.hasSelection">
            <summary>
            Returns true if there is a selected record.
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.isSelected(System.Object)">
            <summary>
            Returns <tt>true</tt> if the specified row is selected.
            @param {Ext.data.Model/Number} record The record or index of the record to check
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.select(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Adds the given records to the currently selected set
            @param {Ext.data.Model/Array/Number} records The records to select
            @param {Boolean} keepExisting If true, the existing selection will be added to (if not, the old selection is replaced)
            @param {Boolean} suppressEvent If true, the 'select' event will not be fired
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.selectRange(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,System.Boolean,System.Object)">
            <summary>
            Selects a range of rows if the selection model {@link Ext.mixin.Selectable#getLocked is not locked}.
            All rows in between startRow and endRow are also selected.
            @param {Number} startRow The index of the first row in the range
            @param {Number} endRow The index of the last row in the range
            @param {Boolean} keepExisting (optional) True to retain existing selections
            </summary>
        </member>
        <member name="M:Ext.mixin.Selectable.updateLastFocused(System.Object,System.Object)">
            <summary>
            @param {Ext.data.Record} record
            Set a record as the last focused record. This does NOT mean
            that the record has been selected.
            </summary>
        </member>
        <member name="P:Ext.mixin.Selectable.alternateClassName">
            <summary>
            Tracks what records are currently selected in a databound widget. This class is mixed in to
            @private
            </summary>
        </member>
        <member name="P:Ext.mixin.SelectableConfig.allowDeselect">
            <summary>
            Allow users to deselect a record in a DataView, List or Grid. Only applicable when the Selectable's mode is
            'SINGLE'. Defaults to false.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.mixin.SelectableConfig.deselectOnContainerClick">
            <summary>
            True to deselect current selection when the container body is
            clicked. Defaults to true
            @accessor
            </summary>
        </member>
        <member name="P:Ext.mixin.SelectableConfig.locked">
            <summary>
            When true, locks the current selection so that the user cannot change what is selected. Defaults to false,
            see {@link #setLocked} to dynamically change locking at run time
            @accessor
            </summary>
        </member>
        <member name="P:Ext.mixin.SelectableConfig.mode">
            <summary>
            Modes of selection.
            Valid values are SINGLE, SIMPLE, and MULTI. Defaults to 'SINGLE'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.mixin.SelectableConfig.selected">
            <summary>
            The {@link Ext.util.MixedCollection MixedCollection} that maintains the set of currently selected items
            @accessor
            </summary>
        </member>
        <member name="P:Ext.mixin.Traversable.extend">
            <summary>
            A Traversable mixin.
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Date.createSlot(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns a slot config for a specified date.
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Date.createSlots">
            <summary>
            Generates all slots for all years specified by this component, and then sets them on the component
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Date.setValue(System.Object,System.Object)">
            <summary>
            @cfg {Array} slots
            @hide
            @accessor
            </summary>
        </member>
        <member name="M:Ext.picker.Date.updateDayText(System.Object,System.Object)">
            <summary>
            Updates the dayText configuraton
            </summary>
        </member>
        <member name="M:Ext.picker.Date.updateMonthText(System.Object,System.Object)">
            <summary>
            Updates the monthText configuration
            </summary>
        </member>
        <member name="M:Ext.picker.Date.updateYearFrom">
            <summary>
            Updates the yearFrom configuration
            </summary>
        </member>
        <member name="M:Ext.picker.Date.updateYearText(System.Object)">
            <summary>
            Updates the yearText configuration
            </summary>
        </member>
        <member name="M:Ext.picker.Date.updateYearTo">
            <summary>
            Updates the yearTo configuration
            </summary>
        </member>
        <member name="P:Ext.picker.Date.extend">
            <summary>
            A date picker component which shows a Date Picker on the screen. This class extends from {@link Ext.picker.Picker}
            and {@link Ext.Sheet} so it is a popup.
            This component has no required configurations.
            ## Examples
            @example preview
            var datePicker = Ext.create('Ext.picker.Date');
            datePicker.show();
            You may want to adjust the {@link #yearFrom} and {@link #yearTo} properties:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            yearFrom: 2000,
            yearTo  : 2015
            });
            datePicker.show();
            You can set the value of the {@link Ext.picker.Date} to the current date using `new Date()`:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            value: new Date()
            });
            datePicker.show();
            And you can hide the titles from each of the slots by using the {@link #useTitles} configuration:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            useTitles: false
            });
            datePicker.show();
            </summary>
        </member>
        <member name="P:Ext.picker.Date.xtype">
            <summary>
            A date picker component which shows a Date Picker on the screen. This class extends from {@link Ext.picker.Picker}
            and {@link Ext.Sheet} so it is a popup.
            This component has no required configurations.
            ## Examples
            @example preview
            var datePicker = Ext.create('Ext.picker.Date');
            datePicker.show();
            You may want to adjust the {@link #yearFrom} and {@link #yearTo} properties:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            yearFrom: 2000,
            yearTo  : 2015
            });
            datePicker.show();
            You can set the value of the {@link Ext.picker.Date} to the current date using `new Date()`:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            value: new Date()
            });
            datePicker.show();
            And you can hide the titles from each of the slots by using the {@link #useTitles} configuration:
            @example preview
            var datePicker = Ext.create('Ext.picker.Date', {
            useTitles: false
            });
            datePicker.show();
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.dayText">
            <summary>
            The label to show for the day column.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.monthText">
            <summary>
            The label to show for the month column.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.slotOrder">
            <summary>
            An array of strings that specifies the order of the slots.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.useTitles">
            <summary>
            Generate a title header for each individual slot and use
            the title configuration of the slot.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.value">
            <summary>
            Default value for the field and the internal {@link Ext.picker.Date} component. Accepts an object of 'year',
            'month' and 'day' values, all of which should be numbers, or a {@link Date}.
            *
            Examples:
            {year: 1989, day: 1, month: 5} = 1st May 1989.
            new Date() = current date
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.yearFrom">
            <summary>
            The start year for the date picker.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.yearText">
            <summary>
            The label to show for the year column.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.DateConfig.yearTo">
            <summary>
            The last year for the date picker.
            @default the current year (new Date().getFullYear())
            @accessor
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.applyCancelButton(System.Object)">
            <summary>
            Updates the {@link #cancelButton} configuration. Will change it into a button when appropriate, or just update the text if needed.
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.applyDoneButton(System.Object)">
            <summary>
            Updates the {@link #doneButton} configuration. Will change it into a button when appropriate, or just update the text if needed.
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.applyToolbar(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.getValue">
            <summary>
            Returns the values of each of the pickers slots
            @return {Object} The values of the pickers slots
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.getValues">
            <summary>
            Returns the values of eaach of the pickers slots
            @return {Object} The values of the pickers slots
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.onCancelButtonTap">
            <summary>
            @private
            Called when the cancel button has been tapped.
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.onDoneButtonTap">
            <summary>
            @private
            Called when the done button has been tapped.
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.onSlotPick(System.Object,System.Object,System.Object)">
            <summary>
            @private
            Called when a slot has been picked.
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.setValue(System.Object,System.Boolean)">
            <summary>
            Sets the values of the pickers slots
            @param {Object} values The values in a {name:'value'} format
            @param {Boolean} animated True to animate setting the values
            @return {Ext.Picker} this This picker
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.updateSlots(System.Object,System.Object)">
            <summary>
            Adds any new {@link #slots} to this picker, and removes existing {@link #slots}
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.updateToolbar(System.Object,System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Picker.updateUseTitles(System.Object)">
            <summary>
            *
            </summary>
        </member>
        <member name="P:Ext.picker.Picker.alias">
            <summary>
            A general picker class. {@link Ext.picker.Slot}s are used to organize multiple scrollable slots into a single picker. {@link #slots} is
            the only necessary configuration.
            The {@link #slots} configuration with a few key values:
            - **name:** The name of the slot (will be the key when using {@link #getValues} in this {@link Ext.picker.Picker})
            - **title:** The title of this slot (if {@link #useTitles} is set to true)
            - **data/store:** The data or store to use for this slot.
            Remember, {@link Ext.picker.Slot} class extends from {@link Ext.dataview.DataView}.
            ## Examples
            @example preview
            var picker = Ext.create('Ext.Picker', {
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            You can also customize the top toolbar on the {@link Ext.picker.Picker} by changing the {@link #doneButton} and {@link #cancelButton} configurations:
            @example preview
            var picker = Ext.create('Ext.Picker', {
            doneButton: 'I\'m done!',
            cancelButton: false,
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            Or by passing a custom {@link #toolbar} configuration:
            @example preview
            var picker = Ext.create('Ext.Picker', {
            doneButton: false,
            cancelButton: false,
            toolbar: {
            ui: 'light',
            title: 'My Picker!'
            },
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            </summary>
        </member>
        <member name="P:Ext.picker.Picker.extend">
            <summary>
            A general picker class. {@link Ext.picker.Slot}s are used to organize multiple scrollable slots into a single picker. {@link #slots} is
            the only necessary configuration.
            The {@link #slots} configuration with a few key values:
            - **name:** The name of the slot (will be the key when using {@link #getValues} in this {@link Ext.picker.Picker})
            - **title:** The title of this slot (if {@link #useTitles} is set to true)
            - **data/store:** The data or store to use for this slot.
            Remember, {@link Ext.picker.Slot} class extends from {@link Ext.dataview.DataView}.
            ## Examples
            @example preview
            var picker = Ext.create('Ext.Picker', {
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            You can also customize the top toolbar on the {@link Ext.picker.Picker} by changing the {@link #doneButton} and {@link #cancelButton} configurations:
            @example preview
            var picker = Ext.create('Ext.Picker', {
            doneButton: 'I\'m done!',
            cancelButton: false,
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            Or by passing a custom {@link #toolbar} configuration:
            @example preview
            var picker = Ext.create('Ext.Picker', {
            doneButton: false,
            cancelButton: false,
            toolbar: {
            ui: 'light',
            title: 'My Picker!'
            },
            slots: [
            {
            name : 'limit_speed',
            title: 'Speed',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            ]
            });
            picker.show();
            </summary>
        </member>
        <member name="P:Ext.picker.Picker.Value">
            <summary>
            Returns the values of each of the pickers slots
            @return {Object} The values of the pickers slots
            </summary>
        </member>
        <member name="P:Ext.picker.Picker.Values">
            <summary>
            Returns the values of eaach of the pickers slots
            @return {Object} The values of the pickers slots
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.cancelButton">
            <summary>
            Can be either:<ul>
            <li>A {String} text to be used on the Cancel button</li>
            <li>An {Object} as config for {@link Ext.Button}</li>
            <li>false or null to hide it</li></ul>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.doneButton">
            <summary>
            Can be either:<ul>
            <li>A {String} text to be used on the Done button</li>
            <li>An {Object} as config for {@link Ext.Button}</li>
            <li>false or null to hide it</li></ul>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.height">
            <summary>
            The height of the picker.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.slots">
            <summary>
            An array of slot configurations.
            <ul>
            <li>name - {String} - Name of the slot</li>
            <li>data - {Array} - An array of text/value pairs in the format {text: 'myKey', value: 'myValue'}</li>
            <li>title - {String} - Title of the slot. This is used in conjunction with useTitles: true.</li>
            </ul>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.toolbar">
            <summary>
            The toolbar which contains the {@link #doneButton} and {@link #cancelButton} buttons.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.useTitles">
            <summary>
            Generate a title header for each individual slot and use
            the title configuration of the slot.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.PickerConfig.value">
            <summary>
            The value to initialize the picker with
            @accessor
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.applyData(System.Object)">
            <summary>
            Looks at the {@link #data} configuration and turns it into {@link #store}
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.applyTitle(System.Object)">
            <summary>
            Sets the title for this dataview by creating element
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.getValue">
            <summary>
            Returns the vlaue of this slot
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.setValue(System.Object)">
            <summary>
            Sets the value of this slot
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.setValueAnimated(System.Object)">
            <summary>
            Sets the value of this slot
            @private
            </summary>
        </member>
        <member name="M:Ext.picker.Slot.updateAlign(System.Object,System.Object)">
            <summary>
            Updates the {@link #align} configuration
            </summary>
        </member>
        <member name="P:Ext.picker.Slot.extend">
            <summary>
            @private
            *
            A general {@link Ext.picker.Picker} slot class.  Slots are used to organize multiple scrollable slots into
            a single {@link Ext.picker.Picker}.
            *
            {
            name : 'limit_speed',
            title: 'Speed Limit',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            *
            See the {@link Ext.picker.Picker} documentation on how to use slots.
            </summary>
        </member>
        <member name="P:Ext.picker.Slot.selectedIndex">
            <summary>
            @private
            The current selectedIndex of the picker slot
            </summary>
        </member>
        <member name="P:Ext.picker.Slot.Value">
            <summary>
            Sets the value of this slot
            @private
            </summary>
        </member>
        <member name="P:Ext.picker.Slot.ValueAnimated">
            <summary>
            Sets the value of this slot
            @private
            </summary>
        </member>
        <member name="P:Ext.picker.Slot.xtype">
            <summary>
            @private
            *
            A general {@link Ext.picker.Picker} slot class.  Slots are used to organize multiple scrollable slots into
            a single {@link Ext.picker.Picker}.
            *
            {
            name : 'limit_speed',
            title: 'Speed Limit',
            data : [
            {text: '50 KB/s', value: 50},
            {text: '100 KB/s', value: 100},
            {text: '200 KB/s', value: 200},
            {text: '300 KB/s', value: 300}
            ]
            }
            *
            See the {@link Ext.picker.Picker} documentation on how to use slots.
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.align">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.cls">
            <summary>
            The main component class
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.displayField">
            <summary>
            The display field in the store.
            Defaults to 'text'.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.flex">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.itemSelector">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.name">
            <summary>
            The name of this slot. This config option is required.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.scrollable">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.showTitle">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.title">
            <summary>
            The title to use for this slot. Null for no title
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.value">
            <summary>
            The value of this slot
            @accessor
            </summary>
        </member>
        <member name="P:Ext.picker.SlotConfig.valueField">
            <summary>
            The value field in the store.
            Defaults to 'value'.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.scroll.Scroller.#ctor(System.Object)">
            <summary>
            @cfg {Number} friction The friction of the scroller. By raising this value the length that momentum scrolls
            becomes shorter. This value is best kept between 0 and 1. The default value is 0.5. Deprecated, please use
            momentumEasing.momentum.friction instead
            @deprecated 2.0.0
            </summary>
        </member>
        <member name="P:Ext.scroll.Scroller.alternateClassName">
            <summary>
            The scroller factory
            </summary>
        </member>
        <member name="P:Ext.scroll.ScrollerConfig.acceleration">
            <summary>
            A higher acceleration gives the scroller more initial velocity. Defaults to 30
            Deprecated, please use momentumEasing.momentum.acceleration instead
            @deprecated 2.0.0
            </summary>
        </member>
        <member name="P:Ext.scroll.View.extend">
            <summary>
            *
            </summary>
        </member>
        <member name="P:Ext.scroll.easing.Bounce.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.easing.BoundMomentum.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.easing.EaseOut.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.easing.Linear.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.easing.Momentum.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.indicator.Abstract.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.indicator.AbstractConfig.axis">
            <summary>
            The current indicator axis
            @accessor
            </summary>
        </member>
        <member name="P:Ext.scroll.indicator.CssTransform.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.indicator.ScrollPosition.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.scroller.AbstractConfig.direction">
            <summary>
            Possible values: 'auto', 'vertical', 'horizontal', or 'both'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.scroll.scroller.CssPosition.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.scroller.CssTransform.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.scroller.Infinite.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.scroll.scroller.ScrollPosition.extend">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.applyActiveTab(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.#ctor">
            <summary>
            @event change
            @param {Ext.tab.Bar} this
            @param {Ext.tab.Tab} tab The Tab button
            @param {Ext.Component} card The component that has been activated
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.doActiveTabChange(System.Object,System.Object,System.Object)">
            <summary>
            @private
            Sets the active tab
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.doSetDocked(System.Object)">
            <summary>
            @private
            When docked to the top, pack left, when on the bottom pack center
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.parseActiveTab(System.Object)">
            <summary>
            @private
            Parses the active tab, which can be a number or string
            </summary>
        </member>
        <member name="M:Ext.tab.Bar.updateActiveTab(System.Object,System.Object)">
            <summary>
            @private
            Fires off the tabchange action
            </summary>
        </member>
        <member name="P:Ext.tab.Bar.alternateClassName">
            <summary>
            Ext.tab.Bar is used internally by {@link Ext.tab.Panel} to create the bar of tabs that appears at the top of the tab
            panel. It's unusual to use it directly, instead see the {@link Ext.tab.Panel tab panel docs} for usage instructions.
            Used in the {@link Ext.tab.Panel} component to display {@link Ext.tab.Tab} components.
            @private
            </summary>
        </member>
        <member name="P:Ext.tab.Bar.extend">
            <summary>
            Ext.tab.Bar is used internally by {@link Ext.tab.Panel} to create the bar of tabs that appears at the top of the tab
            panel. It's unusual to use it directly, instead see the {@link Ext.tab.Panel tab panel docs} for usage instructions.
            Used in the {@link Ext.tab.Panel} component to display {@link Ext.tab.Tab} components.
            @private
            </summary>
        </member>
        <member name="P:Ext.tab.BarConfig.activeTab">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.applyTabBar(System.Object)">
            <summary>
            Creates a new {@link Ext.tab.Bar} instance using {@link Ext.Factory}.
            @private
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.doActiveItemChange(System.Object)">
            <summary>
            Updates the {@link #tabBar} instance with the new {@link Ext.tab.Bar#activeTab}.
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.doTabChange(System.Object,System.Object,System.Object)">
            <summary>
            Updates this container with the new active item.
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.updateTabBar(System.Object)">
            <summary>
            Adds the new {@link Ext.tab.Bar} instance into this container.
            @private
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.updateTabBarPosition(System.Object)">
            <summary>
            Updates the docked position of the {@link #tabBar}.
            @private
            </summary>
        </member>
        <member name="M:Ext.tab.Panel.updateUi(System.Object,System.Object)">
            <summary>
            Updates the Ui for this component and the {@link #tabBar}.
            </summary>
        </member>
        <member name="P:Ext.tab.Panel.extend">
            <summary>
            Tab Panels are a great way to allow the user to switch between several pages that are all full screen. Each
            Component in the Tab Panel gets its own Tab, which shows the Component when tapped on. Tabs can be positioned at
            the top or the bottom of the Tab Panel, and can optionally accept title and icon configurations.
            Here's how we can set up a simple Tab Panel with tabs at the bottom. Use the controls at the top left of the example
            to toggle between code mode and live preview mode (you can also edit the code and see your changes in the live
            preview):
            @example preview
            Ext.create('Ext.TabPanel', {
            fullscreen: true,
            tabBarPosition: 'bottom',
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            title: 'Home',
            iconCls: 'home',
            html: 'Home Screen'
            },
            {
            title: 'Contact',
            iconCls: 'user',
            html: 'Contact Screen'
            }
            ]
            });
            One tab was created for each of the {@link Ext.Panel panels} defined in the items array. Each tab automatically uses
            the title and icon defined on the item configuration, and switches to that item when tapped on. We can also position
            the tab bar at the top, which makes our Tab Panel look like this:
            @example preview
            Ext.create('Ext.TabPanel', {
            fullscreen: true,
            defaults: {
            styleHtmlContent: true
            },
            items: [
            {
            title: 'Home',
            html: 'Home Screen'
            },
            {
            title: 'Contact',
            html: 'Contact Screen'
            }
            ]
            });
            </summary>
        </member>
        <member name="P:Ext.tab.PanelConfig.layout">
            <summary>
            @hide
            </summary>
        </member>
        <member name="P:Ext.tab.PanelConfig.tabBar">
            <summary>
            An Ext.tab.Bar configuration.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.tab.PanelConfig.tabBarPosition">
            <summary>
            The docked position for the {@link #tabBar} instance
            @accessor
            </summary>
        </member>
        <member name="P:Ext.tab.PanelConfig.ui">
            <summary>
            @accessor
            </summary>
        </member>
        <member name="M:Ext.tab.Tab.updateTitle(Ext.tab.Tab)">
            <summary>
            @event deactivate
            @param {Ext.tab.Tab} this
            </summary>
        </member>
        <member name="P:Ext.tab.Tab.extend">
            <summary>
            Used in the {@link Ext.tab.Bar} component. This shouldn't be used directly, instead use
            {@link Ext.tab.Bar} or {@link Ext.tab.Panel}.
            @private
            </summary>
        </member>
        <member name="P:Ext.tab.Tab.xtype">
            <summary>
            Used in the {@link Ext.tab.Bar} component. This shouldn't be used directly, instead use
            {@link Ext.tab.Bar} or {@link Ext.tab.Panel}.
            @private
            </summary>
        </member>
        <member name="P:Ext.tab.TabConfig.active">
            <summary>
            Set this to true to have the tab be active by default.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.tab.TabConfig.activeCls">
            <summary>
            The CSS class to be applied to a Tab when it is active. Defaults to 'x-tab-active'.
            Providing your own CSS for this class enables you to customize the active state.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.tab.TabConfig.pressedCls">
            <summary>
            The CSS class to be applied to a Tab when it is pressed. Defaults to 'x-tab-pressed'.
            Providing your own CSS for this class enables you to customize the pressed state.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.tab.TabConfig.title">
            <summary>
            The title of the card that this tab is bound to.
            @accessor
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.add(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Adds an item to the collection. Fires the {@link #add} event when complete.
            @param {String} key <p>The key to associate with the item, or the new item.</p>
            <p>If a {@link #getKey} implementation was specified for this MixedCollection,
            or if the key of the stored items is in a property called <tt><b>id</b></tt>,
            the MixedCollection will be able to <i>derive</i> the key for the new item.
            In this case just pass the new item in this parameter.</p>
            @param {Object} o The item to add.
            @return {Object} The item added.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.addAll(System.Object)">
            <summary>
            Adds all elements of an Array or an Object to the collection.
            @param {Object/Array} objs An Object containing properties which will be added
            to the collection, or an Array of values, each of which are added to the collection.
            Functions references will be added to the collection if <code>{@link #allowFunctions}</code>
            has been set to <tt>true</tt>.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.clear">
            <summary>
            Removes all items from the collection.  Fires the {@link #clear} event when complete.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.clone">
            <summary>
            Creates a shallow copy of this collection
            @return {Ext.util.MixedCollection}
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.collect(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,System.Boolean)">
            <summary>
            Collects unique values of a particular property in this MixedCollection
            @param {String} property The property to collect on
            @param {String} root Optional 'root' property to extract the first argument from. This is used mainly when
            summing fields in records, where the fields are all stored inside the 'data' object
            @param {Boolean} allowBlank (optional) Pass true to allow null, undefined or empty string values
            @return {Array} The unique values
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.#ctor(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            @event remove
            Fires when an item is removed from the collection.
            @param {Object} o The item being removed.
            @param {String} key (optional) The key associated with the removed item.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.contains(System.Object)">
            <summary>
            Returns true if the collection contains the passed Object as an item.
            @param {Object} o  The Object to look for in the collection.
            @return {Boolean} True if the collection contains the Object as an item.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.containsKey(SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the collection contains the passed Object as a key.
            @param {String} key The key to look for in the collection.
            @return {Boolean} True if the collection contains the Object as a key.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.createValueMatcher(SharpKit.JavaScript.JsString,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns a regular expression based on the given value and matching options. This is used internally for finding and filtering,
            and by Ext.data.Store#filter
            @private
            @param {String} value The value to create the regex for. This is escaped using Ext.escapeRe
            @param {Boolean} anyMatch True to allow any match - no regex start/end line anchors will be added. Defaults to false
            @param {Boolean} caseSensitive True to make the regex case sensitive (adds 'i' switch to regex). Defaults to false.
            @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. Ignored if anyMatch is true.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.each(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Executes the specified function once for every item in the collection, passing the following arguments:
            <div class="mdetail-params"><ul>
            <li><b>item</b> : Mixed<p class="sub-desc">The collection item</p></li>
            <li><b>index</b> : Number<p class="sub-desc">The item's index</p></li>
            <li><b>length</b> : Number<p class="sub-desc">The total number of items in the collection</p></li>
            </ul></div>
            The function should return a boolean value. Returning false from the function will stop the iteration.
            @param {Function} fn The function to execute for each item.
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to the current item in the iteration.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.eachKey(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Executes the specified function once for every key in the collection, passing each
            key, and its associated item as the first two parameters.
            @param {Function} fn The function to execute for each item.
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to the browser window.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.extractValues(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            @private
            Extracts all of the given property values from the items in the MC. Mainly used as a supporting method for
            functions like sum and collect.
            @param {String} property The property to extract
            @param {String} root Optional 'root' property to extract the first argument from. This is used mainly when
            extracting field data from Model instances, where the fields are stored inside the 'data' object
            @return {Array} The extracted values
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.filter(System.Object,System.Object,System.Boolean,System.Boolean)">
            <summary>
            <p>Filters the objects in this collection by a set of {@link Ext.util.Filter Filter}s, or by a single
            property/value pair with optional parameters for substring matching and case sensitivity. See
            {@link Ext.util.Filter Filter} for an example of using Filter objects (preferred). Alternatively,
            MixedCollection can be easily filtered by property like this:</p>
            <pre><code>
            //create a simple store with a few people defined
            var people = new Ext.util.MixedCollection();
            people.addAll([
            {id: 1, age: 25, name: 'Ed'},
            {id: 2, age: 24, name: 'Tommy'},
            {id: 3, age: 24, name: 'Arne'},
            {id: 4, age: 26, name: 'Aaron'}
            ]);
            //a new MixedCollection containing only the items where age == 24
            var middleAged = people.filter('age', 24);
            </code></pre>
            *
            *
            @param {Ext.util.Filter[]/String} property A property on your objects, or an array of {@link Ext.util.Filter Filter} objects
            @param {String/RegExp} value Either string that the property values
            should start with or a RegExp to test against the property
            @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
            @param {Boolean} caseSensitive (optional) True for case sensitive comparison (defaults to False).
            @return {Ext.util.MixedCollection} The new filtered collection
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.filterBy(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Filter by a function. Returns a <i>new</i> collection that has been filtered.
            The passed function will be called with each object in the collection.
            If the function returns true, the value is included otherwise it is filtered.
            @param {Function} fn The function to be called, it will receive the args o (the object), k (the key)
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to this MixedCollection.
            @return {Ext.util.MixedCollection} The new filtered collection
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.findBy(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Returns the first item in the collection which elicits a true return value from the
            passed selection function.
            @param {Function} fn The selection function to execute for each item.
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to the browser window.
            @return {Object} The first item in the collection which returned true from the selection function.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.findIndex(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsNumber,System.Boolean,System.Boolean)">
            <summary>
            Finds the index of the first matching object in this collection by a specific property/value.
            @param {String} property The name of a property on your objects.
            @param {String/RegExp} value A string that the property values
            should start with or a RegExp to test against the property.
            @param {Number} start (optional) The index to start searching at (defaults to 0).
            @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning.
            @param {Boolean} caseSensitive (optional) True for case sensitive comparison.
            @return {Number} The matched index or -1
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.findIndexBy(SharpKit.JavaScript.JsAction,System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            Find the index of the first matching object in this collection by a function.
            If the function returns <i>true</i> it is considered a match.
            @param {Function} fn The function to be called, it will receive the args o (the object), k (the key).
            @param {Object} scope (optional) The scope (<code>this</code> reference) in which the function is executed. Defaults to this MixedCollection.
            @param {Number} start (optional) The index to start searching at (defaults to 0).
            @return {Number} The matched index or -1
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.first">
            <summary>
            Returns the first item in the collection.
            @return {Object} the first item in the collection..
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.get(System.Object)">
            <summary>
            Returns the item associated with the passed key OR index.
            Key has priority over index.  This is the equivalent
            of calling {@link #getByKey} first, then if nothing matched calling {@link #getAt}.
            @param {String/Number} key The key or index of the item.
            @return {Object} If the item is found, returns the item.  If the item was not found, returns <tt>undefined</tt>.
            If an item was found, but is a Class, returns <tt>null</tt>.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.getAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns the item at the specified index.
            @param {Number} index The index of the item.
            @return {Object} The item at the specified index.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.getByKey(System.Object)">
            <summary>
            Returns the item associated with the passed key.
            @param {String/Number} key The key of the item.
            @return {Object} The item associated with the passed key.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.getCount">
            <summary>
            Returns the number of items in the collection.
            @return {Number} the number of items in the collection.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.getKey(System.Object)">
            <summary>
            MixedCollection has a generic way to fetch keys if you implement getKey.  The default implementation
            simply returns <b><code>item.id</code></b> but you can provide your own implementation
            to return a different value as in the following examples:<pre><code>
            // normal way
            var mc = new Ext.util.MixedCollection();
            mc.add(someEl.dom.id, someEl);
            mc.add(otherEl.dom.id, otherEl);
            //and so on
            // using getKey
            var mc = new Ext.util.MixedCollection();
            mc.getKey = function(el){
            return el.dom.id;
            };
            mc.add(someEl);
            mc.add(otherEl);
            // or via the constructor
            var mc = new Ext.util.MixedCollection(false, function(el){
            return el.dom.id;
            });
            mc.add(someEl);
            mc.add(otherEl);
            </code></pre>
            @param {Object} item The item for which to find the key.
            @return {Object} The key for the passed item.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.getRange(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Returns a range of items in this collection
            @param {Number} startIndex (optional) The starting index. Defaults to 0.
            @param {Number} endIndex (optional) The ending index. Defaults to the last item.
            @return {Array} An array of items
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.indexOf(System.Object)">
            <summary>
            Returns index within the collection of the passed Object.
            @param {Object} o The item to find the index of.
            @return {Number} index of the item. Returns -1 if not found.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.indexOfKey(SharpKit.JavaScript.JsString)">
            <summary>
            Returns index within the collection of the passed key.
            @param {String} key The key to find the index of.
            @return {Number} index of the key.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.insert(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Inserts an item at the specified index in the collection. Fires the {@link #add} event when complete.
            @param {Number} index The index to insert the item at.
            @param {String} key The key to associate with the new item, or the item itself.
            @param {Object} o (optional) If the second parameter was a key, the new item.
            @return {Object} The item inserted.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.last">
            <summary>
            Returns the last item in the collection.
            @return {Object} the last item in the collection..
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.remove(System.Object)">
            <summary>
            Remove an item from the collection.
            @param {Object} o The item to remove.
            @return {Object} The item removed or false if no item was removed.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.removeAll(SharpKit.JavaScript.JsArray)">
            <summary>
            Remove all items in the passed array from the collection.
            @param {Array} items An array of items to be removed.
            @return {Ext.util.MixedCollection} this object
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.removeAt(SharpKit.JavaScript.JsNumber)">
            <summary>
            Remove an item from a specified index in the collection. Fires the {@link #remove} event when complete.
            @param {Number} index The index within the collection of the item to remove.
            @return {Object} The item removed or false if no item was removed.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.removeAtKey(SharpKit.JavaScript.JsString)">
            <summary>
            Removed an item associated with the passed key fom the collection.
            @param {String} key The key of the item to remove.
            @return {Object} The item removed or false if no item was removed.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.replace(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Replaces an item in the collection. Fires the {@link #replace} event when complete.
            @param {String} key <p>The key associated with the item to replace, or the replacement item.</p>
            <p>If you supplied a {@link #getKey} implementation for this MixedCollection, or if the key
            of your stored items is in a property called <tt><b>id</b></tt>, then the MixedCollection
            will be able to <i>derive</i> the key of the replacement item. If you want to replace an item
            with one having the same key value, then just pass the replacement item in this parameter.</p>
            @param o {Object} o (optional) If the first parameter passed was a key, the item to associate
            with that key.
            @return {Object}  The new item.
            </summary>
        </member>
        <member name="M:Ext.util.AbstractMixedCollection.sum(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Collects all of the values of the given property and returns their sum
            @param {String} property The property to sum by
            @param {String} root Optional 'root' property to extract the first argument from. This is used mainly when
            summing fields in records, where the fields are all stored inside the 'data' object
            @param {Number} start (optional) The record index to start at (defaults to <tt>0</tt>)
            @param {Number} end (optional) The record index to end at (defaults to <tt>-1</tt>)
            @return {Number} The total
            </summary>
        </member>
        <member name="P:Ext.util.AbstractMixedCollection.allowFunctions">
            <summary>
            @cfg {Boolean} allowFunctions Specify <tt>true</tt> if the {@link #addAll}
            function should add function references to the collection. Defaults to
            <tt>false</tt>.
            </summary>
        </member>
        <member name="P:Ext.util.AbstractMixedCollection.Count">
            <summary>
            Returns the number of items in the collection.
            @return {Number} the number of items in the collection.
            </summary>
        </member>
        <member name="P:Ext.util.AbstractMixedCollectionConfig.allowFunctions">
            <summary>
            Specify <tt>true</tt> if the {@link #addAll}
            function should add function references to the collection. Defaults to
            <tt>false</tt>.
            </summary>
        </member>
        <member name="M:Ext.util.Bindable.bindStore(Ext.data.AbstractStore,System.Boolean)">
            <summary>
            Binds a store to this instance.
            @param {Ext.data.AbstractStore} store The store to bind (may be null to unbind the existing store).
            @param {Boolean} initial (Optional) true to not remove listeners
            </summary>
        </member>
        <member name="M:Ext.util.Bindable.bindStoreListeners(Ext.data.AbstractStore)">
            <summary>
            Binds listeners for this component to the store. By default it will add
            anything bound by the getStoreListeners method, however it can be overridden
            in a subclass to provide any more complicated handling.
            @protected
            @param {Ext.data.AbstractStore} store The store to bind to
            </summary>
        </member>
        <member name="M:Ext.util.Bindable.getStore">
            <summary>
            Gets the current store instance.
            @return {Ext.data.AbstractStore} The store, null if one does not exist.
            </summary>
        </member>
        <member name="M:Ext.util.Bindable.unbindStoreListeners(Ext.data.AbstractStore)">
            <summary>
            Unbinds listeners from this component to the store. By default it will remove
            anything bound by the bindStoreListeners method, however it can be overridden
            in a subclass to provide any more complicated handling.
            @protected
            @param {Ext.data.AbstractStore} store The store to unbind from
            </summary>
        </member>
        <member name="P:Ext.util.Bindable.Store">
            <summary>
            Gets the current store instance.
            @return {Ext.data.AbstractStore} The store, null if one does not exist.
            </summary>
        </member>
        <member name="T:Ext.util.DelayedTask">
            <summary>
            The DelayedTask class provides a convenient way to "buffer" the execution of a method,
            performing setTimeout where a new timeout cancels the old timeout. When called, the
            task will wait the specified time period before executing. If durng that time period,
            the task is called again, the original call will be cancelled. This continues so that
            the function is only called a single time for each iteration.
            *
            This method is especially useful for things like detecting whether a user has finished
            typing in a text field. An example would be performing validation on a keypress. You can
            use this class to buffer the keypress events for a certain number of milliseconds, and
            perform only if they stop for that amount of time.  Usage:
            *
            var task = new Ext.util.DelayedTask(function(){
            alert(Ext.getDom('myInputField').value.length);
            });
            // Wait 500ms before calling our function. If the user presses another key
            // during that 500ms, it will be cancelled and we'll wait another 500ms.
            Ext.get('myInputField').on('keypress', function(){
            task.{@link #delay}(500);
            });
            *
            Note that we are using a DelayedTask here to illustrate a point. The configuration
            option `buffer` for {@link Ext.util.Observable#addListener addListener/on} will
            also setup a delayed task for you to buffer events.
            *
            @constructor
            The parameters to this constructor serve as defaults and are not required.
            @param {Function} [fn] The default function to call.
            @param {Object} [scope] The default scope (The `this` reference) in which the
            function is called. If not specified, `this` will refer to the browser window.
            @param {Array} [args] The default Array of arguments.
            </summary>
        </member>
        <member name="M:Ext.util.DelayedTask.#ctor(SharpKit.JavaScript.JsAction,System.Object,SharpKit.JavaScript.JsArray)">
            <summary>
            The DelayedTask class provides a convenient way to "buffer" the execution of a method,
            performing setTimeout where a new timeout cancels the old timeout. When called, the
            task will wait the specified time period before executing. If durng that time period,
            the task is called again, the original call will be cancelled. This continues so that
            the function is only called a single time for each iteration.
            *
            This method is especially useful for things like detecting whether a user has finished
            typing in a text field. An example would be performing validation on a keypress. You can
            use this class to buffer the keypress events for a certain number of milliseconds, and
            perform only if they stop for that amount of time.  Usage:
            *
            var task = new Ext.util.DelayedTask(function(){
            alert(Ext.getDom('myInputField').value.length);
            });
            // Wait 500ms before calling our function. If the user presses another key
            // during that 500ms, it will be cancelled and we'll wait another 500ms.
            Ext.get('myInputField').on('keypress', function(){
            task.{@link #delay}(500);
            });
            *
            Note that we are using a DelayedTask here to illustrate a point. The configuration
            option `buffer` for {@link Ext.util.Observable#addListener addListener/on} will
            also setup a delayed task for you to buffer events.
            *
            @constructor
            The parameters to this constructor serve as defaults and are not required.
            @param {Function} [fn] The default function to call.
            @param {Object} [scope] The default scope (The `this` reference) in which the
            function is called. If not specified, `this` will refer to the browser window.
            @param {Array} [args] The default Array of arguments.
            </summary>
        </member>
        <member name="M:Ext.util.Draggable.#ctor(System.Object)">
            <summary>
            Creates new Draggable.
            @param {Mixed} el The element you want to make draggable.
            @param {Object} config The configuration object for this Draggable.
            </summary>
        </member>
        <member name="M:Ext.util.Draggable.disable">
            <summary>
            Disable the Draggable.
            @return {Ext.util.Draggable} This Draggable instance
            </summary>
        </member>
        <member name="M:Ext.util.Draggable.enable">
            <summary>
            Enable the Draggable.
            @return {Ext.util.Draggable} This Draggable instance
            </summary>
        </member>
        <member name="P:Ext.util.Draggable.isDraggable">
            <summary>
            A core util class to bring Draggable behavior to any DOM element,
            acts as a base class for Scroller and Sortable.
            </summary>
        </member>
        <member name="P:Ext.util.DraggableConfig.cancelSelector">
            <summary>
            A simple CSS selector that represents elements within the draggable
            that should NOT initiate a drag.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.util.DraggableConfig.delay">
            <summary>
            How many milliseconds a user must hold the draggable before starting a
            drag operation.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.util.DraggableConfig.direction">
            <summary>
            Possible values: 'vertical', 'horizontal', or 'both'
            @accessor
            </summary>
        </member>
        <member name="P:Ext.util.DraggableConfig.group">
            <summary>
            Draggable and Droppable objects can participate in a group which are
            capable of interacting.
            @accessor
            </summary>
        </member>
        <member name="P:Ext.util.DraggableConfig.revert">
            <summary>
            Whether or not the element or it's proxy will be reverted back (with animation)
            when it's not dropped and held by a Droppable
            @accessor
            </summary>
        </member>
        <member name="M:Ext.util.Droppable.#ctor(System.Object,System.Object)">
            <summary>
            Creates new Droppable.
            @param {Mixed} el String, HtmlElement or Ext.Element representing an
            element on the page.
            @param {Object} config Configuration options for this class.
            </summary>
        </member>
        <member name="M:Ext.util.Droppable.disable">
            <summary>
            Disable the Droppable target.
            </summary>
        </member>
        <member name="M:Ext.util.Droppable.enable">
            <summary>
            Enable the Droppable target.
            This is invoked immediately after constructing a Droppable if the
            disabled parameter is NOT set to true.
            </summary>
        </member>
        <member name="M:Ext.util.Droppable.isDisabled">
            <summary>
            Method to determine whether this Component is currently disabled.
            @return {Boolean} the disabled state of this Component.
            </summary>
        </member>
        <member name="M:Ext.util.Droppable.isMonitoring">
            <summary>
            Method to determine whether this Droppable is currently monitoring drag operations of Draggables.
            @return {Boolean} the monitoring state of this Droppable
            </summary>
        </member>
        <member name="P:Ext.util.Droppable.disabled">
            <summary>
            @cfg {Boolean} disabled
            </summary>
        </member>
        <member name="P:Ext.util.Droppable.group">
            <summary>
            @cfg {String} group
            Draggable and Droppable objects can participate in a group which are
            capable of interacting.
            </summary>
        </member>
        <member name="P:Ext.util.Droppable.validDropMode">
            <summary>
            @cfg {String} validDropMode
            Determines when a drop is considered 'valid' whether it simply need to
            intersect the region or if it needs to be contained within the region.
            Valid values are: 'intersects' or 'contains'
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.activeCls">
            <summary>
            The CSS added to a Droppable when a Draggable in the same group is being
            dragged.
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.disabled">
            <summary>
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.group">
            <summary>
            Draggable and Droppable objects can participate in a group which are
            capable of interacting.
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.hoverCls">
            <summary>
            The CSS class to add to the droppable when hovering over a valid drop.
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.invalidCls">
            <summary>
            The CSS class to add to the droppable when dragging a draggable that is
            not in the same group.
            </summary>
        </member>
        <member name="P:Ext.util.DroppableConfig.validDropMode">
            <summary>
            Determines when a drop is considered 'valid' whether it simply need to
            intersect the region or if it needs to be contained within the region.
            Valid values are: 'intersects' or 'contains'
            </summary>
        </member>
        <member name="M:Ext.util.Filter.#ctor(System.Object)">
            <summary>
            Creates new Filter.
            @param {Object} config Config object
            </summary>
        </member>
        <member name="M:Ext.util.Filter.createFilterFn">
            <summary>
            @private
            Creates a filter function for the configured property/value/anyMatch/caseSensitive options for this Filter
            </summary>
        </member>
        <member name="M:Ext.util.Filter.createValueMatcher">
            <summary>
            @private
            Returns a regular expression based on the given value and matching options
            </summary>
        </member>
        <member name="M:Ext.util.Filter.getRoot(System.Object)">
            <summary>
            @private
            Returns the root property of the given item, based on the configured {@link #root} property
            @param {Object} item The item
            @return {Object} The root property of the object
            </summary>
        </member>
        <member name="P:Ext.util.Filter.anyMatch">
            <summary>
            @cfg {Boolean} anyMatch True to allow any match - no regex start/end line anchors will be added.
            </summary>
        </member>
        <member name="P:Ext.util.Filter.caseSensitive">
            <summary>
            @cfg {Boolean} caseSensitive True to make the regex case sensitive (adds 'i' switch to regex).
            </summary>
        </member>
        <member name="P:Ext.util.Filter.exactMatch">
            <summary>
            @cfg {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex).
            Ignored if anyMatch is true.
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.anyMatch">
            <summary>
            True to allow any match - no regex start/end line anchors will be added.
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.caseSensitive">
            <summary>
            True to make the regex case sensitive (adds 'i' switch to regex).
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.exactMatch">
            <summary>
            True to force exact match (^ and $ characters added to the regex).
            Ignored if anyMatch is true.
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.filterFn">
            <summary>
            A custom filter function which is passed each item in the {@link Ext.util.MixedCollection}
            in turn. Should return true to accept each item or false to reject it
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.property">
            <summary>
            The property to filter on. Required unless a `filter` is passed
            </summary>
        </member>
        <member name="P:Ext.util.FilterConfig.root">
            <summary>
            Optional root property. This is mostly useful when filtering a Store, in which case we set the
            root to 'data' to make the filter pull the {@link #property} out of the data object of each item
            </summary>
        </member>
        <member name="M:Ext.util.Format.date(System.Object,SharpKit.JavaScript.JsString)">
            <summary>
            Parse a value into a formatted date using the specified format pattern.
            @param {String/Date} value The value to format (Strings must conform to the format expected by the javascript
            Date object's <a href="http://www.w3schools.com/jsref/jsref_parse.asp">parse()</a> method)
            @param {String} format (optional) Any valid date format string (defaults to 'm/d/Y')
            @return {String} The formatted date string
            </summary>
        </member>
        <member name="M:Ext.util.Format.ellipsis(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,System.Boolean)">
            <summary>
            Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length
            @param {String} value The string to truncate
            @param {Number} length The maximum length to allow before truncating
            @param {Boolean} word True to try to find a common word break
            @return {String} The converted text
            </summary>
        </member>
        <member name="M:Ext.util.Format.escape(SharpKit.JavaScript.JsString)">
            <summary>
            Escapes the passed string for ' and \
            @param {String} string The string to escape
            @return {String} The escaped string
            </summary>
        </member>
        <member name="M:Ext.util.Format.escapeRegex(SharpKit.JavaScript.JsString)">
            <summary>
            Escapes the passed string for use in a regular expression
            @param {String} str
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.util.Format.format(SharpKit.JavaScript.JsString)">
            <summary>
            Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
            token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
            <pre><code>
            var cls = 'my-class', text = 'Some text';
            var s = Ext.util.Format.format('&lt;div class="{0}">{1}&lt;/div>', cls, text);
            // s now contains the string: '&lt;div class="my-class">Some text&lt;/div>'
            </code></pre>
            @param {String} string The tokenized string to be formatted
            @param {String...} values The values to replace token {0}, {1}, etc
            @return {String} The formatted string
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Ext.util.Format.htmlDecode(SharpKit.JavaScript.JsString)" -->
        <!-- Badly formed XML comment ignored for member "M:Ext.util.Format.htmlEncode(SharpKit.JavaScript.JsString)" -->
        <member name="M:Ext.util.Format.leftPad(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsString)">
            <summary>
            Pads the left side of a string with a specified character.  This is especially useful
            for normalizing number and date strings.  Example usage:
            *
            <pre><code>
            var s = Ext.util.Format.leftPad('123', 5, '0');
            // s now contains the string: '00123'
            </code></pre>
            @param {String} string The original string
            @param {Number} size The total length of the output string
            @param {String} char (optional) The character with which to pad the original string (defaults to empty string " ")
            @return {String} The padded string
            </summary>
        </member>
        <member name="M:Ext.util.Format.toggle(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString)">
            <summary>
            Utility function that allows you to easily switch a string between two alternating values.  The passed value
            is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
            they are already different, the first value passed in is returned.  Note that this method returns the new value
            but does not change the current string.
            <pre><code>
            // alternate sort directions
            sort = Ext.util.Format.toggle(sort, 'ASC', 'DESC');
            // instead of conditional logic:
            sort = (sort == 'ASC' ? 'DESC' : 'ASC');
            </code></pre>
            @param {String} string The current string
            @param {String} value The value to compare to the current string
            @param {String} other The new value to use if the string already equals the first value passed in
            @return {String} The new value
            </summary>
        </member>
        <member name="M:Ext.util.Format.trim(SharpKit.JavaScript.JsString)">
            <summary>
            Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
            <pre><code>
            var s = '  foo bar  ';
            alert('-' + s + '-');         //alerts "- foo bar -"
            alert('-' + Ext.util.Format.trim(s) + '-');  //alerts "-foo bar-"
            </code></pre>
            @param {String} string The string to escape
            @return {String} The trimmed string
            </summary>
        </member>
        <member name="P:Ext.util.Format.defaultDateFormat">
            <summary>
            Reusable data formatting functions
            </summary>
        </member>
        <member name="P:Ext.util.Format.singleton">
            <summary>
            Reusable data formatting functions
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.getLocation(System.Object,System.Object)">
            <summary>
            @private
            Returns cached coordinates, and updates if there are no cached coords yet.
            @deprecated
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.setAllowHighAccuracy(SharpKit.JavaScript.JsNumber)">
            <summary>
            Changes the {@link #allowHighAccuracy} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} allowHighAccuracy The value to set the allowHighAccuracy option to.
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.setAutoUpdate(System.Boolean)">
            <summary>
            Enabled/disables the auto-retrieval of the location information.<br/>
            If called with autoUpdate=true, it will execute an immediate location update
            and continue monitoring for location updates.<br/>
            If autoUpdate=false, any current location change monitoring will be disabled.
            A {@link #locationerror} event is fired if the location cannot be determined due
            di an error supporting geolocation.
            @param {Boolean} autoUpdate Whether to start/stop location monitoring.
            @return {Boolean} If enabling autoUpdate, returns false if the location tracking
            cannot begin due to an error supporting geolocation.
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.setMaximumAge(SharpKit.JavaScript.JsNumber)">
            <summary>
            Changes the {@link #maximumAge} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} maximumAge The value to set the maximumAge option to.
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.setTimeout(SharpKit.JavaScript.JsNumber)">
            <summary>
            Changes the {@link #timeout} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} timeout The value to set the timeout option to.
            </summary>
        </member>
        <member name="M:Ext.util.GeoLocation.updateLocation(SharpKit.JavaScript.JsAction,System.Object,System.Object)">
            <summary>
            Executes a onetime location update operation,
            raising either a {@link #locationupdate} or {@link #locationerror} event.<br/>
            Does not interfere with or restart ongoing location monitoring.
            @param {Function} callback
            A callback method to be called when the location retrieval has been completed.<br/>
            Will be called on both success and failure.<br/>
            The method will be passed one parameter, {@link Ext.util.GeoLocation} (<b>this</b> reference),
            set to null on failure.
            <pre><code>
            geo.updateLocation(function (geo) {
            alert('Latitude: ' + (geo != null ? geo.latitude : 'failed'));
            });
            </code></pre>
            @param {Object} scope (optional)
            (optional) The scope (<b>this</b> reference) in which the handler function is executed.
            <b>If omitted, defaults to the object which fired the event.</b>
            <!--positonOptions undocumented param, see W3C spec-->
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.accuracy">
            <summary>
            Read-only property representing the last retrieved
            accuracy level of the latitude and longitude coordinates,
            specified in meters.<br/>
            This will always be a non-negative number.<br/>
            This corresponds to a 95% confidence level.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.allowHighAccuracy">
            <summary>
            @cfg {Boolean} allowHighAccuracy
            When set to true, provide a hint that the application would like to receive
            the best possible results. This may result in slower response times or increased power consumption.
            The user might also deny this capability, or the device might not be able to provide more accurate
            results than if this option was set to false.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.AllowHighAccuracy">
            <summary>
            Changes the {@link #allowHighAccuracy} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} allowHighAccuracy The value to set the allowHighAccuracy option to.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.altitude">
            <summary>
            Read-only property representing the last retrieved
            height of the position, specified in meters above the ellipsoid
            <a href="http://dev.w3.org/geo/api/spec-source.html#ref-wgs">[WGS84]</a>.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.altitudeAccuracy">
            <summary>
            Read-only property representing the last retrieved
            accuracy level of the altitude coordinate, specified in meters.<br/>
            If altitude is not null then this will be a non-negative number.
            Otherwise this returns null.<br/>
            This corresponds to a 95% confidence level.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.autoUpdate">
            <summary>
            @cfg {Boolean} autoUpdate
            When set to true, continually monitor the location of the device (beginning immediately)
            and fire {@link #locationupdate}/{@link #locationerror} events.
            When using google gears, if the user denies access or another error occurs, this will be reset to false.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.AutoUpdate">
            <summary>
            Enabled/disables the auto-retrieval of the location information.<br/>
            If called with autoUpdate=true, it will execute an immediate location update
            and continue monitoring for location updates.<br/>
            If autoUpdate=false, any current location change monitoring will be disabled.
            A {@link #locationerror} event is fired if the location cannot be determined due
            di an error supporting geolocation.
            @param {Boolean} autoUpdate Whether to start/stop location monitoring.
            @return {Boolean} If enabling autoUpdate, returns false if the location tracking
            cannot begin due to an error supporting geolocation.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.heading">
            <summary>
            Read-only property representing the last retrieved
            direction of travel of the hosting device,
            specified in non-negative degrees between 0 and 359,
            counting clockwise relative to the true north.<br/>
            If speed is 0 (device is stationary), then this returns NaN
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.latitude">
            <summary>
            Read-only property representing the last retrieved
            geographical coordinate specified in degrees.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.longitude">
            <summary>
            Read-only property representing the last retrieved
            geographical coordinate specified in degrees.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.maximumAge">
            <summary>
            @cfg {Number} maximumAge
            This option indicates that the application is willing to accept cached location information whose age
            is no greater than the specified time in milliseconds. If maximumAge is set to 0, an attempt to retrieve
            new location information is made immediately.<br/>
            Setting the maximumAge to Infinity returns a cached position regardless of its age.<br/>
            If the device does not have cached location information available whose age is no
            greater than the specified maximumAge, then it must acquire new location information.<br/>
            For example, if location information no older than 10 minutes is required, set this property to 600000.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.MaximumAge">
            <summary>
            Changes the {@link #maximumAge} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} maximumAge The value to set the maximumAge option to.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.speed">
            <summary>
            Read-only property representing the last retrieved
            current ground speed of the device, specified in meters per second.<br/>
            If this feature is unsupported by the device, this returns null.<br/>
            If the device is stationary, this returns 0,
            otherwise it returns a non-negative number.
            @type Number
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.Timeout">
            <summary>
            Changes the {@link #timeout} option and restarts any active
            location monitoring with the updated setting.
            @param {Number} timeout The value to set the timeout option to.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocation.timestamp">
            <summary>
            Read-only property representing when the last retrieved
            positioning information was acquired by the device.
            @type Date
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocationConfig.allowHighAccuracy">
            <summary>
            When set to true, provide a hint that the application would like to receive
            the best possible results. This may result in slower response times or increased power consumption.
            The user might also deny this capability, or the device might not be able to provide more accurate
            results than if this option was set to false.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocationConfig.autoUpdate">
            <summary>
            When set to true, continually monitor the location of the device (beginning immediately)
            and fire {@link #locationupdate}/{@link #locationerror} events.
            When using google gears, if the user denies access or another error occurs, this will be reset to false.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocationConfig.maximumAge">
            <summary>
            This option indicates that the application is willing to accept cached location information whose age
            is no greater than the specified time in milliseconds. If maximumAge is set to 0, an attempt to retrieve
            new location information is made immediately.<br/>
            Setting the maximumAge to Infinity returns a cached position regardless of its age.<br/>
            If the device does not have cached location information available whose age is no
            greater than the specified maximumAge, then it must acquire new location information.<br/>
            For example, if location information no older than 10 minutes is required, set this property to 600000.
            </summary>
        </member>
        <member name="P:Ext.util.GeoLocationConfig.timeout">
            <summary>
            The maximum number of milliseconds allowed to elapse between a location update operation
            and the corresponding {@link #locationupdate} event being raised.  If a location was not successfully
            acquired before the given timeout elapses (and no other internal errors have occurred in this interval),
            then a {@link #locationerror} event will be raised indicating a timeout as the cause.<br/>
            Note that the time that is spent obtaining the user permission is <b>not</b> included in the period
            covered by the timeout.  The timeout attribute only applies to the location acquisition operation.<br/>
            In the case of calling updateLocation, the {@link #locationerror} event will be raised only once.<br/>
            If {@link #autoUpdate} is set to true, the {@link #locationerror} event could be raised repeatedly.
            The first timeout is relative to the moment {@link #autoUpdate} was set to true
            (or this {@link Ext.util.GeoLocation} was initialized with the {@link #autoUpdate} config option set to true).
            Subsequent timeouts are relative to the moment when the device determines that it's position has changed.
            </summary>
        </member>
        <member name="M:Ext.util.Grouper.getGroupString(Ext.data.Model)">
            <summary>
            Function description
            @param {Ext.data.Model} instance The Model instance
            @return {String} The group string for this model
            </summary>
        </member>
        <member name="P:Ext.util.Grouper.extend">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.add(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Add a new item to the hash. An exception will be thrown if the key already exists.
            @param {String} key The key of the new item.
            @param {Object} value The value of the new item.
            @return {Object} The value of the new item added.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.clear(System.Object)">
            <summary>
            private
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.clone">
            <summary>
            Performs a shallow copy on this hash.
            @return {Ext.util.HashMap} The new hash object.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.#ctor(System.Object)">
            <summary>
            Creates new HashMap.
            @param {Object} config The configuration options
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.contains(System.Object)">
            <summary>
            Checks whether a value exists in the hash.
            @param {Object} value The value to check for.
            @return {Boolean} True if the value exists in the dictionary.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.containsKey(SharpKit.JavaScript.JsString)">
            <summary>
            Checks whether a key exists in the hash.
            @param {String} key The key to check for.
            @return {Boolean} True if they key exists in the hash.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.each(SharpKit.JavaScript.JsAction,System.Object)">
            <summary>
            Executes the specified function once for each item in the hash.
            Returning false from the function will cease iteration.
            *
            The paramaters passed to the function are:
            <div class="mdetail-params"><ul>
            <li><b>key</b> : String<p class="sub-desc">The key of the item</p></li>
            <li><b>value</b> : Number<p class="sub-desc">The value of the item</p></li>
            <li><b>length</b> : Number<p class="sub-desc">The total number of items in the hash</p></li>
            </ul></div>
            @param {Function} fn The function to execute.
            @param {Object} scope The scope to execute in. Defaults to <tt>this</tt>.
            @return {Ext.util.HashMap} this
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.findKey(System.Object)">
            <summary>
            @private
            Find the key for a value.
            @param {Object} value The value to find.
            @return {Object} The value of the item. Returns <tt>undefined</tt> if not found.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.get(SharpKit.JavaScript.JsString)">
            <summary>
            Retrieves an item with a particular key.
            @param {String} key The key to lookup.
            @return {Object} The value at that key. If it doesn't exist, <tt>undefined</tt> is returned.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getArray(System.Boolean)">
            <summary>
            Gets either the keys/values in an array from the hash.
            @private
            @param {Boolean} isKey True to extract the keys, otherwise, the value
            @return {Array} An array of either keys/values from the hash.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getCount">
            <summary>
            Gets the number of items in the hash.
            @return {Number} The number of items in the hash.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getData(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Implementation for being able to extract the key from an object if only
            a single argument is passed.
            @private
            @param {String} key The key
            @param {Object} value The value
            @return {Array} [key, value]
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getKey(System.Object)">
            <summary>
            Extracts the key from an object. This is a default implementation, it may be overridden
            @private
            @param {Object} o The object to get the key from
            @return {String} The key to use.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getKeys">
            <summary>
            Return all of the keys in the hash.
            @return {Array} An array of keys.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.getValues">
            <summary>
            Return all of the values in the hash.
            @return {Array} An array of values.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.remove(System.Object)">
            <summary>
            Remove an item from the hash.
            @param {Object} o The value of the item to remove.
            @return {Boolean} True if the item was successfully removed.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.removeByKey(SharpKit.JavaScript.JsString)">
            <summary>
            Remove an item from the hash.
            @param {String} key The key to remove.
            @return {Boolean} True if the item was successfully removed.
            </summary>
        </member>
        <member name="M:Ext.util.HashMap.replace(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Replaces an item in the hash. If the key doesn't exist, the
            {@link #add} method will be used.
            @param {String} key The key of the item.
            @param {Object} value The new value for the item.
            @return {Object} The new value of the item.
            </summary>
        </member>
        <member name="P:Ext.util.HashMap.Count">
            <summary>
            Gets the number of items in the hash.
            @return {Number} The number of items in the hash.
            </summary>
        </member>
        <member name="P:Ext.util.HashMap.Keys">
            <summary>
            Return all of the keys in the hash.
            @return {Array} An array of keys.
            </summary>
        </member>
        <member name="P:Ext.util.HashMap.Values">
            <summary>
            Return all of the values in the hash.
            @return {Array} An array of values.
            </summary>
        </member>
        <member name="P:Ext.util.HashMapConfig.keyFn">
            <summary>
            A function that is used to retrieve a default key for a passed object.
            A default is provided that returns the **id** property on the object.
            This function is only used if the add method is called with a single argument.
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.classify(SharpKit.JavaScript.JsString)">
            <summary>
            Returns the correct {@link Ext.data.Model Model} name for a given string. Mostly used internally by the data
            package
            @param {String} word The word to classify
            @return {String} The classified version of the word
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.clearPlurals">
            <summary>
            Removes all registered pluralization rules
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.clearSingulars">
            <summary>
            Removes all registered singularization rules
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.isTransnumeral(SharpKit.JavaScript.JsString)">
            <summary>
            Returns true if the given word is transnumeral (the word is its own singular and plural form - e.g. sheep, fish)
            @param {String} word The word to test
            @return {Boolean} True if the word is transnumeral
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.ordinalize(SharpKit.JavaScript.JsNumber)">
            <summary>
            Ordinalizes a given number by adding a prefix such as 'st', 'nd', 'rd' or 'th' based on the last digit of the
            number. 21 -> 21st, 22 -> 22nd, 23 -> 23rd, 24 -> 24th etc
            @param {Number} number The number to ordinalize
            @return {String} The ordinalized number
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.plural(SharpKit.JavaScript.JsRegExp,SharpKit.JavaScript.JsString)">
            <summary>
            Adds a new pluralization rule to the Inflector. See the intro docs for more information
            @param {RegExp} matcher The matcher regex
            @param {String} replacer The replacement string, which can reference matches from the matcher argument
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.pluralize(SharpKit.JavaScript.JsString)">
            <summary>
            Returns the pluralized form of a word (e.g. Ext.util.Inflector.pluralize('word') returns 'words')
            @param {String} word The word to pluralize
            @return {String} The pluralized form of the word
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.singular(SharpKit.JavaScript.JsRegExp,SharpKit.JavaScript.JsString)">
            <summary>
            Adds a new singularization rule to the Inflector. See the intro docs for more information
            @param {RegExp} matcher The matcher regex
            @param {String} replacer The replacement string, which can reference matches from the matcher argument
            </summary>
        </member>
        <member name="M:Ext.util.Inflector.singularize(SharpKit.JavaScript.JsString)">
            <summary>
            Returns the singularized form of a word (e.g. Ext.util.Inflector.singularize('words') returns 'word')
            @param {String} word The word to singularize
            @return {String} The singularized form of the word
            </summary>
        </member>
        <member name="P:Ext.util.Inflector.singleton">
            <summary>
            Begin Definitions
            </summary>
        </member>
        <member name="M:Ext.util.JSONP.request(System.Object)">
            <summary>
            Make a cross-domain request using JSONP.
            @param {Object} config
            Valid configurations are:
            <ul>
            <li>url - {String} - Url to request data from. (required) </li>
            <li>params - {Object} - A set of key/value pairs to be url encoded and passed as GET parameters in the request.</li>
            <li>callbackKey - {String} - Key specified by the server-side provider.</li>
            <li>callback - {Function} - Will be passed a single argument of the result of the request.</li>
            <li>scope - {Scope} - Scope to execute your callback in.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Ext.util.JSONP.current">
            <summary>
            Read-only current executing request
            @type Object
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.util.JSONP.singleton" -->
        <member name="M:Ext.util.MixedCollection._sort(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction)">
            <summary>
            @private
            Performs the actual sorting based on a direction and a sorting function. Internally,
            this creates a temporary array of all items in the MixedCollection, sorts it and then writes
            the sorted array data back into this.items and this.keys
            @param {String} property Property to sort by ('key', 'value', or 'index')
            @param {String} dir (optional) Direction to sort 'ASC' or 'DESC'. Defaults to 'ASC'.
            @param {Function} fn (optional) Comparison function that defines the sort order.
            Defaults to sorting by numeric value.
            </summary>
        </member>
        <member name="M:Ext.util.MixedCollection.#ctor">
            <summary>
            Creates new MixedCollection.
            @param {Boolean} allowFunctions Specify <tt>true</tt> if the {@link #addAll}
            function should add function references to the collection. Defaults to
            <tt>false</tt>.
            @param {Function} keyFn A function that can accept an item of the type(s) stored in this MixedCollection
            and return the key value for that item.  This is used when available to look up the key on items that
            were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
            equivalent to providing an implementation for the {@link #getKey} method.
            </summary>
        </member>
        <member name="M:Ext.util.MixedCollection.reorder(System.Object)">
            <summary>
            Reorders each of the items based on a mapping from old index to new index. Internally this
            just translates into a sort. The 'sort' event is fired whenever reordering has occured.
            @param {Object} mapping Mapping from old item index to new item index
            </summary>
        </member>
        <member name="M:Ext.util.MixedCollection.sortBy(SharpKit.JavaScript.JsAction)">
            <summary>
            Sorts the collection by a single sorter function
            @param {Function} sorterFn The function to sort by
            </summary>
        </member>
        <member name="M:Ext.util.MixedCollection.sortByKey(SharpKit.JavaScript.JsString,SharpKit.JavaScript.JsAction)">
            <summary>
            Sorts this collection by <b>key</b>s.
            @param {String} direction (optional) 'ASC' or 'DESC'. Defaults to 'ASC'.
            @param {Function} fn (optional) Comparison function that defines the sort order.
            Defaults to sorting by case insensitive string.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Ext.util.MixedCollection.extend" -->
        <member name="M:Ext.util.Point.clone">
            <summary>
            Copy a new instance of this point
            @return {Ext.util.Point} the new point
            </summary>
        </member>
        <member name="M:Ext.util.Point.copy">
            <summary>
            Clones this Point. Deprecated, please use {@link #clone} instead
            @deprecated 2.0.0
            </summary>
        </member>
        <member name="M:Ext.util.Point.copyFrom(System.Object)">
            <summary>
            Copy the x and y values of another point / object to this point itself
            @param {Ext.util.Point/Object} point
            @return {Ext.util.Point} this This point
            </summary>
        </member>
        <member name="M:Ext.util.Point.equals(System.Object)">
            <summary>
            Compare this point and another point
            @param {Ext.util.Point/Object} The point to compare with, either an instance
            of Ext.util.Point or an object with x and y properties
            @return {Boolean} Returns whether they are equivalent
            </summary>
        </member>
        <member name="M:Ext.util.Point.isCloseTo(System.Object,System.Object)">
            <summary>
            Whether the given point is not away from this point within the given threshold amount
            @param {Ext.util.Point/Object} The point to check with, either an instance
            of Ext.util.Point or an object with x and y properties
            @param {Object/Number} threshold Can be either an object with x and y properties or a number
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Point.isWithin">
            <summary>
            Returns true if this point is close to another one. Deprecated, please use {@link #isCloseTo} instead
            @deprecated 2.0.0
            </summary>
        </member>
        <member name="M:Ext.util.Point.roundedEquals(System.Object)">
            <summary>
            Compare this point with another point when the x and y values of both points are rounded. E.g:
            [100.3,199.8] will equals to [100, 200]
            @param {Ext.util.Point/Object} The point to compare with, either an instance
            of Ext.util.Point or an object with x and y properties
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Point.toString">
            <summary>
            Returns a human-eye-friendly string that represents this point,
            useful for debugging
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.util.Point.translate(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Translate this point by the given amounts
            @param {Number} x Amount to translate in the x-axis
            @param {Number} y Amount to translate in the y-axis
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Region.adjust(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Modifies the current region to be adjusted by offsets.
            @param {Number} top top offset
            @param {Number} right right offset
            @param {Number} bottom bottom offset
            @param {Number} left left offset
            </summary>
        </member>
        <member name="M:Ext.util.Region.constrainTo(Ext.util.Region)">
            <summary>
            Modifies the current region to be constrained to the targetRegion.
            @param {Ext.util.Region} targetRegion
            </summary>
        </member>
        <member name="M:Ext.util.Region.#ctor(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Creates new Region.
            @param {Number} top Top
            @param {Number} right Right
            @param {Number} bottom Bottom
            @param {Number} left Left
            </summary>
        </member>
        <member name="M:Ext.util.Region.contains(Ext.util.Region)">
            <summary>
            Checks if this region completely contains the region that is passed in.
            @param {Ext.util.Region} region
            </summary>
        </member>
        <member name="M:Ext.util.Region.copy">
            <summary>
            Copy a new instance
            @return {Ext.util.Region}
            </summary>
        </member>
        <member name="M:Ext.util.Region.equals(Ext.util.Region)">
            <summary>
            Check whether this region is equivalent to the given region
            @param {Ext.util.Region} region The region to compare with
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Region.getOutOfBoundOffset(SharpKit.JavaScript.JsString,Ext.util.Point)">
            <summary>
            Get the offset amount of a point outside the region
            @param {String} axis optional
            @param {Ext.util.Point} p the point
            @return {Ext.util.Offset}
            </summary>
        </member>
        <member name="M:Ext.util.Region.getOutOfBoundOffsetX(SharpKit.JavaScript.JsNumber)">
            <summary>
            Get the offset amount on the x-axis
            @param {Number} p the offset
            @return {Number}
            </summary>
        </member>
        <member name="M:Ext.util.Region.getOutOfBoundOffsetY(SharpKit.JavaScript.JsNumber)">
            <summary>
            Get the offset amount on the y-axis
            @param {Number} p the offset
            @return {Number}
            </summary>
        </member>
        <member name="M:Ext.util.Region.getSize">
            <summary>
            Get the width / height of this region
            @return {Object} an object with width and height properties
            </summary>
        </member>
        <member name="M:Ext.util.Region.intersect(Ext.util.Region)">
            <summary>
            Checks if this region intersects the region passed in.
            @param {Ext.util.Region} region
            @return {Ext.util.Region/Boolean} Returns the intersected region or false if there is no intersection.
            </summary>
        </member>
        <member name="M:Ext.util.Region.isOutOfBound(SharpKit.JavaScript.JsString,System.Object)">
            <summary>
            Check whether the point / offset is out of bound
            @param {String} axis optional
            @param {Ext.util.Point/Number} p the point / offset
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Region.isOutOfBoundX(SharpKit.JavaScript.JsNumber)">
            <summary>
            Check whether the offset is out of bound in the x-axis
            @param {Number} p the offset
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Region.isOutOfBoundY(SharpKit.JavaScript.JsNumber)">
            <summary>
            Check whether the offset is out of bound in the y-axis
            @param {Number} p the offset
            @return {Boolean}
            </summary>
        </member>
        <member name="M:Ext.util.Region.restrict(SharpKit.JavaScript.JsString,System.Object,SharpKit.JavaScript.JsNumber)">
            <summary>
            Restrict a point within the region by a certain factor.
            @param {String} axis Optional
            @param {Ext.util.Point/Ext.util.Offset/Object} p
            @param {Number} factor
            @return {Ext.util.Point/Ext.util.Offset/Object/Number}
            </summary>
        </member>
        <member name="M:Ext.util.Region.restrictX(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Restrict an offset within the region by a certain factor, on the x-axis
            @param {Number} p
            @param {Number} factor The factor, optional, defaults to 1
            @return
            </summary>
        </member>
        <member name="M:Ext.util.Region.restrictY(SharpKit.JavaScript.JsNumber,SharpKit.JavaScript.JsNumber)">
            <summary>
            Restrict an offset within the region by a certain factor, on the y-axis
            @param {Number} p
            @param {Number} factor The factor, optional, defaults to 1
            </summary>
        </member>
        <member name="M:Ext.util.Region.round">
            <summary>
            Round all the properties of this region
            @return {Ext.util.Region} this This Region
            </summary>
        </member>
        <member name="M:Ext.util.Region.toString">
            <summary>
            Dump this to an eye-friendly string, great for debugging
            @return {String}
            </summary>
        </member>
        <member name="M:Ext.util.Region.translateBy(System.Object)">
            <summary>
            Translate this region by the given offset amount
            @param {Ext.util.Offset/Object} offset
            @return {Ext.util.Region} this This Region
            </summary>
        </member>
        <member name="M:Ext.util.Region.union(Ext.util.Region)">
            <summary>
            Returns the smallest region that contains the current AND targetRegion.
            @param {Ext.util.Region} region
            </summary>
        </member>
        <member name="P:Ext.util.Region.Size">
            <summary>
            Get the width / height of this region
            @return {Object} an object with width and height properties
            </summary>
        </member>
        <member name="M:Ext.util.Sortable.decodeSorters(SharpKit.JavaScript.JsArray)">
            <summary>
            @private
            Normalizes an array of sorter objects, ensuring that they are all Ext.util.Sorter instances
            @param {Array} sorters The sorters array
            @return {Array} Array of Ext.util.Sorter objects
            </summary>
        </member>
        <member name="M:Ext.util.Sortable.initSortable">
            <summary>
            Performs initialization of this mixin. Component classes using this mixin should call this method during their
            own initialization.
            </summary>
        </member>
        <member name="M:Ext.util.Sortable.sort(System.Object,SharpKit.JavaScript.JsString,System.Object,System.Object)">
            <summary>
            Sorts the data in the Store by one or more of its properties. Example usage:
            *
            //sort by a single field
            myStore.sort('myField', 'DESC');
            *
            //sorting by multiple fields
            myStore.sort([
            {
            property : 'age',
            direction: 'ASC'
            },
            {
            property : 'name',
            direction: 'DESC'
            }
            ]);
            *
            Internally, Store converts the passed arguments into an array of {@link Ext.util.Sorter} instances, and delegates
            the actual sorting to its internal {@link Ext.util.MixedCollection}.
            *
            When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
            *
            store.sort('myField');
            store.sort('myField');
            *
            Is equivalent to this code, because Store handles the toggling automatically:
            *
            store.sort('myField', 'ASC');
            store.sort('myField', 'DESC');
            *
            @param {String/Ext.util.Sorter[]} sorters Either a string name of one of the fields in this Store's configured
            {@link Ext.data.Model Model}, or an array of sorter configurations.
            @param {String} direction The overall direction to sort the data by. Defaults to "ASC".
            @return {Ext.util.Sorter[]}
            </summary>
        </member>
        <member name="P:Ext.util.Sortable.defaultSortDirection">
            <summary>
            @property {String} defaultSortDirection
            The default sort direction to use if one is not specified (defaults to "ASC")
            </summary>
        </member>
        <member name="P:Ext.util.Sortable.isSortable">
            <summary>
            @property {Boolean} isSortable
            Flag denoting that this object is sortable. Always true.
            </summary>
        </member>
        <member name="M:Ext.util.Sorter.#ctor(System.Object)">
            <summary>
            @cfg {String} direction The direction to sort by. Defaults to ASC
            </summary>
        </member>
        <member name="M:Ext.util.Sorter.createSortFunction(System.Object)">
            <summary>
            @private
            Creates and returns a function which sorts an array by the given property and direction
            @return {Function} A function which sorts by the property/direction combination provided
            </summary>
        </member>
        <member name="M:Ext.util.Sorter.defaultSorterFn(System.Object,System.Object)">
            <summary>
            @private
            Basic default sorter function that just compares the defined property of each object
            </summary>
        </member>
        <member name="M:Ext.util.Sorter.getRoot(System.Object)">
            <summary>
            @private
            Returns the root property of the given item, based on the configured {@link #root} property
            @param {Object} item The item
            @return {Object} The root property of the object
            </summary>
        </member>
        <member name="P:Ext.util.Sorter.direction">
            <summary>
            @cfg {String} direction The direction to sort by. Defaults to ASC
            </summary>
        </member>
        <member name="P:Ext.util.SorterConfig.direction">
            <summary>
            The direction to sort by. Defaults to ASC
            </summary>
        </member>
        <member name="P:Ext.util.SorterConfig.property">
            <summary>
            The property to sort by. Required unless `sorter` is provided
            </summary>
        </member>
        <member name="P:Ext.util.SorterConfig.root">
            <summary>
            Optional root property. This is mostly useful when sorting a Store, in which case we set the
            root to 'data' to make the filter pull the {@link #property} out of the data object of each item
            </summary>
        </member>
        <member name="P:Ext.util.SorterConfig.sorterFn">
            <summary>
            A specific sorter function to execute. Can be passed instead of {@link #property}
            </summary>
        </member>
        <member name="P:Ext.util.SorterConfig.transform">
            <summary>
            A function that will be run on each value before
            it is compared in the sorter. The function will receive a single argument,
            the value.
            </summary>
        </member>
        <member name="M:Ext.util.TapRepeater.#ctor(System.Object)">
            <summary>
            Creates new TapRepeater.
            @param {Mixed} el The element to listen on
            @param {Object} config
            </summary>
        </member>
        <member name="M:Ext.viewport.Default.#ctor(System.Object)">
            <summary>
            @private
            </summary>
        </member>
        <member name="P:Ext.viewport.Default.extend">
            <summary>
            *
            </summary>
        </member>
        <member name="P:Ext.viewport.DefaultConfig.autoMaximize">
            <summary>
            Whether or not to always automatically maximize the viewport on
            first load and all subsequent orientation changes
            @accessor
            </summary>
        </member>
        <member name="P:Ext.viewport.DefaultConfig.preventPanning">
            <summary>
            Whether or not to always prevent default panning behavior of the
            browser's viewport
            @accessor
            </summary>
        </member>
        <member name="P:Ext.viewport.DefaultConfig.preventZooming">
            <summary>
            Whether or not to always prevent default zooming feature of the
            browser's viewport via finger gestures such as pinching and / or double-tapping
            @accessor
            </summary>
        </member>
    </members>
</doc>
